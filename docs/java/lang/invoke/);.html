<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/lang/invoke/);.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id=""><a href="#" class="headerlink" title=");"></a>);</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.lang.invoke.);</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>type: MethodType</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>form: final</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asTypeCache: &#x2F;<em>private</em>&#x2F;</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">private*&#x2F; final LambdaForm form;</td>
</tr>
<tr>
<td align="center"><strong>customizationCount: &#x2F;<em>non-public</em>&#x2F;</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">private*&#x2F; MethodHandle asTypeCache;</td>
</tr>
<tr>
<td align="center"><strong>FORM_OFFSET: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>initStatics(); }</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>Target(</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Internal marker interface which distinguishes (to the Java compiler) those methods which are <a href="MethodHandle.html#sigpoly">signature polymorphic</a>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>type(): MethodType</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reports the type of this method handle. Every invocation of this method handle via ‘invokeExact’ must exactly match this type.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>MethodHandle(MethodType type, LambdaForm form): &#x2F;<em>non-public</em>&#x2F;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Package-private constructor for the method handle implementation hierarchy. Method handle inheritance will be contained completely within the ‘java.lang.invoke’ package.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>invokeExact(Object… args): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match. The symbolic type descriptor at the call site of ‘invokeExact’ must exactly match this method handle’s ‘#type type’. No conversions are allowed on arguments or return values. <p> When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via ‘java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke’, via JNI, or indirectly via ‘java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect’, it will throw an ‘UnsupportedOperationException’.</td>
<td align="left">WrongMethodTypeException<br/>Throwable</td>
</tr>
<tr>
<td align="center"><strong>invoke(Object… args): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values. <p> If the call site’s symbolic type descriptor exactly matches this method handle’s ‘#type type’, the call proceeds as if by ‘#invokeExact invokeExact’. <p> Otherwise, the call proceeds as if this method handle were first adjusted by calling ‘#asType asType’ to adjust this method handle to the required type, and then the call proceeds as if by ‘#invokeExact invokeExact’ on the adjusted method handle. <p> There is no guarantee that the ‘asType’ call is actually made. If the JVM can predict the results of making the call, it may perform adaptations directly on the caller’s arguments, and call the target method handle according to its own exact type. <p> The resolved type descriptor at the call site of ‘invoke’ must be a valid argument to the receivers ‘asType’ method. In particular, the caller must specify the same argument arity as the callee’s type, if the callee is not a ‘#asVarargsCollector variable arity collector’. <p> When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via ‘java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke’, via JNI, or indirectly via ‘java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect’, it will throw an ‘UnsupportedOperationException’.</td>
<td align="left">WrongMethodTypeException<br/>ClassCastException<br/>Throwable</td>
</tr>
<tr>
<td align="center"><strong>invokeBasic(Object… args): Object</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Private method for trusted invocation of a method handle respecting simplified signatures. Type mismatches will not throw ‘WrongMethodTypeException’, but could crash the JVM. <p> The caller signature is restricted to the following basic types: Object, int, long, float, double, and void return. <p> The caller is responsible for maintaining type correctness by ensuring that the each outgoing argument value is a member of the range of the corresponding callee argument type. (The caller should therefore issue appropriate casts and integer narrowing operations on outgoing argument values.) The caller can assume that the incoming result value is part of the range of the callee’s return type.</td>
<td align="left">Throwable</td>
</tr>
<tr>
<td align="center"><strong>linkToVirtual(Object… args): Object</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Private method for trusted invocation of a MemberName of kind ‘REF_invokeVirtual’. The caller signature is restricted to basic types as with ‘invokeBasic’. The trailing (not leading) argument must be a MemberName.</td>
<td align="left">Throwable</td>
</tr>
<tr>
<td align="center"><strong>linkToStatic(Object… args): Object</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Private method for trusted invocation of a MemberName of kind ‘REF_invokeStatic’. The caller signature is restricted to basic types as with ‘invokeBasic’. The trailing (not leading) argument must be a MemberName.</td>
<td align="left">Throwable</td>
</tr>
<tr>
<td align="center"><strong>linkToSpecial(Object… args): Object</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Private method for trusted invocation of a MemberName of kind ‘REF_invokeSpecial’. The caller signature is restricted to basic types as with ‘invokeBasic’. The trailing (not leading) argument must be a MemberName.</td>
<td align="left">Throwable</td>
</tr>
<tr>
<td align="center"><strong>linkToInterface(Object… args): Object</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Private method for trusted invocation of a MemberName of kind ‘REF_invokeInterface’. The caller signature is restricted to basic types as with ‘invokeBasic’. The trailing (not leading) argument must be a MemberName.</td>
<td align="left">Throwable</td>
</tr>
<tr>
<td align="center"><strong>invokeWithArguments(Object… arguments): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact ‘#invoke invoke’ from a call site which mentions only the type ‘Object’, and whose arity is the length of the argument list. <p> Specifically, execution proceeds as if by the following steps, although the methods are not guaranteed to be called if the JVM can predict their effects. <ul> <li>Determine the length of the argument array as ‘N’. For a null reference, ‘N&#x3D;0’. </li> <li>Determine the general type ‘TN’ of ‘N’ arguments as as ‘TN&#x3D;MethodType.genericMethodType(N)’.</li> <li>Force the original target method handle ‘MH0’ to the required type, as ‘MH1 &#x3D; MH0.asType(TN)’. </li> <li>Spread the array into ‘N’ separate arguments ‘A0, …’. </li> <li>Invoke the type-adjusted method handle on the unpacked arguments: MH1.invokeExact(A0, …). </li> <li>Take the return value as an ‘Object’ reference. </li> </ul> <p> Because of the action of the ‘asType’ step, the following argument conversions are applied as necessary: <ul> <li>reference casting <li>unboxing <li>widening primitive conversions </ul> <p> The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void. <p> This call is equivalent to the following code: <blockquote><pre>'MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0); Object result = invoker.invokeExact(this, arguments);'</pre></blockquote> <p> Unlike the signature polymorphic methods ‘invokeExact’ and ‘invoke’, ‘invokeWithArguments’ can be accessed normally via the Core Reflection API and JNI. It can therefore be used as a bridge between native or reflective code and method handles.</td>
<td align="left">WrongMethodTypeException<br/>ClassCastException<br/>Throwable</td>
</tr>
<tr>
<td align="center"><strong>invokeWithArguments(java.util.List&lt;?&gt; arguments): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact ‘#invoke invoke’ from a call site which mentions only the type ‘Object’, and whose arity is the length of the argument array. <p> This method is also equivalent to the following code: <blockquote><pre>'invokeWithArguments(arguments.toArray()'</pre></blockquote></td>
<td align="left">WrongMethodTypeException<br/>ClassCastException<br/>NullPointerException<br/>Throwable</td>
</tr>
<tr>
<td align="center"><strong>asType(MethodType newType): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. <p> If the original type and new type are equal, returns ‘this’. <p> The new method handle, when invoked, will perform the following steps: <ul> <li>Convert the incoming argument list to match the original method handle’s argument list. <li>Invoke the original method handle on the converted argument list. <li>Convert any result returned by the original method handle to the return type of new method handle. </ul> <p> This method provides the crucial behavioral difference between ‘#invokeExact invokeExact’ and plain, inexact ‘#invoke invoke’. The two methods perform the same steps when the caller’s type descriptor exactly m atches the callee’s, but when the types differ, plain ‘#invoke invoke’ also calls ‘asType’ (or some internal equivalent) in order to match up the caller’s and callee’s types. <p> If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as ‘#asVarargsCollector described elsewhere’. In every other case, all conversions are applied <em>pairwise</em>, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types. <p> Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types, or old and new return types.  Specifically, for some valid index ‘i’, let <em>T0</em>‘&#x3D;newType.parameterType(i)’ and <em>T1</em>‘&#x3D;this.type().parameterType(i)’. Or else, going the other way for return values, let <em>T0</em>‘&#x3D;this.type().returnType()’ and <em>T1</em>‘&#x3D;newType.returnType()’. If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: <ul> <li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) <li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.) <li>If <em>T0</em> is a primitive and <em>T1</em> a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from <em>T0</em> to its wrapper class, which is then widened as needed to <em>T1</em>.) <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value.  (These are the primitive widening conversions.) <em>T0</em> must be a wrapper class or a supertype of one. (In the case where <em>T0</em> is Object, these are the conversions allowed by ‘java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke’.) The unboxing conversion must have a possibility of success, which means that if <em>T0</em> is not itself a wrapper class, there must exist at least one wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed primitive value can be widened to <em>T1</em>. <li>If the return type <em>T1</em> is marked as void, any returned value is discarded <li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced. <li>If the return type <em>T0</em> is void and <em>T1</em> a primitive, a zero value is introduced. </ul> (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types, because neither corresponds specifically to the <em>dynamic type</em> of any actual argument or return value.) <p> The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. <p> At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a ‘java.lang.NullPointerException NullPointerException’. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a ‘java.lang.ClassCastException ClassCastException’. Although an unboxing operation may accept several kinds of wrappers, if none are available, a ‘ClassCastException’ will be thrown.</td>
<td align="left">WrongMethodTypeException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>asTypeCached(MethodType newType): MethodHandle</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asTypeUncached(MethodType newType): MethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Override this to change asType behavior.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asSpreader(Class&lt;?&gt; arrayType, int arrayLength): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Makes an <em>array-spreading</em> method handle, which accepts a trailing array argument and spreads its elements as positional arguments. The new method handle adapts, as its <i>target</i>, the current method handle.  The type of the adapter will be the same as the type of the target, except that the final ‘arrayLength’ parameters of the target’s type are replaced by a single array parameter of type ‘arrayType’. <p> If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to ‘#asType asType’. <p> When called, the adapter replaces a trailing array argument by the array’s elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and&#x2F;or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. <p> Before calling the target, the adapter verifies that the array contains exactly enough elements to provide a correct argument count to the target method handle. (The array may also be null when zero elements are required.) <p> If, when the adapter is called, the supplied array argument does not have the correct number of elements, the adapter will throw an ‘IllegalArgumentException’ instead of invoking the target. <p> Here are some simple examples of array-spreading method handles: <blockquote><pre>''</pre></blockquote></td>
<td align="left">WrongMethodTypeException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>asSpreaderChecks(Class&lt;?&gt; arrayType, int arrayLength): MethodType</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">See if ‘asSpreader’ can be validly called with the given arguments. Return the type of the method handle call after spreading but before conversions.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>spreadArrayChecks(Class&lt;?&gt; arrayType, int arrayLength): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asCollector(Class&lt;?&gt; arrayType, int arrayLength): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Makes an <em>array-collecting</em> method handle, which accepts a given number of trailing positional arguments and collects them into an array argument. The new method handle adapts, as its <i>target</i>, the current method handle.  The type of the adapter will be the same as the type of the target, except that a single trailing parameter (usually of type ‘arrayType’) is replaced by ‘arrayLength’ parameters whose type is element type of ‘arrayType’. <p> If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to ‘#asType asType’. <p> When called, the adapter replaces its trailing ‘arrayLength’ arguments by a single new array of type ‘arrayType’, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter. <p> (The array may also be a shared constant when ‘arrayLength’ is zero.) <p> (<em>Note:</em> The ‘arrayType’ is often identical to the last parameter type of the original target. It is an explicit argument for symmetry with ‘asSpreader’, and also to allow the target to use a simple ‘Object’ as its last parameter type.) <p> In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use ‘#asVarargsCollector asVarargsCollector’ instead. <p> Here are some examples of array-collecting method handles: <blockquote><pre>''</pre></blockquote></td>
<td align="left">WrongMethodTypeException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>asCollectorChecks(Class&lt;?&gt; arrayType, int arrayLength): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">See if ‘asCollector’ can be validly called with the given arguments. Return false if the last parameter is not an exact match to arrayType.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asVarargsCollector(Class&lt;?&gt; arrayType): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Makes a <em>variable arity</em> adapter which is able to accept any number of trailing positional arguments and collect them into an array argument. <p> The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain ‘invoke’ and ‘asType’ requests can lead to trailing positional arguments being collected into target’s trailing parameter. Also, the last parameter type of the adapter will be ‘arrayType’, even if the target has a different last parameter type. <p> This transformation may return ‘this’ if the method handle is already of variable arity and its trailing parameter type is identical to ‘arrayType’. <p> When called with ‘#invokeExact invokeExact’, the adapter invokes the target with no argument changes. (<em>Note:</em> This behavior is different from a ‘#asCollector fixed arity collector’, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.) <p> When called with plain, inexact ‘#invoke invoke’, if the caller type is the same as the adapter, the adapter invokes the target as with ‘invokeExact’. (This is the normal behavior for ‘invoke’ when types match.) <p> Otherwise, if the caller and adapter arity are the same, and the trailing parameter type of the caller is a reference type identical to or assignable to the trailing parameter type of the adapter, the arguments and return values are converted pairwise, as if by ‘#asType asType’ on a fixed arity method handle. <p> Otherwise, the arities differ, or the adapter’s trailing parameter type is not assignable from the corresponding caller type. In this case, the adapter replaces all trailing arguments from the original trailing argument position onward, by a new array of type ‘arrayType’, whose elements comprise (in order) the replaced arguments. <p> The caller type must provides as least enough arguments, and of the correct type, to satisfy the target’s requirement for positional arguments before the trailing array argument. Thus, the caller must supply, at a minimum, ‘N-1’ arguments, where ‘N’ is the arity of the target. Also, there must exist conversions from the incoming arguments to the target’s arguments. As with other uses of plain ‘invoke’, if these basic requirements are not fulfilled, a ‘WrongMethodTypeException’ may be thrown. <p> In all cases, what the target eventually returns is returned unchanged by the adapter. <p> In the final case, it is exactly as if the target method handle were temporarily adapted with a ‘#asCollector fixed arity collector’ to the arity required by the caller type. (As with ‘asCollector’, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to ‘asCollector’ would throw an ‘IllegalArgumentException’ or ‘WrongMethodTypeException’, the call to the variable arity adapter must throw ‘WrongMethodTypeException’.) <p> The behavior of ‘#asType asType’ is also specialized for variable arity adapters, to maintain the invariant that plain, inexact ‘invoke’ is always equivalent to an ‘asType’ call to adjust the target type, followed by ‘invokeExact’. Therefore, a variable arity adapter responds to an ‘asType’ request by building a fixed arity collector, if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of ‘asType’. <p> When a method handle is obtained by executing an ‘ldc’ instruction of a ‘CONSTANT_MethodHandle’ constant, and the target method is marked as a variable arity method (with the modifier bit ‘0x0080’), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to ‘asVarargsCollector’. <p> In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use ‘#asCollector asCollector’ instead. <p> No method handle transformations produce new method handles with variable arity, unless they are documented as doing so. Therefore, besides ‘asVarargsCollector’, all methods in ‘MethodHandle’ and ‘MethodHandles’ will return a method handle with fixed arity, except in the cases where they are specified to return their original operand (e.g., ‘asType’ of the method handle’s own type). <p> Calling ‘asVarargsCollector’ on a method handle which is already of variable arity will produce a method handle with the same type and behavior. It may (or may not) return the original variable arity method handle. <p> Here is an example, of a list-making variable arity method handle: <blockquote><pre>''</pre></blockquote> <p style="font-size:smaller;"> <em>Discussion:</em> These rules are designed as a dynamically-typed variation of the Java rules for variable arity methods. In both cases, callers to a variable arity method or method handle can either pass zero or more positional arguments, or else pass pre-collected arrays of any length.  Users should be aware of the special role of the final argument, and of the effect of a type match on that final argument, which determines whether or not a single trailing argument is interpreted as a whole array or a single element of an array to be collected. Note that the dynamic type of the trailing argument has no effect on this decision, only a comparison between the symbolic type descriptor of the call site and the type descriptor of the method handle.)</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>isVarargsCollector(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Determines if this method handle supports ‘#asVarargsCollector variable arity’ calls. Such method handles arise from the following sources: <ul> <li>a call to ‘#asVarargsCollector asVarargsCollector’ <li>a call to a ‘java.lang.invoke.MethodHandles.Lookup lookup method’ which resolves to a variable arity Java method or constructor <li>an ‘ldc’ instruction of a ‘CONSTANT_MethodHandle’ which resolves to a variable arity Java method or constructor </ul></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asFixedArity(): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Makes a <em>fixed arity</em> method handle which is otherwise equivalent to the current method handle. <p> If the current method handle is not of ‘#asVarargsCollector variable arity’, the current method handle is returned. This is true even if the current method handle could not be a valid input to ‘asVarargsCollector’. <p> Otherwise, the resulting fixed-arity method handle has the same type and behavior of the current method handle, except that ‘#isVarargsCollector isVarargsCollector’ will be false. The fixed-arity method handle may (or may not) be the a previous argument to ‘asVarargsCollector’. <p> Here is an example, of a list-making variable arity method handle: <blockquote><pre>''</pre></blockquote></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>bindTo(Object x): MethodHandle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Binds a value ‘x’ to the first argument of a method handle, without invoking it. The new method handle adapts, as its <i>target</i>, the current method handle by binding it to the given argument. The type of the bound handle will be the same as the type of the target, except that a single leading reference parameter will be omitted. <p> When called, the bound handle inserts the given value ‘x’ as a new leading argument to the target.  The other arguments are also passed unchanged. What the target eventually returns is returned unchanged by the bound handle. <p> The reference ‘x’ must be convertible to the first parameter type of the target. <p> (<em>Note:</em>  Because method handles are immutable, the target method handle retains its original type and behavior.)</td>
<td align="left">ClassCastException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a string representation of the method handle, starting with the string ‘“MethodHandle”‘ and ending with the string representation of the method handle’s type. In other words, this method returns a string equal to the value of: <blockquote><pre>'"MethodHandle" + type().toString()'</pre></blockquote> <p> (<em>Note:</em>  Future releases of this API may add further information to the string representation. Therefore, the present syntax should not be parsed by applications.)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>standardString(): String</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>debugString(): String</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return a string with a several lines describing the method handle structure. This string would be suitable for display in an IDE debugger.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>bindArgumentL(int pos, Object value): BoundMethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setVarargs(MemberName member): MethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left">IllegalAccessException</td>
</tr>
<tr>
<td align="center"><strong>viewAsType(MethodType newType, boolean strict): MethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>viewAsTypeChecks(MethodType newType, boolean strict): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalForm(): LambdaForm</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalMemberName(): MemberName</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalCallerClass(): Class&lt;?&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>intrinsicName(): MethodHandleImpl.Intrinsic</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>withInternalMemberName(MemberName member, boolean isInvokeSpecial): MethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isInvokeSpecial(): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalValues(): Object</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalProperties(): Object</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>copyWith(MethodType mt, LambdaForm lf): MethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>rebind(): BoundMethodHandle</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Require this method handle to be a BMH, or else replace it with a “wrapper” BMH. Many transforms are implemented only for BMHs.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>updateForm(LambdaForm newForm): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>customize(): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">non-public</td>
<td align="left"></td>
</tr>
</tbody></table>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
