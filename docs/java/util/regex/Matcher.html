<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/regex/Matcher.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父接口</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.regex.Matcher</strong></td>
<td align="center">class</td>
<td align="center">MatchResult</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>parentPattern: Pattern</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The Pattern object that created this Matcher.</td>
</tr>
<tr>
<td align="center"><strong>groups: int[]</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The storage used by groups. They may contain invalid values if a group was skipped during the matching.</td>
</tr>
<tr>
<td align="center"><strong>to: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The range within the sequence that is to be matched. Anchors will match at these “hard” boundaries. Changing the region changes these values.</td>
</tr>
<tr>
<td align="center"><strong>lookbehindTo: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Lookbehind uses this value to ensure that the subexpression match ends at the point where the lookbehind was encountered.</td>
</tr>
<tr>
<td align="center"><strong>text: CharSequence</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The original string being matched.</td>
</tr>
<tr>
<td align="center"><strong>ENDANCHOR: int</strong></td>
<td align="center">1</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Matcher state used by the last node. NOANCHOR is used when a match does not have to consume all of the input. ENDANCHOR is the mode used for matching all the input.</td>
</tr>
<tr>
<td align="center"><strong>NOANCHOR: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>acceptMode: int</strong></td>
<td align="center">NOANCHOR</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>first: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The range of string that last matched the pattern. If the last match failed then first is -1; last initially holds 0 then it holds the index of the end of the last match (which is where the next search starts).</td>
</tr>
<tr>
<td align="center"><strong>oldLast: int</strong></td>
<td align="center">-1</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The end index of what matched in the last match operation.</td>
</tr>
<tr>
<td align="center"><strong>lastAppendPosition: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The index of the last position appended in a substitution.</td>
</tr>
<tr>
<td align="center"><strong>locals: int[]</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Storage used by nodes to tell what repetition they are on in a pattern, and where groups begin. The nodes themselves are stateless, so they rely on this field to hold state during a match.</td>
</tr>
<tr>
<td align="center"><strong>hitEnd: boolean</strong></td>
<td align="center">false</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Boolean indicating whether or not more input could change the results of the last match.  If hitEnd is true, and a match was found, then more input might cause a different match to be found. If hitEnd is true and a match was not found, then more input could cause a match to be found. If hitEnd is false and a match was found, then more input will not change the match. If hitEnd is false and a match was not found, then more input will not cause a match to be found.</td>
</tr>
<tr>
<td align="center"><strong>requireEnd: boolean</strong></td>
<td align="center">false</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Boolean indicating whether or not more input could change a positive match into a negative one.  If requireEnd is true, and a match was found, then more input could cause the match to be lost. If requireEnd is false and a match was found, then more input might change the match but the match won’t be lost. If a match was not found, then requireEnd has no meaning.</td>
</tr>
<tr>
<td align="center"><strong>transparentBounds: boolean</strong></td>
<td align="center">false</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If transparentBounds is true then the boundaries of this matcher’s region are transparent to lookahead, lookbehind, and boundary matching constructs that try to see beyond them.</td>
</tr>
<tr>
<td align="center"><strong>anchoringBounds: boolean</strong></td>
<td align="center">true</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If anchoringBounds is true then the boundaries of this matcher’s region match anchors such as ^ and $.</td>
</tr>
<tr>
<td align="center"><strong>this: return</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Matcher()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">No default constructor.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>Matcher(Pattern parent, CharSequence text)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">All matchers have the state used by Pattern during a match.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pattern(): Pattern</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the pattern that is interpreted by this matcher.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMatchResult(): MatchResult</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the match state of this matcher as a ‘MatchResult’. The result is unaffected by subsequent operations performed upon this matcher.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>usePattern(Pattern newPattern): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Changes the <tt>Pattern</tt> that this <tt>Matcher</tt> uses to find matches with.  <p> This method causes this matcher to lose information about the groups of the last match that occurred. The matcher’s position in the input is maintained and its last append position is unaffected.</p></td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>reset(): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Resets this matcher.  <p> Resetting a matcher discards all of its explicit state information and sets its append position to zero. The matcher’s region is set to the default region, which is its entire character sequence. The anchoring and transparency of this matcher’s region boundaries are unaffected.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reset(CharSequence input): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Resets this matcher with a new input sequence.  <p> Resetting a matcher discards all of its explicit state information and sets its append position to zero.  The matcher’s region is set to the default region, which is its entire character sequence.  The anchoring and transparency of this matcher’s region boundaries are unaffected.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>start(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the start index of the previous match.</td>
<td align="left">IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>start(int group): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the start index of the subsequence captured by the given group during the previous match operation.  <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left to right, starting at one.  Group zero denotes the entire pattern, so the expression <i>m.</i><tt>start(0)</tt> is equivalent to <i>m.</i><tt>start()</tt>.  </p></td>
<td align="left">IndexOutOfBoundsException<br/>IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>start(String name): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the start index of the subsequence captured by the given <a href="Pattern.html#groupname">named-capturing group</a> during the previous match operation.</td>
<td align="left">IllegalStateException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>end(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the offset after the last character matched.</td>
<td align="left">IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>end(int group): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the offset after the last character of the subsequence captured by the given group during the previous match operation.  <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left to right, starting at one.  Group zero denotes the entire pattern, so the expression <i>m.</i><tt>end(0)</tt> is equivalent to <i>m.</i><tt>end()</tt>.  </p></td>
<td align="left">IndexOutOfBoundsException<br/>IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>end(String name): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the offset after the last character of the subsequence captured by the given <a href="Pattern.html#groupname">named-capturing group</a> during the previous match operation.</td>
<td align="left">IllegalStateException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>group(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the input subsequence matched by the previous match.  <p> For a matcher <i>m</i> with input sequence <i>s</i>, the expressions <i>m.</i><tt>group()</tt> and <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&amp;nbsp;<i>m.</i><tt>end())</tt> are equivalent.  </p>  <p> Note that some patterns, for example <tt>a*</tt>, match the empty string.  This method will return the empty string when the pattern successfully matches the empty string in the input.  </p></td>
<td align="left">IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>group(int group): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the input subsequence captured by the given group during the previous match operation.  <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index <i>g</i>, the expressions <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt> and <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&amp;nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt> are equivalent.  </p>  <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left to right, starting at one.  Group zero denotes the entire pattern, so the expression <tt>m.group(0)</tt> is equivalent to <tt>m.group()</tt>. </p>  <p> If the match was successful but the group specified failed to match any part of the input sequence, then <tt>null</tt> is returned. Note that some groups, for example <tt>(a*)</tt>, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.  </p></td>
<td align="left">IndexOutOfBoundsException<br/>IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>group(String name): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the input subsequence captured by the given <a href="Pattern.html#groupname">named-capturing group</a> during the previous match operation.  <p> If the match was successful but the group specified failed to match any part of the input sequence, then <tt>null</tt> is returned. Note that some groups, for example <tt>(a*)</tt>, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.  </p></td>
<td align="left">IllegalStateException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>groupCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the number of capturing groups in this matcher’s pattern.  <p> Group zero denotes the entire pattern by convention. It is not included in this count.  <p> Any non-negative integer smaller than or equal to the value returned by this method is guaranteed to be a valid group index for this matcher.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>matches(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to match the entire region against the pattern.  <p> If the match succeeds then more information can be obtained via the <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>find(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to find the next subsequence of the input sequence that matches the pattern.  <p> This method starts at the beginning of this matcher’s region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match.  <p> If the match succeeds then more information can be obtained via the <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>find(int start): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index.  <p> If the match succeeds then more information can be obtained via the <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods, and subsequent invocations of the ‘#find()’ method will start at the first character not matched by this match.  </p></td>
<td align="left">IndexOutOfBoundsException</td>
</tr>
<tr>
<td align="center"><strong>lookingAt(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to match the input sequence, starting at the beginning of the region, against the pattern.  <p> Like the ‘#matches matches’ method, this method always starts at the beginning of the region; unlike that method, it does not require that the entire region be matched.  <p> If the match succeeds then more information can be obtained via the <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>quoteReplacement(String s): String</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a literal replacement <code>String</code> for the specified <code>String</code>.  This method produces a <code>String</code> that will work as a literal replacement <code>s</code> in the <code>appendReplacement</code> method of the ‘Matcher’ class. The <code>String</code> produced will match the sequence of characters in <code>s</code> treated as a literal sequence. Slashes (‘&#39;) and dollar signs (‘$’) will be given no special meaning.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>appendReplacement(StringBuffer sb, String replacement): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Implements a non-terminal append-and-replace step.  <p> This method performs the following actions: </p>  <ol>  <li><p> It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer.  It stops after reading the last character preceding the previous match, that is, the character at index ‘#start()’&amp;nbsp;<tt>-</tt>&amp;nbsp;<tt>1</tt>.  </p></li>  <li><p> It appends the given replacement string to the string buffer. </p></li>  <li><p> It sets the append position of this matcher to the index of the last character matched, plus one, that is, to ‘#end()’. </p></li>  </ol>  <p> The replacement string may contain references to subsequences captured during the previous match: Each occurrence of <tt>${</tt><i>name</i><tt>}</tt> or <tt>$</tt><i>g</i> will be replaced by the result of evaluating the corresponding ‘#group(String) group(name)’ or ‘#group(int) group(g)’ respectively. For  <tt>$</tt><i>g</i>, the first number after the <tt>$</tt> is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals ‘0’ through ‘9’ are considered as potential components of the group reference. If the second group matched the string <tt>“foo”</tt>, for example, then passing the replacement string <tt>“$2bar”</tt> would cause <tt>“foobar”</tt> to be appended to the string buffer. A dollar sign (<tt>$</tt>) may be included as a literal in the replacement string by preceding it with a backslash (<tt>$</tt>).  <p> Note that backslashes (<tt>&lt;&#x2F;tt&gt;) and dollar signs (<tt>$</tt>) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  <p> This method is intended to be used in a loop together with the ‘#appendTail appendTail’ and ‘#find find’ methods.  The following code, for example, writes <tt>one dog two dogs in the yard</tt> to the standard-output stream: </p>  <blockquote><pre> Pattern p = Pattern.compile("cat"); Matcher m = p.matcher("one cat two cats in the yard"); StringBuffer sb = new StringBuffer(); while (m.find()) { m.appendReplacement(sb, "dog"); } m.appendTail(sb); System.out.println(sb.toString());</pre></blockquote></td>
<td align="left">IndexOutOfBoundsException<br/>IllegalStateException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>appendTail(StringBuffer sb): StringBuffer</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Implements a terminal append-and-replace step.  <p> This method reads characters from the input sequence, starting at the append position, and appends them to the given string buffer.  It is intended to be invoked after one or more invocations of the ‘#appendReplacement appendReplacement’ method in order to copy the remainder of the input sequence.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceAll(String replacement): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Replaces every subsequence of the input sequence that matches the pattern with the given replacement string.  <p> This method first resets this matcher.  It then scans the input sequence looking for matches of the pattern.  Characters that are not part of any match are appended directly to the result string; each match is replaced in the result by the replacement string.  The replacement string may contain references to captured subsequences as in the ‘#appendReplacement appendReplacement’ method.  <p> Note that backslashes (<tt>&lt;&#x2F;tt&gt;) and dollar signs (<tt>$</tt>) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  <p> Given the regular expression <tt>a*b</tt>, the input <tt>“aabfooaabfooabfoob”</tt>, and the replacement string <tt>“-“</tt>, an invocation of this method on a matcher for that expression would yield the string <tt>“-foo-foo-foo-“</tt>.  <p> Invoking this method changes this matcher’s state.  If the matcher is to be used in further matching operations then it should first be reset.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceFirst(String replacement): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.  <p> This method first resets this matcher.  It then scans the input sequence looking for a match of the pattern.  Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string.  The replacement string may contain references to captured subsequences as in the ‘#appendReplacement appendReplacement’ method.  <p>Note that backslashes (<tt>&lt;&#x2F;tt&gt;) and dollar signs (<tt>$</tt>) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  <p> Given the regular expression <tt>dog</tt>, the input <tt>“zzzdogzzzdogzzz”</tt>, and the replacement string <tt>“cat”</tt>, an invocation of this method on a matcher for that expression would yield the string <tt>“zzzcatzzzdogzzz”</tt>.  </p>  <p> Invoking this method changes this matcher’s state.  If the matcher is to be used in further matching operations then it should first be reset.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>region(int start, int end): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the limits of this matcher’s region. The region is the part of the input sequence that will be searched to find a match. Invoking this method resets the matcher, and then sets the region to start at the index specified by the <code>start</code> parameter and end at the index specified by the <code>end</code> parameter.  <p>Depending on the transparency and anchoring being used (see ‘#useTransparentBounds useTransparentBounds’ and ‘#useAnchoringBounds useAnchoringBounds’), certain constructs such as anchors may behave differently at or around the boundaries of the region.</td>
<td align="left">IndexOutOfBoundsException</td>
</tr>
<tr>
<td align="center"><strong>regionStart(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reports the start index of this matcher’s region. The searches this matcher conducts are limited to finding matches within ‘#regionStart regionStart’ (inclusive) and ‘#regionEnd regionEnd’ (exclusive).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>regionEnd(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reports the end index (exclusive) of this matcher’s region. The searches this matcher conducts are limited to finding matches within ‘#regionStart regionStart’ (inclusive) and ‘#regionEnd regionEnd’ (exclusive).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasTransparentBounds(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Queries the transparency of region bounds for this matcher.  <p> This method returns <tt>true</tt> if this matcher uses <i>transparent</i> bounds, <tt>false</tt> if it uses <i>opaque</i> bounds.  <p> See ‘#useTransparentBounds useTransparentBounds’ for a description of transparent and opaque bounds.  <p> By default, a matcher uses opaque region boundaries.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>useTransparentBounds(boolean b): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the transparency of region bounds for this matcher.  <p> Invoking this method with an argument of <tt>true</tt> will set this matcher to use <i>transparent</i> bounds. If the boolean argument is <tt>false</tt>, then <i>opaque</i> bounds will be used.  <p> Using transparent bounds, the boundaries of this matcher’s region are transparent to lookahead, lookbehind, and boundary matching constructs. Those constructs can see beyond the boundaries of the region to see if a match is appropriate.  <p> Using opaque bounds, the boundaries of this matcher’s region are opaque to lookahead, lookbehind, and boundary matching constructs that may try to see beyond them. Those constructs cannot look past the boundaries so they will fail to match anything outside of the region.  <p> By default, a matcher uses opaque bounds.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasAnchoringBounds(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Queries the anchoring of region bounds for this matcher.  <p> This method returns <tt>true</tt> if this matcher uses <i>anchoring</i> bounds, <tt>false</tt> otherwise.  <p> See ‘#useAnchoringBounds useAnchoringBounds’ for a description of anchoring bounds.  <p> By default, a matcher uses anchoring region boundaries.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>useAnchoringBounds(boolean b): Matcher</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the anchoring of region bounds for this matcher.  <p> Invoking this method with an argument of <tt>true</tt> will set this matcher to use <i>anchoring</i> bounds. If the boolean argument is <tt>false</tt>, then <i>non-anchoring</i> bounds will be used.  <p> Using anchoring bounds, the boundaries of this matcher’s region match anchors such as ^ and $.  <p> Without anchoring bounds, the boundaries of this matcher’s region will not match anchors such as ^ and $.  <p> By default, a matcher uses anchoring region boundaries.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"><p>Returns the string representation of this matcher. The string representation of a <code>Matcher</code> contains information that may be useful for debugging. The exact format is unspecified.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hitEnd(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"><p>Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher.  <p>When this method returns true, then it is possible that more input would have changed the result of the last search.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>requireEnd(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"><p>Returns true if more input could change a positive match into a negative one.  <p>If this method returns true, and a match was found, then more input could cause the match to be lost. If this method returns false and a match was found, then more input might change the match but the match won’t be lost. If a match was not found, then requireEnd has no meaning.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>search(int from): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initiates a search to find a Pattern within the given bounds. The groups are filled with default values and the match of the root of the state machine is called. The state machine will hold the state of the match as it proceeds in this matcher.  Matcher.from is not set here, because it is the “hard” boundary of the start of the search which anchors will set to. The from param is the “soft” boundary of the start of the search, meaning that the regex tries to match at that index but ^ won’t match there. Subsequent calls to the search methods start at a new “soft” boundary which is the end of the previous match.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>match(int from, int anchor): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initiates a search for an anchored match to a Pattern within the given bounds. The groups are filled with default values and the match of the root of the state machine is called. The state machine will hold the state of the match as it proceeds in this matcher.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTextLength(): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the end index of the text.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getSubSequence(int beginIndex, int endIndex): CharSequence</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Generates a String from this Matcher’s input in the specified range.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>charAt(int i): char</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns this Matcher’s input character at index i.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getMatchedGroupIndex(String name): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the group index of the matched capturing group.</td>
<td align="left"></td>
</tr>
</tbody></table>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
