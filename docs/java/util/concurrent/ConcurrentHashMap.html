<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ConcurrentHashMap.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ConcurrentHashMap-lt-K-V-gt"><a href="#ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="ConcurrentHashMap&lt;K,V&gt;"></a>ConcurrentHashMap&lt;K,V&gt;</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">父接口</th>
<th align="center">泛型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ConcurrentHashMap&lt;K,V&gt;</strong></td>
<td align="center">class</td>
<td align="center">AbstractMap&lt;K,V&gt;implements</td>
<td align="center">ConcurrentMap&lt;K,V&gt;,Serializable</td>
<td align="center">&lt;K&gt;,&lt;V&gt;</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>serialVersionUID: long</strong></td>
<td align="center">7249069246763182397L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>MAXIMUM_CAPACITY: int</strong></td>
<td align="center">1 &lt;&lt; 30</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">最大可能的表容量。该值必须正好为1&lt;&lt;30，才能在两个表大小的幂的Java数组分配和索引范围内，而且由于32位散列字段的前两位用于控制目的，因此更需要该值。</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT_CAPACITY: int</strong></td>
<td align="center">16</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">默认初始表容量。必须是2的幂（即至少1）且最大容量。</td>
</tr>
<tr>
<td align="center"><strong>MAX_ARRAY_SIZE: int</strong></td>
<td align="center">Integer.MAX_VALUE - 8</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能的最大（非二次幂）数组大小。toArray和相关方法所需。</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT_CONCURRENCY_LEVEL: int</strong></td>
<td align="center">16</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">此表的默认并发级别。未使用，但定义为与此类的早期版本兼容。</td>
</tr>
<tr>
<td align="center"><strong>LOAD_FACTOR: float</strong></td>
<td align="center">0.75f</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">此表的负载系数。在构造函数中重写此值仅影响初始表容量。实际的浮点值通常不使用——使用{@code n-（n&gt;&gt;&gt;2）}等表达式作为相关的调整大小阈值更简单。</td>
</tr>
<tr>
<td align="center"><strong>TREEIFY_THRESHOLD: int</strong></td>
<td align="center">8</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用树而不是列表存储箱的存储箱计数阈值。当向至少具有这么多节点的容器添加元素时，容器将转换为树。该值必须大于2，且应至少为8，以符合树木移除中关于收缩后转换回普通箱的假设。</td>
</tr>
<tr>
<td align="center"><strong>UNTREEIFY_THRESHOLD: int</strong></td>
<td align="center">6</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在调整大小操作期间取消（拆分）存储箱的存储箱计数阈值。应小于TREEIFY_ THRESHOLD，并且最多6个网格，在移除时进行收缩检测。</td>
</tr>
<tr>
<td align="center"><strong>MIN_TREEIFY_CAPACITY: int</strong></td>
<td align="center">64</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">存储箱可以树化的最小表容量。（否则，如果bin中的节点太多，则会调整表的大小。）该值应至少为4*TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。</td>
</tr>
<tr>
<td align="center"><strong>MIN_TRANSFER_STRIDE: int</strong></td>
<td align="center">16</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">每个转移步骤的最小再投球次数。范围被细分以允许多个调整器线程。此值用作下限，以避免大小调整器遇到过多内存争用。该值应至少为DEFAULT_ CAPACITY。</td>
</tr>
<tr>
<td align="center"><strong>RESIZE_STAMP_BITS: int</strong></td>
<td align="center">16</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">sizeCtl中用于生成戳记的位数。对于32位阵列，必须至少为6。</td>
</tr>
<tr>
<td align="center"><strong>MAX_RESIZERS: int</strong></td>
<td align="center">(1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可以帮助调整大小的最大线程数。必须适合32位-RESIZE_STAMP_。</td>
</tr>
<tr>
<td align="center"><strong>RESIZE_STAMP_SHIFT: int</strong></td>
<td align="center">32 - RESIZE_STAMP_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在sizeCtl中记录大小戳的位偏移。</td>
</tr>
<tr>
<td align="center"><strong>MOVED: int</strong></td>
<td align="center">-1</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">节点哈希字段的编码。请参见上面的解释。</td>
</tr>
<tr>
<td align="center"><strong>TREEBIN: int</strong></td>
<td align="center">-2</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RESERVED: int</strong></td>
<td align="center">-3</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>HASH_BITS: int</strong></td>
<td align="center">0x7fffffff</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>NCPU: int</strong></td>
<td align="center">Runtime.getRuntime().availableProcessors()</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">CPU的数量，以限制某些大小</td>
</tr>
<tr>
<td align="center"><strong>table: Node&lt;K,V&gt;[]</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">容器阵列。在第一次插入时延迟初始化。大小总是二的幂。由迭代器直接访问。</td>
</tr>
<tr>
<td align="center"><strong>nextTable: Node&lt;K,V&gt;[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">下一个要使用的表；仅在调整大小时为非null。</td>
</tr>
<tr>
<td align="center"><strong>baseCount: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">基本计数器值，主要在没有争用时使用，但在表初始化竞争期间也用作回退。通过CAS更新。</td>
</tr>
<tr>
<td align="center"><strong>sizeCtl: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">表初始化和调整大小控件。如果为负值，则表正在初始化或调整大小：-1用于初始化，否则-（1+活动调整大小线程的数量）。否则，当表为空时，将保留创建时使用的初始表大小，或默认值为0。初始化后，保存下一个要调整表大小的元素计数值。</td>
</tr>
<tr>
<td align="center"><strong>transferIndex: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">调整大小时要拆分的下一个表索引（加上一个）。</td>
</tr>
<tr>
<td align="center"><strong>cellsBusy: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">调整和&#x2F;或创建计数器单元时使用的自旋锁（通过CAS锁定）。</td>
</tr>
<tr>
<td align="center"><strong>counterCells: CounterCell[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">计数器单元格表。非空时，大小为2的幂。</td>
</tr>
<tr>
<td align="center"><strong>keySet: KeySetView&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>values: ValuesView&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySet: EntrySetView&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SIZECTL: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">任务类。以常规但难看的格式&#x2F;样式进行编码，以简化检查，确保每个变体以正确的方式与其他变体不同。空筛选的存在是因为编译器无法判断我们已经对任务参数进行了空检查，所以我们强制最简单的提升旁路来帮助避免复杂的陷阱。</td>
</tr>
<tr>
<td align="center"><strong>TRANSFERINDEX: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>BASECOUNT: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CELLSBUSY: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CELLVALUE: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ABASE: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ASHIFT: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>spread(int h): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将散列的高位扩展（异或）到低位，同时也将高位强制为0。由于表使用两个掩码的幂，因此仅在当前掩码上方的位上变化的散列集将始终发生冲突。（已知的例子包括在小表格中保存连续整数的浮点键集。）因此，我们应用了一种向下扩展高位影响的变换。位扩展的速度、实用性和质量之间存在权衡。因为许多常见的散列集已经合理分布（因此无法从扩展中受益），而且因为我们使用树来处理容器中的大型冲突集，所以我们只是以最便宜的方式对一些移位的位进行异或运算，以减少系统损失，并合并最高位的影响，否则，由于表边界，这些最高位将永远不会用于索引计算。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tableSizeFor(int c): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回给定所需容量的表大小的二次方。请参阅第3.2节</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>comparableClassFor(Object x): Class&lt;?&gt;</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果x的类的形式为“C类实现了可比较的<C>”，则返回x的类，否则为空。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareComparables(Class&lt;?&gt; kc, Object k, Object x): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果x与kc匹配（k是经过筛选的可比类），则返回k.compareTo（x），否则返回0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tabAt(Node&lt;K,V&gt;[] tab, int i): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可变访问方法用于表元素以及调整大小时正在进行的下一个表的元素。调用方必须检查选项卡参数的所有用法是否为空。所有调用者还偏执地预先检查tab的长度是否为零（或等效的检查），从而确保任何采用散列值AND和（长度-1）形式的索引参数都是有效的索引。请注意，为了纠正用户的wrt任意并发错误，这些检查必须对局部变量进行操作，这导致了下面一些奇怪的内联分配。请注意，对setTabAt的调用总是发生在锁定区域内，因此原则上只需要发布顺序，而不需要完整的易失性语义，但目前编码为易失性写入以保持保守。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v): boolean</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap()</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建具有默认初始表大小（16）的新空映射。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap(int initialCapacity)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个新的空映射，其初始表大小可容纳指定数量的元素，而无需动态调整大小。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用与给定映射相同的映射创建新映射。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap(int initialCapacity, float loadFactor)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个新的空映射，其初始表大小基于给定的元素数（“初始容量”）和初始表密度（“负载因子”）。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个新的空映射，其初始表大小基于给定的元素数量（“初始容量”）、表密度（“加载因子”）和并发更新线程数量（“并发水平”）。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>size(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isEmpty(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>get(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回指定键映射到的值，如果此映射不包含该键的映射，则返回“null”<p> 更正式地说，如果此映射包含从键“k”到值“v”的映射，则为该键。等于（k）”，则该方法返回“v”；否则返回“null”。（最多可以有一个这样的映射。）</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>containsKey(Object key): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">测试指定的对象是否是此表中的键。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>containsValue(Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此映射将一个或多个键映射到指定值，则返回“true”。注意：此方法可能需要完全遍历映射，并且比方法“containsKey”慢得多。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>put(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将指定的键映射到此表中的指定值。键和值都不能为null<p> 可以通过使用与原始键相等的键调用“get”方法来检索该值。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>putVal(K key, V value, boolean onlyIfAbsent): V</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">put和putIfAbsent的实现</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>putAll(Map&lt;? extends K, ? extends V&gt; m): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将所有映射从指定映射复制到此映射。这些映射替换此映射对指定映射中当前任何键的所有映射。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>remove(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从该映射中删除键（及其相应的值）。如果键不在映射中，则此方法不执行任何操作。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>replaceNode(Object key, V value, Object cv): V</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">四种公共移除&#x2F;替换方法的实现：将节点值替换为v，条件是cv匹配（如果非空）。如果结果值为空，请删除。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clear(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从该映射中删除所有映射。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>keySet(): KeySetView&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的键的“设置”视图。集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。该集合支持元素移除，即通过“迭代器”从该映射中移除相应的映射。删除“”集。移除、移除全部、保留和清除操作。它不支持“添加”或“添加所有”操作<p> 视图的迭代器和拆分器是弱一致的<p> 视图的“拆分器”报告“拆分器并发”、“拆分器不同”和“拆分器非空”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>values(): Collection<V></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的值的“集合”视图。集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。集合支持元素移除，通过“迭代器”从该映射中移除相应的映射。删除“”集合。移除、移除全部、保留和清除操作。它不支持“添加”或“添加所有”操作<p> 视图的迭代器和拆分器是弱一致的<p> 视图的“拆分器”报告“拆分器并发”和“拆分器非空”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySet(): Set&lt;Map.Entry&lt;K,V&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的映射的“集合”视图。集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。该集合支持元素移除，即通过“迭代器”从映射中移除相应的映射。删除“”集。移除、移除全部、保留和清除操作<p> 视图的迭代器和拆分器是弱一致的<p> 视图的“拆分器”报告“拆分器并发”、“拆分器不同”和“拆分器非空”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hashCode(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此“映射”的哈希代码值，即映射中每个键值对的“key”和。hashCode（）^value.hashCode（）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射的字符串表示形式。字符串表示法由一系列键值映射（没有特定顺序）组成，用大括号（“｛｝”）括起来。相邻映射由字符“，”分隔（逗号和空格）。每个键值映射都呈现为键，后跟等号（“&#x3D;”），后跟关联值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(Object o): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将指定对象与此映射进行相等性比较。如果给定对象是与此映射具有相同映射的映射，则返回“true”。如果在执行此方法期间同时修改任一映射，则此操作可能会返回误导性结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>writeObject(java.io.ObjectOutputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将“ConcurrentHashMap”实例的状态保存到流中（即，将其序列化）。</td>
<td align="left">java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>readObject(java.io.ObjectInputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从流中重构实例（即，对其进行反序列化）。</td>
<td align="left">ClassNotFoundException<br/>java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>putIfAbsent(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>remove(Object key, Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V oldValue, V newValue): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getOrDefault(Object key, V defaultValue): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回指定键映射到的值，如果此映射不包含该键的映射，则返回给定的默认值。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>forEach(BiConsumer&lt;? super K, ? super V&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定的键尚未与值关联，则尝试使用给定的映射函数计算其值，并将其输入此映射，除非“null”。整个方法调用以原子方式执行，因此每个键最多应用一次函数。在计算过程中，其他线程对此映射尝试的某些更新操作可能会被阻止，因此计算应该简短，并且不得尝试更新此映射的任何其他映射。</td>
<td align="left">RuntimeException<br/>IllegalStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定键的值存在，则尝试计算给定键及其当前映射值的新映射。整个方法调用以原子方式执行。在计算过程中，其他线程对此映射尝试的某些更新操作可能会被阻止，因此计算应该简短，并且不得尝试更新此映射的任何其他映射。</td>
<td align="left">RuntimeException<br/>IllegalStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试计算指定键及其当前映射值的映射（如果没有当前映射，则为“null”）。整个方法调用以原子方式执行。在计算过程中，其他线程对此映射尝试的某些更新操作可能会被阻止，因此计算应该简短，并且不得尝试更新此映射的任何其他映射。</td>
<td align="left">RuntimeException<br/>IllegalStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定的键尚未与（非空）值关联，则将其与给定值关联。否则，用给定重映射函数的结果替换该值，或者如果为“null”，则删除该值。整个方法调用以原子方式执行。在计算过程中，其他线程对此映射尝试的某些更新操作可能会被阻止，因此计算应该简短，并且不得尝试更新此映射的任何其他映射。</td>
<td align="left">RuntimeException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>contains(Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">传统方法测试某些键是否映射到此表中的指定值。此方法在功能上与“#containsValue（Object）”相同，其存在只是为了确保与类“java.util”完全兼容。Hashtable’，它在引入Java集合框架之前支持这种方法。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>keys(): Enumeration<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此表中键的枚举。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>elements(): Enumeration<V></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此表中值的枚举。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>mappingCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回映射数。应使用此方法而不是“#size”，因为ConcurrentHashMap可能包含比可以表示为int更多的映射。返回的值是估计值；如果存在并发插入或删除，则实际计数可能不同。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newKeySet(): KeySetView&lt;K,Boolean&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个由ConcurrentHashMap支持的新“集合”，该集合从给定类型到“Boolean.TRUE”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newKeySet(int initialCapacity): KeySetView&lt;K,Boolean&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个由ConcurrentHashMap支持的新“集合”，该集合从给定类型到“Boolean.TRUE”。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>keySet(V mappedValue): KeySetView&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中键的“集合”视图，使用任何添加的给定公共映射值（即“集合添加”和“集合添加所有（集合）”。当然，这仅适用于对该视图中的所有添加使用相同值的情况。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>resizeStamp(int n): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回用于调整大小为n的表的大小的戳记位。当向左移位RESIZE_stamp_SHIFT时，必须为负。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>initTable(): Node&lt;K,V&gt;[]</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用sizeCtl中记录的大小初始化表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>addCount(long x, int check): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">添加到计数，如果表太小且尚未调整大小，则启动传输。如果已调整大小，则有助于在工作可用时执行传输。在转移后重新检查占用情况，以查看是否已经需要重新调整大小，因为调整大小是滞后的添加。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f): Node&lt;K,V&gt;[]</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果正在调整大小，则帮助传输。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryPresize(int size): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试预先确定表的大小以容纳给定数量的元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将每个存储箱中的节点移动和&#x2F;或复制到新表中。请参见上面的解释。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sumCount(): long</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于分配计数的填充单元。改编自LongAdder和Striped64。有关解释，请参阅其内部文档。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fullAddCount(long x, boolean wasUncontended): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>treeifyBin(Node&lt;K,V&gt;[] tab, int index): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在给定索引处替换bin中的所有链接节点，除非表太小，在这种情况下将改为调整大小。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>untreeify(Node&lt;K,V&gt; b): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回非树节点列表，替换给定列表中的树节点。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>batchFor(long b): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">计算批量任务的初始批处理值。返回值大约是执行叶操作之前将任务拆分为两个的次数（减去1）的exp2。与深度相比，该值计算速度更快，并且更方便用作拆分的指南，因为它是在除以2时使用的。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEach(long parallelismThreshold, BiConsumer&lt;? super K,? super V&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个（键、值）执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEach(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer, Consumer&lt;? super U&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个（键、值）的每个非空转换执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>search(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U&gt; searchFunction): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">通过对每个（键、值）应用给定的搜索函数返回非null结果，如果没有，则返回null。成功后，将抑制进一步的元素处理，并忽略搜索函数的任何其他并行调用的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduce(long parallelismThreshold, BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer, BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有（键、值）对的给定变换的累加结果，使用给定的缩减器组合值，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceToDouble(long parallelismThreshold, ToDoubleBiFunction&lt;? super K, ? super V&gt; transformer, double basis, DoubleBinaryOperator reducer): double</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有（键、值）对的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceToLong(long parallelismThreshold, ToLongBiFunction&lt;? super K, ? super V&gt; transformer, long basis, LongBinaryOperator reducer): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有（键、值）对的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceToInt(long parallelismThreshold, ToIntBiFunction&lt;? super K, ? super V&gt; transformer, int basis, IntBinaryOperator reducer): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有（键、值）对的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachKey(long parallelismThreshold, Consumer&lt;? super K&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个键执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachKey(long parallelismThreshold, Function&lt;? super K, ? extends U&gt; transformer, Consumer&lt;? super U&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个键的每个非空转换执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>searchKeys(long parallelismThreshold, Function&lt;? super K, ? extends U&gt; searchFunction): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">通过对每个键应用给定的搜索函数返回非null结果，如果没有，则返回null。成功后，将抑制进一步的元素处理，并忽略搜索函数的任何其他并行调用的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceKeys(long parallelismThreshold, BiFunction&lt;? super K, ? super K, ? extends K&gt; reducer): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值累加所有键的结果，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceKeys(long parallelismThreshold, Function&lt;? super K, ? extends U&gt; transformer, BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有键的给定转换的累加结果，使用给定的缩减器组合值，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceKeysToDouble(long parallelismThreshold, ToDoubleFunction&lt;? super K&gt; transformer, double basis, DoubleBinaryOperator reducer): double</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有键的给定变换的累加结果，使用给定的缩减器组合值，并将给定基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceKeysToLong(long parallelismThreshold, ToLongFunction&lt;? super K&gt; transformer, long basis, LongBinaryOperator reducer): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有键的给定变换的累加结果，使用给定的缩减器组合值，并将给定基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceKeysToInt(long parallelismThreshold, ToIntFunction&lt;? super K&gt; transformer, int basis, IntBinaryOperator reducer): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有键的给定变换的累加结果，使用给定的缩减器组合值，并将给定基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachValue(long parallelismThreshold, Consumer&lt;? super V&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个值执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachValue(long parallelismThreshold, Function&lt;? super V, ? extends U&gt; transformer, Consumer&lt;? super U&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个值的每个非空转换执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>searchValues(long parallelismThreshold, Function&lt;? super V, ? extends U&gt; searchFunction): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">通过对每个值应用给定的搜索函数返回非空结果，如果没有，则返回null。成功后，将抑制进一步的元素处理，并忽略搜索函数的任何其他并行调用的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceValues(long parallelismThreshold, BiFunction&lt;? super V, ? super V, ? extends V&gt; reducer): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值累加所有值的结果，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceValues(long parallelismThreshold, Function&lt;? super V, ? extends U&gt; transformer, BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有值的给定转换的累加结果，使用给定的缩减器组合值，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceValuesToDouble(long parallelismThreshold, ToDoubleFunction&lt;? super V&gt; transformer, double basis, DoubleBinaryOperator reducer): double</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有值的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceValuesToLong(long parallelismThreshold, ToLongFunction&lt;? super V&gt; transformer, long basis, LongBinaryOperator reducer): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有值的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceValuesToInt(long parallelismThreshold, ToIntFunction&lt;? super V&gt; transformer, int basis, IntBinaryOperator reducer): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回所有值的给定变换的累加结果，使用给定的缩减器组合值，并将给定的基作为标识值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachEntry(long parallelismThreshold, Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个条目执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachEntry(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V&gt;, ? extends U&gt; transformer, Consumer&lt;? super U&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">对每个条目的每个非空转换执行给定操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>searchEntries(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V&gt;, ? extends U&gt; searchFunction): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">通过对每个条目应用给定的搜索函数返回非空结果，如果没有，则返回null。成功后，将抑制进一步的元素处理，并忽略搜索函数的任何其他并行调用的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceEntries(long parallelismThreshold, BiFunction&lt;Map.Entry&lt;K,V&gt;, Map.Entry&lt;K,V&gt;, ? extends Map.Entry&lt;K,V&gt;&gt; reducer): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值累加所有条目的结果，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceEntries(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V&gt;, ? extends U&gt; transformer, BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer): U</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器对所有项的给定转换进行累加以组合值的结果，如果没有，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceEntriesToDouble(long parallelismThreshold, ToDoubleFunction&lt;Map.Entry&lt;K,V&gt;&gt; transformer, double basis, DoubleBinaryOperator reducer): double</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值和给定基作为标识值累加所有项的给定变换的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceEntriesToLong(long parallelismThreshold, ToLongFunction&lt;Map.Entry&lt;K,V&gt;&gt; transformer, long basis, LongBinaryOperator reducer): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值和给定基作为标识值累加所有项的给定变换的结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reduceEntriesToInt(long parallelismThreshold, ToIntFunction&lt;Map.Entry&lt;K,V&gt;&gt; transformer, int basis, IntBinaryOperator reducer): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回使用给定缩减器合并值和给定基作为标识值累加所有项的给定变换的结果。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ConcurrentHashMap-Node"><a href="#ConcurrentHashMap-Node" class="headerlink" title="ConcurrentHashMap$Node"></a><a href="./ConcurrentHashMap$Node.html">ConcurrentHashMap$Node</a></h3><h3 id="ConcurrentHashMap-Segment"><a href="#ConcurrentHashMap-Segment" class="headerlink" title="ConcurrentHashMap$Segment"></a><a href="./ConcurrentHashMap$Segment.html">ConcurrentHashMap$Segment</a></h3><h3 id="ConcurrentHashMap-ForwardingNode"><a href="#ConcurrentHashMap-ForwardingNode" class="headerlink" title="ConcurrentHashMap$ForwardingNode"></a><a href="./ConcurrentHashMap$ForwardingNode.html">ConcurrentHashMap$ForwardingNode</a></h3><h3 id="ConcurrentHashMap-ReservationNode"><a href="#ConcurrentHashMap-ReservationNode" class="headerlink" title="ConcurrentHashMap$ReservationNode"></a><a href="./ConcurrentHashMap$ReservationNode.html">ConcurrentHashMap$ReservationNode</a></h3><h3 id="ConcurrentHashMap-CounterCell"><a href="#ConcurrentHashMap-CounterCell" class="headerlink" title="ConcurrentHashMap$CounterCell"></a><a href="./ConcurrentHashMap$CounterCell.html">ConcurrentHashMap$CounterCell</a></h3><h3 id="ConcurrentHashMap-TreeNode"><a href="#ConcurrentHashMap-TreeNode" class="headerlink" title="ConcurrentHashMap$TreeNode"></a><a href="./ConcurrentHashMap$TreeNode.html">ConcurrentHashMap$TreeNode</a></h3><h3 id="ConcurrentHashMap-TreeBin"><a href="#ConcurrentHashMap-TreeBin" class="headerlink" title="ConcurrentHashMap$TreeBin"></a><a href="./ConcurrentHashMap$TreeBin.html">ConcurrentHashMap$TreeBin</a></h3><h3 id="ConcurrentHashMap-TableStack"><a href="#ConcurrentHashMap-TableStack" class="headerlink" title="ConcurrentHashMap$TableStack"></a><a href="./ConcurrentHashMap$TableStack.html">ConcurrentHashMap$TableStack</a></h3><h3 id="ConcurrentHashMap-Traverser"><a href="#ConcurrentHashMap-Traverser" class="headerlink" title="ConcurrentHashMap$Traverser"></a><a href="./ConcurrentHashMap$Traverser.html">ConcurrentHashMap$Traverser</a></h3><h3 id="ConcurrentHashMap-BaseIterator"><a href="#ConcurrentHashMap-BaseIterator" class="headerlink" title="ConcurrentHashMap$BaseIterator"></a><a href="./ConcurrentHashMap$BaseIterator.html">ConcurrentHashMap$BaseIterator</a></h3><h3 id="ConcurrentHashMap-KeyIterator"><a href="#ConcurrentHashMap-KeyIterator" class="headerlink" title="ConcurrentHashMap$KeyIterator"></a><a href="./ConcurrentHashMap$KeyIterator.html">ConcurrentHashMap$KeyIterator</a></h3><h3 id="ConcurrentHashMap-ValueIterator"><a href="#ConcurrentHashMap-ValueIterator" class="headerlink" title="ConcurrentHashMap$ValueIterator"></a><a href="./ConcurrentHashMap$ValueIterator.html">ConcurrentHashMap$ValueIterator</a></h3><h3 id="ConcurrentHashMap-EntryIterator"><a href="#ConcurrentHashMap-EntryIterator" class="headerlink" title="ConcurrentHashMap$EntryIterator"></a><a href="./ConcurrentHashMap$EntryIterator.html">ConcurrentHashMap$EntryIterator</a></h3><h3 id="ConcurrentHashMap-MapEntry"><a href="#ConcurrentHashMap-MapEntry" class="headerlink" title="ConcurrentHashMap$MapEntry"></a><a href="./ConcurrentHashMap$MapEntry.html">ConcurrentHashMap$MapEntry</a></h3><h3 id="ConcurrentHashMap-KeySpliterator"><a href="#ConcurrentHashMap-KeySpliterator" class="headerlink" title="ConcurrentHashMap$KeySpliterator"></a><a href="./ConcurrentHashMap$KeySpliterator.html">ConcurrentHashMap$KeySpliterator</a></h3><h3 id="ConcurrentHashMap-ValueSpliterator"><a href="#ConcurrentHashMap-ValueSpliterator" class="headerlink" title="ConcurrentHashMap$ValueSpliterator"></a><a href="./ConcurrentHashMap$ValueSpliterator.html">ConcurrentHashMap$ValueSpliterator</a></h3><h3 id="ConcurrentHashMap-EntrySpliterator"><a href="#ConcurrentHashMap-EntrySpliterator" class="headerlink" title="ConcurrentHashMap$EntrySpliterator"></a><a href="./ConcurrentHashMap$EntrySpliterator.html">ConcurrentHashMap$EntrySpliterator</a></h3><h3 id="ConcurrentHashMap-CollectionView"><a href="#ConcurrentHashMap-CollectionView" class="headerlink" title="ConcurrentHashMap$CollectionView"></a><a href="./ConcurrentHashMap$CollectionView.html">ConcurrentHashMap$CollectionView</a></h3><h3 id="ConcurrentHashMap-KeySetView"><a href="#ConcurrentHashMap-KeySetView" class="headerlink" title="ConcurrentHashMap$KeySetView"></a><a href="./ConcurrentHashMap$KeySetView.html">ConcurrentHashMap$KeySetView</a></h3><h3 id="ConcurrentHashMap-ValuesView"><a href="#ConcurrentHashMap-ValuesView" class="headerlink" title="ConcurrentHashMap$ValuesView"></a><a href="./ConcurrentHashMap$ValuesView.html">ConcurrentHashMap$ValuesView</a></h3><h3 id="ConcurrentHashMap-EntrySetView"><a href="#ConcurrentHashMap-EntrySetView" class="headerlink" title="ConcurrentHashMap$EntrySetView"></a><a href="./ConcurrentHashMap$EntrySetView.html">ConcurrentHashMap$EntrySetView</a></h3><h3 id="ConcurrentHashMap-BulkTask"><a href="#ConcurrentHashMap-BulkTask" class="headerlink" title="ConcurrentHashMap$BulkTask"></a><a href="./ConcurrentHashMap$BulkTask.html">ConcurrentHashMap$BulkTask</a></h3><h3 id="ConcurrentHashMap-ForEachKeyTask"><a href="#ConcurrentHashMap-ForEachKeyTask" class="headerlink" title="ConcurrentHashMap$ForEachKeyTask"></a><a href="./ConcurrentHashMap$ForEachKeyTask.html">ConcurrentHashMap$ForEachKeyTask</a></h3><h3 id="ConcurrentHashMap-ForEachValueTask"><a href="#ConcurrentHashMap-ForEachValueTask" class="headerlink" title="ConcurrentHashMap$ForEachValueTask"></a><a href="./ConcurrentHashMap$ForEachValueTask.html">ConcurrentHashMap$ForEachValueTask</a></h3><h3 id="ConcurrentHashMap-ForEachEntryTask"><a href="#ConcurrentHashMap-ForEachEntryTask" class="headerlink" title="ConcurrentHashMap$ForEachEntryTask"></a><a href="./ConcurrentHashMap$ForEachEntryTask.html">ConcurrentHashMap$ForEachEntryTask</a></h3><h3 id="ConcurrentHashMap-ForEachMappingTask"><a href="#ConcurrentHashMap-ForEachMappingTask" class="headerlink" title="ConcurrentHashMap$ForEachMappingTask"></a><a href="./ConcurrentHashMap$ForEachMappingTask.html">ConcurrentHashMap$ForEachMappingTask</a></h3><h3 id="ConcurrentHashMap-ForEachTransformedKeyTask"><a href="#ConcurrentHashMap-ForEachTransformedKeyTask" class="headerlink" title="ConcurrentHashMap$ForEachTransformedKeyTask"></a><a href="./ConcurrentHashMap$ForEachTransformedKeyTask.html">ConcurrentHashMap$ForEachTransformedKeyTask</a></h3><h3 id="ConcurrentHashMap-ForEachTransformedValueTask"><a href="#ConcurrentHashMap-ForEachTransformedValueTask" class="headerlink" title="ConcurrentHashMap$ForEachTransformedValueTask"></a><a href="./ConcurrentHashMap$ForEachTransformedValueTask.html">ConcurrentHashMap$ForEachTransformedValueTask</a></h3><h3 id="ConcurrentHashMap-ForEachTransformedEntryTask"><a href="#ConcurrentHashMap-ForEachTransformedEntryTask" class="headerlink" title="ConcurrentHashMap$ForEachTransformedEntryTask"></a><a href="./ConcurrentHashMap$ForEachTransformedEntryTask.html">ConcurrentHashMap$ForEachTransformedEntryTask</a></h3><h3 id="ConcurrentHashMap-ForEachTransformedMappingTask"><a href="#ConcurrentHashMap-ForEachTransformedMappingTask" class="headerlink" title="ConcurrentHashMap$ForEachTransformedMappingTask"></a><a href="./ConcurrentHashMap$ForEachTransformedMappingTask.html">ConcurrentHashMap$ForEachTransformedMappingTask</a></h3><h3 id="ConcurrentHashMap-SearchKeysTask"><a href="#ConcurrentHashMap-SearchKeysTask" class="headerlink" title="ConcurrentHashMap$SearchKeysTask"></a><a href="./ConcurrentHashMap$SearchKeysTask.html">ConcurrentHashMap$SearchKeysTask</a></h3><h3 id="ConcurrentHashMap-SearchValuesTask"><a href="#ConcurrentHashMap-SearchValuesTask" class="headerlink" title="ConcurrentHashMap$SearchValuesTask"></a><a href="./ConcurrentHashMap$SearchValuesTask.html">ConcurrentHashMap$SearchValuesTask</a></h3><h3 id="ConcurrentHashMap-SearchEntriesTask"><a href="#ConcurrentHashMap-SearchEntriesTask" class="headerlink" title="ConcurrentHashMap$SearchEntriesTask"></a><a href="./ConcurrentHashMap$SearchEntriesTask.html">ConcurrentHashMap$SearchEntriesTask</a></h3><h3 id="ConcurrentHashMap-SearchMappingsTask"><a href="#ConcurrentHashMap-SearchMappingsTask" class="headerlink" title="ConcurrentHashMap$SearchMappingsTask"></a><a href="./ConcurrentHashMap$SearchMappingsTask.html">ConcurrentHashMap$SearchMappingsTask</a></h3><h3 id="ConcurrentHashMap-ReduceKeysTask"><a href="#ConcurrentHashMap-ReduceKeysTask" class="headerlink" title="ConcurrentHashMap$ReduceKeysTask"></a><a href="./ConcurrentHashMap$ReduceKeysTask.html">ConcurrentHashMap$ReduceKeysTask</a></h3><h3 id="ConcurrentHashMap-ReduceValuesTask"><a href="#ConcurrentHashMap-ReduceValuesTask" class="headerlink" title="ConcurrentHashMap$ReduceValuesTask"></a><a href="./ConcurrentHashMap$ReduceValuesTask.html">ConcurrentHashMap$ReduceValuesTask</a></h3><h3 id="ConcurrentHashMap-ReduceEntriesTask"><a href="#ConcurrentHashMap-ReduceEntriesTask" class="headerlink" title="ConcurrentHashMap$ReduceEntriesTask"></a><a href="./ConcurrentHashMap$ReduceEntriesTask.html">ConcurrentHashMap$ReduceEntriesTask</a></h3><h3 id="ConcurrentHashMap-MapReduceKeysTask"><a href="#ConcurrentHashMap-MapReduceKeysTask" class="headerlink" title="ConcurrentHashMap$MapReduceKeysTask"></a><a href="./ConcurrentHashMap$MapReduceKeysTask.html">ConcurrentHashMap$MapReduceKeysTask</a></h3><h3 id="ConcurrentHashMap-MapReduceValuesTask"><a href="#ConcurrentHashMap-MapReduceValuesTask" class="headerlink" title="ConcurrentHashMap$MapReduceValuesTask"></a><a href="./ConcurrentHashMap$MapReduceValuesTask.html">ConcurrentHashMap$MapReduceValuesTask</a></h3><h3 id="ConcurrentHashMap-MapReduceEntriesTask"><a href="#ConcurrentHashMap-MapReduceEntriesTask" class="headerlink" title="ConcurrentHashMap$MapReduceEntriesTask"></a><a href="./ConcurrentHashMap$MapReduceEntriesTask.html">ConcurrentHashMap$MapReduceEntriesTask</a></h3><h3 id="ConcurrentHashMap-MapReduceMappingsTask"><a href="#ConcurrentHashMap-MapReduceMappingsTask" class="headerlink" title="ConcurrentHashMap$MapReduceMappingsTask"></a><a href="./ConcurrentHashMap$MapReduceMappingsTask.html">ConcurrentHashMap$MapReduceMappingsTask</a></h3><h3 id="ConcurrentHashMap-MapReduceKeysToDoubleTask"><a href="#ConcurrentHashMap-MapReduceKeysToDoubleTask" class="headerlink" title="ConcurrentHashMap$MapReduceKeysToDoubleTask"></a><a href="./ConcurrentHashMap$MapReduceKeysToDoubleTask.html">ConcurrentHashMap$MapReduceKeysToDoubleTask</a></h3><h3 id="ConcurrentHashMap-MapReduceValuesToDoubleTask"><a href="#ConcurrentHashMap-MapReduceValuesToDoubleTask" class="headerlink" title="ConcurrentHashMap$MapReduceValuesToDoubleTask"></a><a href="./ConcurrentHashMap$MapReduceValuesToDoubleTask.html">ConcurrentHashMap$MapReduceValuesToDoubleTask</a></h3><h3 id="ConcurrentHashMap-MapReduceEntriesToDoubleTask"><a href="#ConcurrentHashMap-MapReduceEntriesToDoubleTask" class="headerlink" title="ConcurrentHashMap$MapReduceEntriesToDoubleTask"></a><a href="./ConcurrentHashMap$MapReduceEntriesToDoubleTask.html">ConcurrentHashMap$MapReduceEntriesToDoubleTask</a></h3><h3 id="ConcurrentHashMap-MapReduceMappingsToDoubleTask"><a href="#ConcurrentHashMap-MapReduceMappingsToDoubleTask" class="headerlink" title="ConcurrentHashMap$MapReduceMappingsToDoubleTask"></a><a href="./ConcurrentHashMap$MapReduceMappingsToDoubleTask.html">ConcurrentHashMap$MapReduceMappingsToDoubleTask</a></h3><h3 id="ConcurrentHashMap-MapReduceKeysToLongTask"><a href="#ConcurrentHashMap-MapReduceKeysToLongTask" class="headerlink" title="ConcurrentHashMap$MapReduceKeysToLongTask"></a><a href="./ConcurrentHashMap$MapReduceKeysToLongTask.html">ConcurrentHashMap$MapReduceKeysToLongTask</a></h3><h3 id="ConcurrentHashMap-MapReduceValuesToLongTask"><a href="#ConcurrentHashMap-MapReduceValuesToLongTask" class="headerlink" title="ConcurrentHashMap$MapReduceValuesToLongTask"></a><a href="./ConcurrentHashMap$MapReduceValuesToLongTask.html">ConcurrentHashMap$MapReduceValuesToLongTask</a></h3><h3 id="ConcurrentHashMap-MapReduceEntriesToLongTask"><a href="#ConcurrentHashMap-MapReduceEntriesToLongTask" class="headerlink" title="ConcurrentHashMap$MapReduceEntriesToLongTask"></a><a href="./ConcurrentHashMap$MapReduceEntriesToLongTask.html">ConcurrentHashMap$MapReduceEntriesToLongTask</a></h3><h3 id="ConcurrentHashMap-MapReduceMappingsToLongTask"><a href="#ConcurrentHashMap-MapReduceMappingsToLongTask" class="headerlink" title="ConcurrentHashMap$MapReduceMappingsToLongTask"></a><a href="./ConcurrentHashMap$MapReduceMappingsToLongTask.html">ConcurrentHashMap$MapReduceMappingsToLongTask</a></h3><h3 id="ConcurrentHashMap-MapReduceKeysToIntTask"><a href="#ConcurrentHashMap-MapReduceKeysToIntTask" class="headerlink" title="ConcurrentHashMap$MapReduceKeysToIntTask"></a><a href="./ConcurrentHashMap$MapReduceKeysToIntTask.html">ConcurrentHashMap$MapReduceKeysToIntTask</a></h3><h3 id="ConcurrentHashMap-MapReduceValuesToIntTask"><a href="#ConcurrentHashMap-MapReduceValuesToIntTask" class="headerlink" title="ConcurrentHashMap$MapReduceValuesToIntTask"></a><a href="./ConcurrentHashMap$MapReduceValuesToIntTask.html">ConcurrentHashMap$MapReduceValuesToIntTask</a></h3><h3 id="ConcurrentHashMap-MapReduceEntriesToIntTask"><a href="#ConcurrentHashMap-MapReduceEntriesToIntTask" class="headerlink" title="ConcurrentHashMap$MapReduceEntriesToIntTask"></a><a href="./ConcurrentHashMap$MapReduceEntriesToIntTask.html">ConcurrentHashMap$MapReduceEntriesToIntTask</a></h3><h3 id="ConcurrentHashMap-MapReduceMappingsToIntTask"><a href="#ConcurrentHashMap-MapReduceMappingsToIntTask" class="headerlink" title="ConcurrentHashMap$MapReduceMappingsToIntTask"></a><a href="./ConcurrentHashMap$MapReduceMappingsToIntTask.html">ConcurrentHashMap$MapReduceMappingsToIntTask</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
