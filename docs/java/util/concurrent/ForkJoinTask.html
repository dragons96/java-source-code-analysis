<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ForkJoinTask.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask<V></h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父接口</th>
<th align="center">泛型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ForkJoinTask&lt;V&gt;</strong></td>
<td align="center">abstract class</td>
<td align="center">Future&lt;V&gt;,Serializable</td>
<td align="center">&lt;V&gt;</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>status: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">此任务的运行状态</td>
</tr>
<tr>
<td align="center"><strong>DONE_MASK: int</strong></td>
<td align="center">0xf0000000</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>NORMAL: int</strong></td>
<td align="center">0xf0000000</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CANCELLED: int</strong></td>
<td align="center">0xc0000000</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>EXCEPTIONAL: int</strong></td>
<td align="center">0x80000000</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SIGNAL: int</strong></td>
<td align="center">0x00010000</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SMASK: int</strong></td>
<td align="center">0x0000ffff</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>exceptionTable: ExceptionNode[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">任务引发的异常表，以支持调用方的报告。由于异常非常罕见，我们不直接将它们保存在任务对象中，而是使用弱引用表。请注意，取消异常不会出现在表中，而是记录为状态值。注意：这些静态在下面的静态块中初始化。</td>
</tr>
<tr>
<td align="center"><strong>exceptionTableLock: ReentrantLock</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>exceptionTableRefQueue: ReferenceQueue&lt;Object&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>EXCEPTION_MAP_CAPACITY: int</strong></td>
<td align="center">32</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">例外情况的固定容量。</td>
</tr>
<tr>
<td align="center"><strong>serialVersionUID: long</strong></td>
<td align="center">-7721805057305804111L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>U: sun.misc.Unsafe</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STATUS: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>setCompletion(int completion): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">标记完成并唤醒等待加入此任务的线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doExec(): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">被盗任务的主要执行方法。除非完成，否则调用exec并在完成时记录状态，否则不等待完成。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalWait(long timeout): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果未完成，则设置信号状态并执行Object.wait（超时）。此任务可能在退出时完成，也可能不完成。忽略中断。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>externalAwaitDone(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">阻止非工作线程，直到完成。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>externalInterruptibleAwaitDone(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">阻塞非工作线程，直到完成或中断。</td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>doJoin(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">join、get和quietlyJoin的实现。仅直接处理已完成、外部等待和unfork+exec的情况。其他则中继到ForkJoinPool.awaitJoin。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doInvoke(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">调用的实现，quietlynvoke。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>recordExceptionalCompletion(Throwable ex): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">记录异常并设置状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setExceptionalCompletion(Throwable ex): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">记录异常并可能传播。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>internalPropagateException(Throwable ex): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">钩子，用于支持带有补足符的任务的异常传播。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>cancelIgnoringExceptions(ForkJoinTask&lt;?&gt; t): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">取消，忽略取消引发的任何异常。在工作线程和池关闭期间使用。Cancel被指定为不抛出任何异常，但如果它确实抛出异常，我们在关机期间没有追索权，所以要防止这种情况。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clearExceptionalCompletion(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">删除异常节点并清除状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getThrowableException(): Throwable</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回给定任务的可重试异常（如果可用）。为了提供准确的堆栈跟踪，如果异常不是由当前线程引发的，我们尝试创建与引发的异常类型相同的新异常，但将记录的异常作为其原因。如果没有这样的构造函数，我们将尝试使用无参数构造函数，后跟initCause，以达到相同的效果。如果这些都不适用，或者由于其他异常导致任何失败，我们将返回记录的异常，该异常仍然正确，尽管它可能包含误导性的堆栈跟踪。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>expungeStaleExceptions(): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">轮询陈旧的引用并删除它们。只有在持有锁时才能调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpExpungeStaleExceptions(): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果锁可用，则轮询过时的引用并将其删除。当池处于静止状态时，从ForkJoinPool调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>rethrow(Throwable ex): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">中继异常的“偷偷抛出”版本</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>uncheckedThrow(Throwable t): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">鬼鬼祟祟抛出的鬼祟部分，依靠泛型限制来避免编译器抱怨重新抛出未经检查的异常</td>
<td align="left">T</td>
</tr>
<tr>
<td align="center"><strong>reportException(int s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">引发与给定状态关联的异常（如果有）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fork(): ForkJoinTask<V></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">安排在当前任务运行的池中异步执行此任务（如果适用），或者使用“ForkJoinPool#commonPool（）”或“如果不是”#InforkJoinPooll”。虽然不一定强制执行，但如果任务未完成并重新初始化，则多次分叉任务是一种使用错误。除执行该任务的线程外，对该任务状态或其操作的任何数据的后续修改不一定能够被任何线程一致地观察到，除非之前调用了“#join”或相关方法，或者调用了返回“true”的“isDone”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>join(): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在“#isDone完成”时返回计算结果。此方法与“#get（）”的不同之处在于，异常完成会导致“RuntimeException”或“Error”，而不是“ExecutionException”，并且调用线程的中断不会导致方法通过抛出“InterruptedException”（中断异常）而突然返回。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>invoke(): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">开始执行此任务，如有必要，等待其完成，并返回其结果，如果基础计算执行，则抛出（未经检查的）“RuntimeException”或“Error”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>invokeAll(ForkJoinTask&lt;?&gt; t1, ForkJoinTask&lt;?&gt; t2): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">分叉给定的任务，当每个任务的“isDone”保持不变或遇到（未检查的）异常时返回，在这种情况下，异常被重新抛出。如果多个任务遇到异常，则此方法将抛出其中任何一个异常。如果任何任务遇到异常，则可以取消另一个任务。但是，在异常返回时，无法保证单个任务的执行状态。可以使用“#getException（）”和相关方法获取每个任务的状态，以检查它们是否已被取消、正常完成或异常完成，或未被处理。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>invokeAll(ForkJoinTask&lt;?&gt;… tasks): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">分叉给定的任务，当每个任务的“isDone”保持不变或遇到（未检查的）异常时返回，在这种情况下，异常被重新抛出。如果多个任务遇到异常，则此方法将抛出其中任何一个异常。如果任何任务遇到异常，其他任务可能会被取消。但是，在异常返回时，无法保证单个任务的执行状态。可以使用“#getException（）”和相关方法获取每个任务的状态，以检查它们是否已被取消、正常完成或异常完成，或未被处理。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>invokeAll(Collection&lt;T&gt; tasks): Collection<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">分叉指定集合中的所有任务，在每个任务的’isDone’保持不变或遇到（未检查的）异常时返回，在这种情况下，异常被重试。如果多个任务遇到异常，则此方法将抛出其中任何一个异常。如果任何任务遇到异常，其他任务可能会被取消。但是，在异常返回时，无法保证单个任务的执行状态。可以使用“#getException（）”和相关方法获取每个任务的状态，以检查它们是否已被取消、正常完成或异常完成，或未被处理。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>cancel(boolean mayInterruptIfRunning): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试取消此任务的执行。如果任务已完成或由于其他原因无法取消，则此尝试将失败。如果成功，并且调用“取消”时此任务尚未启动，则此任务的执行将被抑制。此方法成功返回后，除非有对“#reinitialize”的中间调用，否则对“”isCancelled”、“isDone”和“cancel”的后续调用将返回“true”，对“Şjoin”和相关方法的调用将导致“CancelationException”<p> 此方法可以在子类中重写，但如果是这样，则必须确保这些属性仍然有效。特别是，“cancel”方法本身不能引发异常<p> 此方法设计用于<em>其他</em>任务调用。要终止当前任务，您可以从其计算方法返回或抛出未经检查的异常，或调用“#CompleteExceptionly（Throwable）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isDone(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isCancelled(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isCompletedAbnormally(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此任务引发异常或被取消，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isCompletedNormally(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此任务未引发异常且未取消，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getException(): Throwable</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回由基计算引发的异常，如果已取消，则返回“CancellationException”，如果没有异常，或如果方法尚未完成，返回“null”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>completeExceptionally(Throwable ex): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">异常完成此任务，如果尚未中止或取消，则会导致该任务在“加入”和相关操作时引发给定异常。此方法可用于在异步任务中引发异常，或强制完成否则无法完成的任务。不鼓励在其他情况下使用。此方法是可重写的，但被重写的版本必须调用“超级”实现来维护保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>complete(V value): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">完成此任务，如果尚未中止或取消，则返回给定值作为后续调用“join”和相关操作的结果。此方法可用于为异步任务提供结果，或为无法正常完成的任务提供替代处理。不鼓励在其他情况下使用。此方法是可重写的，但被重写的版本必须调用“超级”实现来维护保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>quietlyComplete(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">正常完成此任务，无需设置值。由“#setRawResult”（默认情况下为“null”）建立的最新值将作为后续调用“join”和相关操作的结果返回。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>get(): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果需要，等待计算完成，然后检索其结果。</td>
<td align="left">InterruptedException<br/>ExecutionException<br/>CancellationException</td>
</tr>
<tr>
<td align="center"><strong>get(long timeout, TimeUnit unit): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果需要，最多等待给定时间以完成计算，然后检索其结果（如果可用）。</td>
<td align="left">InterruptedException<br/>TimeoutException<br/>ExecutionException<br/>CancellationException</td>
</tr>
<tr>
<td align="center"><strong>quietlyJoin(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">加入此任务，而不返回其结果或引发其异常。当任务集合被取消或已知已中止时，此方法在处理任务集合时可能很有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>quietlyInvoke(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">开始执行此任务，并在必要时等待其完成，而不返回其结果或引发其异常。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpQuiesce(): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能会执行任务，直到承载当前任务“ForkJoinPool#Isquisite”的池处于静止状态。这种方法可能适用于许多任务被分叉，但没有显式连接的设计，而是在所有任务都被处理之前执行它们。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reinitialize(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">重置此任务的内部记账状态，允许后续“分叉”。此方法允许重复重用此任务，但仅当此任务从未分叉或分叉，然后完成且此任务的所有未完成连接也已完成时，才允许重用。不保证在任何其他使用条件下的效果。当在循环中执行预构造的子任务树时，此方法可能很有用<p> 完成此方法后，’isDone（）’报告’false’，’getException（）’报告’null’。但是，“getRawResult”返回的值不受影响。要清除此值，可以调用“setRawResult（null）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getPool(): ForkJoinPool</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回承载当前任务执行的池，如果此任务在任何ForkJoinPool之外执行，则返回null。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>inForkJoinPool(): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果当前线程是作为ForkJoinPool计算执行的“ForkJoinWorkerThread”，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryUnfork(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试取消此任务的执行计划。如果此任务是当前线程最近分叉的任务，并且尚未开始在另一个线程中执行，则此方法通常（但不保证）会成功。当安排可能被盗但未被盗的任务的替代本地处理时，此方法可能很有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueuedTaskCount(): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回当前工作线程已分叉但尚未执行的任务数的估计值。该值对于是否分叉其他任务的启发式决策可能很有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getSurplusQueuedTaskCount(): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回当前工作线程持有的本地排队任务数比可能窃取它们的其他工作线程多的估计数，如果该线程未在ForkJoinPool中操作，则返回零。该值对于是否分叉其他任务的启发式决策可能很有用。在ForkJoinTasks的许多用途中，在稳定状态下，每个工作人员都应致力于保持任务的少量恒定盈余（例如，3），并在超过此阈值时在本地处理计算。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRawResult(): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">返回“#join”将返回的结果，即使此任务异常完成，或者如果未知此任务已完成，返回“null”。此方法旨在帮助调试，并支持扩展。不鼓励在任何其他情况下使用它。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setRawResult(V value): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">强制返回给定值作为结果。此方法旨在支持扩展，通常不应以其他方式调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>exec(): boolean</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">立即执行该任务的基本操作，如果从该方法返回时，该任务保证已正常完成，则返回true。此方法可能返回false，否则表示此任务不一定完成（或不知道是否完成），例如在需要显式调用完成方法的异步操作中。此方法还可能引发（未检查的）异常以指示异常退出。此方法旨在支持扩展，通常不应以其他方式调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>peekNextLocalTask(): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">protected</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回由当前线程排队但尚未执行的任务（如果该任务立即可用），但不取消该任务的调度或执行。无法保证下一步实际轮询或执行此任务。相反，即使任务存在，该方法也可能返回null，但如果没有与其他线程的争用，则无法访问该方法。此方法主要用于支持扩展，否则不太可能有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollNextLocalTask(): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">protected</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果当前线程正在ForkJoinPool中操作，则取消调度并返回当前线程排队但尚未执行的下一个任务，而不执行该任务。此方法主要用于支持扩展，否则不太可能有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollTask(): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">protected</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果当前线程正在ForkJoinPool中操作，则取消调度并返回当前线程排队但尚未执行的下一个任务（如果一个任务可用），或者如果不可用，返回由其他线程分叉的任务（如果可用）。可用性可能是暂时的，所以“空”结果不一定意味着此任务运行的池处于静止状态。此方法主要用于支持扩展，否则不太可能有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getForkJoinTaskTag(): short</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此任务的标记。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setForkJoinTaskTag(short tag): short</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">自动设置此任务的标记值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareAndSetForkJoinTaskTag(short e, short tag): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">原子地、有条件地设置此任务的标记值。在其他应用程序中，标记可以用作在图形上操作的任务中的访问标记，如在处理之前检查“if（task.compareAndSetForkJoinTaskTag（（短）0，（短）1））”的方法，否则将退出，因为节点已被访问。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>adapt(Runnable runnable): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个新的“ForkJoinTask”，该任务执行给定“Runnable”的“run”方法作为其操作，并在“#join”时返回空结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>adapt(Runnable runnable, T result): ForkJoinTask<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个新的“ForkJoinTask”，该任务执行给定“Runnable”的“run”方法作为其操作，并在“#join”时返回给定结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>adapt(Callable&lt;? extends T&gt; callable): ForkJoinTask<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个新的“ForkJoinTask”，该任务执行给定“Callable”的“call”方法作为其操作，并在“#join”时返回其结果，将遇到的任何已检查异常转换为“RuntimeException”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>writeObject(java.io.ObjectOutputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将此任务保存到流（即，将其序列化）。</td>
<td align="left">java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>readObject(java.io.ObjectInputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从流中重新配置此任务（即，将其反序列化）。</td>
<td align="left">ClassNotFoundException<br/>java.io.IOException</td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ForkJoinTask-ExceptionNode"><a href="#ForkJoinTask-ExceptionNode" class="headerlink" title="ForkJoinTask$ExceptionNode"></a><a href="./ForkJoinTask$ExceptionNode.html">ForkJoinTask$ExceptionNode</a></h3><h3 id="ForkJoinTask-AdaptedRunnable"><a href="#ForkJoinTask-AdaptedRunnable" class="headerlink" title="ForkJoinTask$AdaptedRunnable"></a><a href="./ForkJoinTask$AdaptedRunnable.html">ForkJoinTask$AdaptedRunnable</a></h3><h3 id="ForkJoinTask-AdaptedRunnableAction"><a href="#ForkJoinTask-AdaptedRunnableAction" class="headerlink" title="ForkJoinTask$AdaptedRunnableAction"></a><a href="./ForkJoinTask$AdaptedRunnableAction.html">ForkJoinTask$AdaptedRunnableAction</a></h3><h3 id="ForkJoinTask-RunnableExecuteAction"><a href="#ForkJoinTask-RunnableExecuteAction" class="headerlink" title="ForkJoinTask$RunnableExecuteAction"></a><a href="./ForkJoinTask$RunnableExecuteAction.html">ForkJoinTask$RunnableExecuteAction</a></h3><h3 id="ForkJoinTask-AdaptedCallable"><a href="#ForkJoinTask-AdaptedCallable" class="headerlink" title="ForkJoinTask$AdaptedCallable"></a><a href="./ForkJoinTask$AdaptedCallable.html">ForkJoinTask$AdaptedCallable</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
