<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ForkJoinPool.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ForkJoinPool</strong></td>
<td align="center">class</td>
<td align="center">AbstractExecutorService</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>SMASK: int</strong></td>
<td align="center">0xffff</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于人工任务的类，如果从WorkQueue.tryRemoveAndExec中的内部队列槽中删除了本地联接的目标，则这些任务用于替换这些目标。除了拥有唯一身份之外，我们不需要代理来实际执行任何操作。</td>
</tr>
<tr>
<td align="center"><strong>MAX_CAP: int</strong></td>
<td align="center">0x7fff</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>EVENMASK: int</strong></td>
<td align="center">0xfffe</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SQMASK: int</strong></td>
<td align="center">0x007e</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SCANNING: int</strong></td>
<td align="center">1</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>INACTIVE: int</strong></td>
<td align="center">1 &lt;&lt; 31</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SS_SEQ: int</strong></td>
<td align="center">1 &lt;&lt; 16</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>MODE_MASK: int</strong></td>
<td align="center">0xffff &lt;&lt; 16</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>LIFO_QUEUE: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>FIFO_QUEUE: int</strong></td>
<td align="center">1 &lt;&lt; 16</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SHARED_QUEUE: int</strong></td>
<td align="center">1 &lt;&lt; 31</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>defaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory</strong></td>
<td align="center">null</td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建新的ForkJoinWorkerThread。除非在ForkJoinPool构造函数中重写，否则将使用此工厂。</td>
</tr>
<tr>
<td align="center"><strong>modifyThreadPermission: RuntimePermission</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能启动或终止线程的方法调用方所需的权限。</td>
</tr>
<tr>
<td align="center"><strong>common: ForkJoinPool</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">公共（静态）池。非空用于公共用途，除非静态构造异常，但内部使用空检查来偏执地避免潜在的初始化循环，并简化生成的代码。</td>
</tr>
<tr>
<td align="center"><strong>commonParallelism: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">公共池并行性。为了在禁用公共池线程时更简单地使用和管理，我们允许使用底层公共池。parallelism字段为零，但在这种情况下，仍将并行度报告为1，以反映结果调用方运行机制。</td>
</tr>
<tr>
<td align="center"><strong>commonMaxSpares: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">tryCompensate中的备用螺纹构造限制。</td>
</tr>
<tr>
<td align="center"><strong>poolNumberSequence: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于创建workerNamePrefix的序列号。</td>
</tr>
<tr>
<td align="center"><strong>IDLE_TIMEOUT: long</strong></td>
<td align="center">2000L * 1000L * 1000L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">触发静止的线程暂停等待新工作的初始超时值（纳秒）。超时时，线程将尝试减少工作线程的数量。该值应足够大，以避免在大多数瞬态失速（长GC等）期间过度收缩。</td>
</tr>
<tr>
<td align="center"><strong>TIMEOUT_SLOP: long</strong></td>
<td align="center">20L * 1000L * 1000L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">空闲超时的容差，以应对定时器下冲</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT_COMMON_MAX_SPARES: int</strong></td>
<td align="center">256</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">静态初始化期间commonMaxSpares的初始值。该值远远超出正常需求，但也远远低于MAX_CAP和典型的OS线程限制，因此允许JVM在耗尽所需资源之前捕获误用&#x2F;滥用。</td>
</tr>
<tr>
<td align="center"><strong>SPINS: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">阻塞前旋转等待的次数。自旋（在awaitRunStateLock和awaitWork中）当前使用随机自旋。当前设置为零以减少CPU使用。如果大于零，则旋转值必须为2的幂，至少为4。2048的值会导致旋转，仅占典型上下文切换时间的一小部分。如果&#x2F;当类似MWAIT的Intrinsic可用时，它们可能允许更安静的旋转。</td>
</tr>
<tr>
<td align="center"><strong>SEED_INCREMENT: int</strong></td>
<td align="center">0x9e3779b9</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">种子生成器的增量。有关说明，请参见类ThreadLocal。</td>
</tr>
<tr>
<td align="center"><strong>SP_MASK: long</strong></td>
<td align="center">0xffffffffL</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">字段ctl的位和掩码，包含4个16位子字段：AC：活动运行的工作线程数减去目标并行度TC：总工作线程数减目标并行度SS：版本计数和顶部等待线程状态ID：等待线程的Treiber堆栈顶部的Poolidex如果方便，我们可以提取较低的32个堆栈顶部位（包括版本位）作为sp&#x3D;（int）ctl。通过目标平行度的计数偏移和字段的位置，可以通过字段的符号测试执行最常见的检查：当ac为负时，没有足够的活动工作线程；当tc为负时。当sp为非零时，有等待的工作线程。为了处理可能的负字段，我们使用“短”和&#x2F;或有符号移位的强制转换来保持有符号性。因为它占用最高位，所以当从阻塞连接返回时，我们可以使用AC_UNIT的GetAndAndLong而不是CAS添加一个活动计数。其他更新需要多个子字段和屏蔽，需要CAS。</td>
</tr>
<tr>
<td align="center"><strong>UC_MASK: long</strong></td>
<td align="center">~SP_MASK</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>AC_SHIFT: int</strong></td>
<td align="center">48</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>AC_UNIT: long</strong></td>
<td align="center">0x0001L &lt;&lt; AC_SHIFT</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>AC_MASK: long</strong></td>
<td align="center">0xffffL &lt;&lt; AC_SHIFT</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TC_SHIFT: int</strong></td>
<td align="center">32</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TC_UNIT: long</strong></td>
<td align="center">0x0001L &lt;&lt; TC_SHIFT</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TC_MASK: long</strong></td>
<td align="center">0xffffL &lt;&lt; TC_SHIFT</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ADD_WORKER: long</strong></td>
<td align="center">0x0001L &lt;&lt; (TC_SHIFT + 15)</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RSLOCK: int</strong></td>
<td align="center">1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RSIGNAL: int</strong></td>
<td align="center">1 &lt;&lt; 1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STARTED: int</strong></td>
<td align="center">1 &lt;&lt; 2</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STOP: int</strong></td>
<td align="center">1 &lt;&lt; 29</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TERMINATED: int</strong></td>
<td align="center">1 &lt;&lt; 30</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SHUTDOWN: int</strong></td>
<td align="center">1 &lt;&lt; 31</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ctl: long</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runState: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>config: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>indexSeed: int</strong></td>
<td align="center">0</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>workQueues: WorkQueue[]</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>factory: ForkJoinWorkerThreadFactory</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ueh: UncaughtExceptionHandler</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>workerNamePrefix: String</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>stealCounter: AtomicLong</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>U: sun.misc.Unsafe</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ABASE: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ASHIFT: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CTL: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RUNSTATE: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STEALCOUNTER: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>PARKBLOCKER: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QTOP: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QLOCK: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QSCANSTATE: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QPARKER: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QCURRENTSTEAL: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>QCURRENTJOIN: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>checkPermission(): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果有安全管理器，则确保调用方具有修改线程的权限。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>nextPoolId(): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回下一个序列号。我们不希望这种情况发生，所以使用简单的内置同步。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lockRunState(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取运行状态锁；返回当前（锁定）运行状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitRunStateLock(): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">旋转和&#x2F;或阻止，直到运行状态锁定可用。请参见上面的解释。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unlockRunState(int oldRunState, int newRunState): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">解锁并将runState设置为newRunState。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>createWorker(): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试构造并启动一个worker。假设总计数已作为保留增加。在任何失败时调用deregisterWorker。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryAddWorker(long c): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试添加一个worker，在添加之前增加ctl计数，在失败时依靠createWorker退出。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>registerWorker(ForkJoinWorkerThread wt): WorkQueue</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从ForkJoinWorkerThread构造函数回调以建立并记录其工作队列。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>deregisterWorker(ForkJoinWorkerThread wt, Throwable ex): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">终止工作进程的最终回调，以及构造或启动工作进程失败时的回调。从数组中删除工作进程的记录，并调整计数。如果池正在关闭，则尝试完成终止。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>signalWork(WorkQueue[] ws, WorkQueue q): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果活动的工作线程太少，则尝试创建或激活工作线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryRelease(long c, WorkQueue v, long inc): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果工人v位于空闲工人堆栈的顶部，则发出信号并释放工人v。仅当（显然）至少有一名空闲工作人员时，该系统才执行信号工作的一次性版本。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runWorker(WorkQueue w): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Worker的顶级运行循环，由ForkJoinWorkerThread.run调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>scan(WorkQueue w, int r): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">扫描并试图窃取顶级任务。扫描从一个随机位置开始，在明显的争用中随机移动，否则线性继续，直到使用相同的校验和（对每个队列的每个基本索引求和，在每次窃取时移动）在所有队列上达到两次连续的空传递，此时工作人员尝试停用，然后重新扫描，如果找到任务，则尝试重新激活（自身或其他工作人员）；否则返回null以等待工作。否则，扫描将尽可能少地占用内存，以减少对其他扫描线程的中断。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitWork(WorkQueue w, int r): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能会阻止等待任务窃取的worker w，或者如果worker应该终止，则返回false。如果禁用w导致池处于静止状态，则会检查池是否终止，并且只要这不是唯一的工作线程，就会等待一段时间。在超时时，如果ctl没有更改，则终止工作进程，这将唤醒另一个工作进程，以可能重复此过程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpComplete(WorkQueue w, CountedCompleter&lt;?&gt; task, int maxTasks): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">试图窃取并运行目标计算中的任务。使用顶级算法的一个变体，仅限于以给定任务为祖先的任务：它更喜欢接受并运行从工作者自己的队列中弹出的合格任务（通过popCC）。否则，它会扫描其他人，在争用或执行时随机移动，并根据校验和（通过来自POLLANDEXECC的返回码）决定放弃。maxTasks参数支持外部用法；内部调用使用零，允许无限步长（外部调用捕获非正值）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试为给定任务的窃取者（或其窃取者之一）定位和执行任务，跟踪currentSteal-&gt;currentJoin链接，寻找在给定任务的子代上工作的线程，并使用非空队列从中窃取并执行任务。在等待连接时对该方法的第一次调用通常需要扫描&#x2F;搜索（这是可以的，因为加入者没有更好的事情要做），但该方法会在worker中留下提示，以加快后续调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryCompensate(WorkQueue w): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试减少活动计数（有时是隐式的），并可能释放或创建一个补偿工作线程以准备阻塞。在发生争用、检测到过时、不稳定或终止时返回false（可由调用方检索）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitJoin(WorkQueue w, ForkJoinTask&lt;?&gt; task, long deadline): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">帮助和&#x2F;或阻止，直到给定任务完成或超时。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findNonEmptyStealQueue(): WorkQueue</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回（可能）非空的窃取队列（如果在扫描期间发现），否则为空。如果调用方在尝试使用队列时队列为空，则该方法必须由调用方重试。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>helpQuiescePool(WorkQueue w): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">运行任务直到“isquisite（）”。我们依靠活动计数ctl维护，但不是在找不到任务时阻塞，而是重新扫描，直到所有其他任务都找不到为止。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>nextTaskFor(WorkQueue w): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取并删除给定工作进程的本地或被盗任务。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getSurplusQueuedTaskCount(): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">当程序员、框架、工具或语言对任务粒度知之甚少或一无所知时，返回任务划分的廉价启发式指南。本质上，通过提供这种方法，我们只询问用户开销与预期吞吐量及其变化之间的权衡，而不是任务划分的精细程度。在稳态严格（树结构）计算中，每个线程都可以窃取足够的任务，以使其他线程保持活动状态。归纳地说，如果所有线程都遵循相同的规则，那么每个线程应该只提供恒定数量的任务。最小有用常数仅为1。但使用值1需要在每次偷窃时立即补充，以维持足够的任务，这是不可行的。此外，所提供任务的划分&#x2F;粒度应使窃取率最小化，这通常意味着更接近计算树顶部的线程应比更接近底部的线程生成更多。在完全稳定状态下，每个线程都处于近似相同的计算树级别。然而，产生额外任务会摊销进度和扩散假设的不确定性。因此，用户希望使用大于1（但不太大）的值来缓解暂时性短缺，并对冲不平衡的进展；与额外任务开销的成本进行权衡。我们让用户选择一个阈值，与此调用的结果进行比较，以指导决策，但建议使用3这样的值。当所有线程都处于活动状态时，平均而言，可以严格地在本地估计剩余。在稳定状态下，如果一个线程正在维护例如2个剩余任务，那么其他线程也是如此。所以我们可以使用估计的队列长度。然而，在某些非稳态条件下（上升、下降和其他失速），仅此策略就会导致严重的错误估计。我们可以通过进一步考虑“空闲”线程的数量来检测其中的许多线程，已知这些线程的队列任务数为零，因此可以通过（#idle&#x2F;#active）线程的因数进行补偿。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryTerminate(boolean now, boolean enable): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能发起和&#x2F;或完成终止。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>externalSubmit(ForkJoinTask&lt;?&gt; task): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">externalPush的完整版本，处理不常见的情况，并在第一次向池提交第一个任务时执行二次初始化。它还检测外部线程的第一次提交，如果索引中的队列为空或已竞争，则创建一个新的共享队列。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>externalPush(ForkJoinTask&lt;?&gt; task): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试将给定任务添加到提交者当前队列的提交队列中。该方法仅直接处理（非常）常见的路径，同时筛选是否需要外部提交。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>commonSubmitterQueue(): WorkQueue</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回外部线程的公共池队列。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryExternalUnpush(ForkJoinTask&lt;?&gt; task): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为外部提交者执行tryUnpush：查找队列，如果明显为非空则锁定，锁定后验证，并调整顶部。每次检查都可能失败，但很少失败。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>externalHelpComplete(CountedCompleter&lt;?&gt; task, int maxTasks): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为外部提交者执行helpComplete。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ForkJoinPool()</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用“#defaultForkJoinWorkerThreadFactory默认线程工厂”、无UncaughtExceptionHandler和非异步后进先出处理模式创建并行度等于“java.lang.Runtime#availableProcessors”的“ForkJointPool”。</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>ForkJoinPool(int parallelism)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建具有指定并行度级别的“ForkJoinPool”、“默认ForkJoinerThreadFactory默认线程工厂”、“无UncaughtExceptionHandler”和非异步后进先出处理模式。</td>
<td align="left">IllegalArgumentException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定参数创建“ForkJoinPool”。</td>
<td align="left">IllegalArgumentException<br/>SecurityException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>checkParallelism(int parallelism): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, int mode, String workerNamePrefix)</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定参数创建“ForkJoinPool”，无需任何安全检查或参数验证。由MakeComonPool直接调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>commonPool(): ForkJoinPool</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回公共池实例。该池是静态构造的；其运行状态不受“#shutdown”或“shutdownNow”尝试的影响。然而，该池和任何正在进行的处理在程序“System#exit”时自动终止。任何依赖异步任务处理在程序终止前完成的程序都应调用“commonPool（）”#等待静止等待静止’，然后退出。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>invoke(ForkJoinTask&lt;T&gt; task): T</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">执行给定任务，完成后返回其结果。如果计算遇到未经检查的异常或错误，它将作为此调用的结果重新调用。Rethrown异常的行为方式与常规异常相同，但在可能的情况下，包含当前线程和实际遇到异常的线程的堆栈跟踪（例如使用“ex.printStackTrace（）”显示）；至少仅后者。</td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>execute(ForkJoinTask&lt;?&gt; task): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">安排给定任务的（异步）执行。</td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>execute(Runnable task): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>submit(ForkJoinTask&lt;T&gt; task): ForkJoinTask<T></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">提交ForkJoinTask以供执行。</td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>submit(Callable&lt;T&gt; task): ForkJoinTask<T></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>submit(Runnable task, T result): ForkJoinTask<T></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>submit(Runnable task): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks): List&lt;Future<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getFactory(): ForkJoinWorkerThreadFactory</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回用于构造新工人的工厂。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getUncaughtExceptionHandler(): UncaughtExceptionHandler</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回由于执行任务时遇到不可恢复错误而终止的内部工作线程的处理程序。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getParallelism(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此池的目标并行级别。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCommonPoolParallelism(): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回公共池的目标并行级别。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回已启动但尚未终止的工作线程数。此方法返回的结果可能与创建线程以在其他线程被协作阻止时保持并行性时的“#getParallelism”不同。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getAsyncMode(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此池对从未加入的分叉任务使用本地先进先出调度模式，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRunningThreadCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回等待加入任务或其他托管同步而未被阻止的工作线程数的估计值。此方法可能会高估正在运行的线程数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getActiveThreadCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回当前正在窃取或执行任务的线程数的估计值。此方法可能高估了活动线程的数量。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isQuiescent(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果所有工作线程当前处于空闲状态，则返回“true”。空闲工作线程是无法获得要执行的任务的工作线程，因为没有任何线程可以从其他线程中窃取，并且池中没有挂起的提交。这种方法是保守的；它可能不会在所有线程空闲时立即返回“true”，但如果线程保持不活动，它最终将变为true。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getStealCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回从一个线程的工作队列中被另一个线程窃取的任务总数的估计值。报告的值低估了池不静止时的实际盗窃总数。这个值对于监视和调优fork&#x2F;join程序可能很有用：一般来说，窃取计数应该足够高，以保持线程繁忙，但足够低，以避免线程间的开销和争用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueuedTaskCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回工作线程当前保留在队列中的任务总数的估计值（但不包括提交到池中尚未开始执行的任务）。该值只是一个近似值，通过在池中的所有线程上迭代获得。此方法可能有助于调整任务粒度。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueuedSubmissionCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回提交到此池中尚未开始执行的任务数的估计值。此方法可能需要与提交数量成比例的时间。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasQueuedSubmissions(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果提交到此池的任何任务尚未开始执行，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollSubmission(): ForkJoinTask&lt;?&gt;</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">删除并返回下一个未执行的提交（如果有）。此方法在此类的扩展中可能很有用，该类可以在具有多个池的系统中重新分配工作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>drainTasksTo(Collection&lt;? super ForkJoinTask&lt;?&gt;&gt; c): int</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从调度队列中删除所有可用的未执行、提交和分叉任务，并将它们添加到给定集合中，而不改变其执行状态。这些可能包括人工生成或包装的任务。此方法设计为仅在已知池处于静态时调用。其他时间的调用可能不会删除所有任务。尝试将元素添加到集合“c”时遇到的失败可能会导致在引发关联异常时元素既不在集合中，也不在集合或集合中。如果在操作进行过程中修改了指定的集合，则此操作的行为未定义。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回标识此池及其状态的字符串，包括运行状态、并行级别以及工作线程和任务计数的指示。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>shutdown(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能会启动有序关机，其中执行以前提交的任务，但不会接受新任务。如果这是“#commonPool（）”，则调用对执行状态没有影响，如果已经关闭，则不会产生额外影响。在此方法过程中同时提交的任务可能会被拒绝，也可能不会被拒绝。</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>shutdownNow(): List<Runnable></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">可能会尝试取消和&#x2F;或停止所有任务，并拒绝所有随后提交的任务。如果这是“#commonPool（）”，则调用对执行状态没有影响，如果已经关闭，则不会产生额外影响。否则，在此方法过程中同时提交或执行的任务可能会被拒绝，也可能不会被拒绝。此方法取消现有和未执行的任务，以便在存在任务相关性时终止。因此，该方法总是返回一个空列表（与其他一些执行器的情况不同）。</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isTerminated(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果关闭后所有任务都已完成，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isTerminating(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果终止过程已开始但尚未完成，则返回“true”。此方法可能对调试有用。关闭后足够长时间内报告的“true”返回可能表示提交的任务忽略或抑制了中断，或正在等待I&#x2F;O，导致此执行器无法正确终止。（参见“ForkJoinTask”类的建议注释，说明任务通常不应包含阻塞操作。但如果包含阻塞操作，则必须在中断时中止它们。）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isShutdown(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此池已关闭，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitTermination(long timeout, TimeUnit unit): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">阻塞，直到所有任务在关机请求后完成执行，或超时发生，或当前线程中断，以先发生的为准。由于“#commonPool（）”在程序关闭之前从未终止，因此当应用于公共池时，此方法等同于“35Awaitquiesion（long，TimeUnit）”，但始终返回“false”。</td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>awaitQuiescence(long timeout, TimeUnit unit): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果由在此池中操作的ForkJoinTask调用，则实际上相当于“ForkJointTask#helpQuiesce”。否则，等待和&#x2F;或尝试协助执行任务，直到该池“#isquisite”或指示的超时时间过去。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>quiesceCommonPool(): void</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">等待和&#x2F;或尝试无限期协助执行任务，直到“#commonPool（）”处于静止状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>managedBlock(ManagedBlocker blocker): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">运行给定的可能阻塞任务。当“ForkJoinTask#inForkJoinPool（）在ForkJointPool中运行”时，此方法可能会在必要时安排激活备用线程，以确保在“ManagedBlocker#block blocker.block（）中阻塞当前线程时具有足够的并行性<p> 此方法反复调用“拦截器”。isReleasable（）’和’blocker’。block（），直到任一方法返回“true”。每次呼叫“拦截器”。block（）’前面是对’blocker’的调用。返回“false”的isReleasable（）<p> 如果未在ForkJoinPool中运行，则此方法在行为上等同于＜pre＞，而（！blocker.isReleasable（））如果（blocker.block（））中断；’</pre>如果在ForkJoinPool中运行，可以首先扩展该池，以确保在调用“blocker.block（）”期间有足够的并行性。</td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>newTaskFor(Runnable runnable, T value): RunnableFuture<T></strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newTaskFor(Callable&lt;T&gt; callable): RunnableFuture<T></strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>makeCommonPool(): ForkJoinPool</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">根据通过系统属性指定的用户设置，创建并返回公共池。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ForkJoinPool-ForkJoinWorkerThreadFactory"><a href="#ForkJoinPool-ForkJoinWorkerThreadFactory" class="headerlink" title="ForkJoinPool$ForkJoinWorkerThreadFactory"></a><a href="./ForkJoinPool$ForkJoinWorkerThreadFactory.html">ForkJoinPool$ForkJoinWorkerThreadFactory</a></h3><h3 id="ForkJoinPool-DefaultForkJoinWorkerThreadFactory"><a href="#ForkJoinPool-DefaultForkJoinWorkerThreadFactory" class="headerlink" title="ForkJoinPool$DefaultForkJoinWorkerThreadFactory"></a><a href="./ForkJoinPool$DefaultForkJoinWorkerThreadFactory.html">ForkJoinPool$DefaultForkJoinWorkerThreadFactory</a></h3><h3 id="ForkJoinPool-EmptyTask"><a href="#ForkJoinPool-EmptyTask" class="headerlink" title="ForkJoinPool$EmptyTask"></a><a href="./ForkJoinPool$EmptyTask.html">ForkJoinPool$EmptyTask</a></h3><h3 id="ForkJoinPool-WorkQueue"><a href="#ForkJoinPool-WorkQueue" class="headerlink" title="ForkJoinPool$WorkQueue"></a><a href="./ForkJoinPool$WorkQueue.html">ForkJoinPool$WorkQueue</a></h3><h3 id="ForkJoinPool-ManagedBlocker"><a href="#ForkJoinPool-ManagedBlocker" class="headerlink" title="ForkJoinPool$ManagedBlocker"></a><a href="./ForkJoinPool$ManagedBlocker.html">ForkJoinPool$ManagedBlocker</a></h3><h3 id="ForkJoinPool-InnocuousForkJoinWorkerThreadFactory"><a href="#ForkJoinPool-InnocuousForkJoinWorkerThreadFactory" class="headerlink" title="ForkJoinPool$InnocuousForkJoinWorkerThreadFactory"></a><a href="./ForkJoinPool$InnocuousForkJoinWorkerThreadFactory.html">ForkJoinPool$InnocuousForkJoinWorkerThreadFactory</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
