<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/locks/ReentrantLock.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父接口</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.locks.ReentrantLock</strong></td>
<td align="center">class</td>
<td align="center">Lock,java.io.Serializable</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>serialVersionUID: long</strong></td>
<td align="center">7373984872572414699L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sync: Sync</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">同步器提供了所有的实现机制</td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ReentrantLock()</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建“ReentrantLock”的实例。这相当于使用“ReentrantLock（false）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ReentrantLock(boolean fair)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定的公平策略创建“ReentrantLock”实例。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lock(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取锁<p> 如果锁未被另一个线程持有，则获取该锁并立即返回，将锁持有计数设置为1<p> 如果当前线程已经持有锁，那么持有计数将增加1，并且方法立即返回<p> 如果锁由另一个线程持有，则当前线程出于线程调度目的将被禁用，并处于休眠状态，直到获得锁为止，此时锁持有计数设置为1。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lockInterruptibly(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取锁，除非当前线程为“线程中断”<p> 如果锁未被另一个线程持有，则获取该锁并立即返回，将锁持有计数设置为1<p> 如果当前线程已经持有该锁，那么持有计数将增加1，并且该方法立即返回<p> 如果锁由另一个线程持有，则当前线程出于线程调度目的将被禁用，并处于休眠状态，直到发生以下两种情况之一：<ul><li>锁由当前线程获取；或＜li＞某个其他线程的“线程中断”中断当前线程</ul><p>如果锁是由当前线程获取的，则锁保持计数设置为1<p> 如果当前线程：<ul><li>在进入此方法时设置了其中断状态；或者＜li＞在获取锁时是“线程中断”，然后抛出“中断异常”，清除当前线程的中断状态<p> 在该实现中，由于该方法是一个显式中断点，因此与锁的正常或可重入获取相比，优先响应中断。</td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>tryLock(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">仅当调用时锁未被另一个线程持有时，才获取该锁<p> 如果锁未被另一个线程持有，则获取该锁，并立即返回值“true”，将锁持有计数设置为1。即使将此锁设置为使用公平排序策略，调用“tryLock（）”<em>也将</em>立即获取可用的锁，无论当前是否有其他线程在等待该锁。这是一个“错误”；“驳船”；行为在某些情况下是有用的，即使它破坏了公平。如果您想遵守此锁的公平性设置，请使用“#tryLock（long，TimeUnit）tryLock”（0，timeunits.SECONDS），这几乎是等效的（它还检测中断）<p> 如果当前线程已经持有该锁，那么持有计数将增加1，并且该方法返回“true”<p> 如果锁由另一个线程持有，则此方法将立即返回值“false”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryLock(long timeout, TimeUnit unit): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果在给定等待时间内未被另一个线程持有，并且当前线程未被“线程中断”，则获取锁<p> 如果锁未被另一个线程持有，则获取该锁，并立即返回值“true”，将锁持有计数设置为1。如果此锁已设置为使用公平排序策略，则如果任何其他线程正在等待该锁，则不会获取可用锁<em>。这与“#tryLock（）”方法相反。如果你想要一个定时的’tryLock’，它允许在一个公平锁上闯入，然后将定时和非定时表单组合在一起：＜pre＞If（lock.tryLock（）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unlock(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">试图释放此锁<p> 如果当前线程是该锁的持有人，则持有计数将递减。如果保持计数现在为零，则释放锁。如果当前线程不是此锁的持有者，则抛出“IllegalMonitorStateException”。</td>
<td align="left">IllegalMonitorStateException</td>
</tr>
<tr>
<td align="center"><strong>newCondition(): Condition</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与此“锁”实例一起使用的“条件”实例<p> 返回的“条件”实例支持与内置监视器锁一起使用时的“对象”监视器方法（“对象#wait（）wait”、“对象”notify”和“对象ŞnotifyAll notifyAll”）相同的用法<ul><li>如果在调用任何“条件”或“条件#wait（）waiting”或“信号信令”方法时未保持此锁，则会引发“IllegalMonitorStateException”<li>当调用条件“condition#await（）waiting”方法时，锁被释放，在它们返回之前，锁被重新获取，锁保持计数恢复到调用该方法时的状态<li>如果线程在等待时为“thread#interrupt interrupt”，则等待将终止，抛出“InterruptedException”，线程的中断状态将被清除<li>等待线程按FIFO顺序发出信号<li>对于从等待方法返回的线程，锁重新获取的顺序与最初获取锁的线程相同，在默认情况下未指定，但对于<em>公平</em>锁，优先选择等待时间最长的线程</ul></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getHoldCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询当前线程对此锁的保留次数<p> 对于每个锁定操作，线程都会保持锁定，而解锁操作不匹配<p> 保持计数信息通常仅用于测试和调试目的。例如，如果某段代码不应在锁已被持有的情况下输入，那么我们可以断言这一事实：＜pre＞“class X{ReentrantLock&#x3D;new ReentrantLock（）；public void m（）｛assert lock.getHoldCount（）＝＝0；lock.lock（）；try｛最终｛lock.unlock（）；｝｝</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isHeldByCurrentThread(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询此锁是否由当前线程持有<p> 类似于内置监控器锁的“Thread#holdsLock（Object）”方法，此方法通常用于调试和测试。例如，一个只应在持有锁时调用的方法可以断言这种情况：＜pre＞‘class X｛ReentrantLock＝new ReentrantLock（）；public void m（）｛assert lock.isHeldByCurrentThread（）；‘｝｝</pre>＜p＞它还可以用于确保以非重入方式使用重入锁，例如：＜pre＞“类X{ReentrantLock lock&#x3D;new reentrontlock（）；公共void m（）{assert！lock.isHeldByCurrentThread（）；lock.lock（）；try{finally{lock.unlock（）；}”</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isLocked(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询此锁是否由任何线程持有。此方法设计用于监视系统状态，而不是用于同步控制。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isFair(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此锁的公平性设置为true，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getOwner(): Thread</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回当前拥有此锁的线程，如果不拥有，则返回“null”。当此方法由非所有者的线程调用时，返回值反映当前锁状态的最佳近似值。例如，即使有线程试图获取锁，但尚未获取，所有者也可能暂时为“null”。该方法旨在促进提供更广泛锁监控设施的子类的构建。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasQueuedThreads(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询是否有线程正在等待获取此锁。请注意，由于取消可能随时发生，“true”返回并不保证任何其他线程都会获取此锁。该方法主要用于监控系统状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasQueuedThread(Thread thread): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询给定线程是否正在等待获取此锁。请注意，由于取消可能随时发生，“true”返回并不保证此线程将获得此锁。该方法主要用于监控系统状态。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getQueueLength(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回等待获取此锁的线程数的估计值。该值只是一个估计值，因为当该方法遍历内部数据结构时，线程的数量可能会动态变化。此方法设计用于监视系统状态，而不是用于同步控制。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueuedThreads(): Collection<Thread></strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回包含可能正在等待获取此锁的线程的集合。因为在构造此结果时，实际的线程集可能会动态变化，所以返回的集合只是一个尽力而为的估计。返回集合的元素没有特定顺序。该方法旨在促进提供更广泛监测设施的子类的构建。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hasWaiters(Condition condition): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查询是否有任何线程正在等待与此锁关联的给定条件。请注意，由于超时和中断可能随时发生，“true”返回并不保证将来的“信号”将唤醒任何线程。该方法主要用于监控系统状态。</td>
<td align="left">IllegalArgumentException<br/>IllegalMonitorStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getWaitQueueLength(Condition condition): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回等待与此锁关联的给定条件的线程数的估计值。请注意，由于超时和中断可能随时发生，因此估计值仅作为实际服务员人数的上限。此方法设计用于监视系统状态，而不是用于同步控制。</td>
<td align="left">IllegalArgumentException<br/>IllegalMonitorStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getWaitingThreads(Condition condition): Collection<Thread></strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个集合，其中包含可能正在等待与此锁关联的给定条件的线程。因为在构造此结果时，实际的线程集可能会动态变化，所以返回的集合只是一个尽力而为的估计。返回集合的元素没有特定顺序。该方法旨在促进提供更广泛的状态监测设施的子类的构建。</td>
<td align="left">IllegalArgumentException<br/>IllegalMonitorStateException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回标识此锁及其锁状态的字符串。括号中的状态包括字符串“Unlocked”或字符串“Locked by”，后跟所属线程的“Thread#getName”。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ReentrantLock-Sync"><a href="#ReentrantLock-Sync" class="headerlink" title="ReentrantLock$Sync"></a><a href="./ReentrantLock$Sync.html">ReentrantLock$Sync</a></h3><h3 id="ReentrantLock-NonfairSync"><a href="#ReentrantLock-NonfairSync" class="headerlink" title="ReentrantLock$NonfairSync"></a><a href="./ReentrantLock$NonfairSync.html">ReentrantLock$NonfairSync</a></h3><h3 id="ReentrantLock-FairSync"><a href="#ReentrantLock-FairSync" class="headerlink" title="ReentrantLock$FairSync"></a><a href="./ReentrantLock$FairSync.html">ReentrantLock$FairSync</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
