<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ThreadPoolExecutor.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ThreadPoolExecutor</strong></td>
<td align="center">class</td>
<td align="center">AbstractExecutorService</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ctl: AtomicInteger</strong></td>
<td align="center">new AtomicInteger(ctlOf(RUNNING, 0))</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">主池控制状态ctl是一个原子整数，包含两个概念字段workerCount，指示线程的有效数量runState，指示是否正在运行、关闭等。为了将它们打包为一个int，我们将WorkerCounts限制为（2^29）-1（约5亿）个线程，而不是（2^31）-1（20亿）个其他可表示的线程。如果这是将来的问题，可以将变量更改为原子长度，并调整下面的移位&#x2F;掩码常数。但在需要之前，此代码使用int会更快更简单。workerCount是允许启动和不允许停止的工作人员数。该值可能暂时不同于活动线程的实际数量，例如当ThreadFactory在请求时无法创建线程，并且退出线程在终止前仍在执行记账时。用户可见池大小报告为workers集的当前大小。运行状态提供主要的生命周期控制，具有以下值：运行：接受新任务和处理排队任务关闭：不接受新任务，但处理排队任务停止：不接受新建任务、不处理排队任务和中断进行中任务整理：所有任务都已终止，workerCount为零，转换到状态整理的线程将运行terminated（）钩子方法terminateed:terminated（）已完成这些值之间的数字顺序，以允许有序比较。运行状态随时间单调增加，但不需要命中每个状态。转换为：调用SHUTDOWN（）时运行-&gt;关闭，也许在finalize（）（RUNNING或SHUTDOWN）-&gt;调用shutdownNow（）时停止shutdownlow-&gt;当队列和池都为空时清理停止-&gt;当池为空时整理-&gt;在终止（）钩子方法完成时终止等待终止（）的线程将在状态达到终止时返回。检测从关闭到整理的转换并不像您希望的那样简单，因为队列在非空状态下可能变为空，在关闭状态下也可能变为空白，但只有在看到workerCount为空后，我们才能终止它（这有时需要重新检查——见下文）。</td>
</tr>
<tr>
<td align="center"><strong>COUNT_BITS: int</strong></td>
<td align="center">Integer.SIZE - 3</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CAPACITY: int</strong></td>
<td align="center">(1 &lt;&lt; COUNT_BITS) - 1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RUNNING: int</strong></td>
<td align="center">-1 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SHUTDOWN: int</strong></td>
<td align="center">0 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STOP: int</strong></td>
<td align="center">1 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TIDYING: int</strong></td>
<td align="center">2 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TERMINATED: int</strong></td>
<td align="center">3 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>workQueue: BlockingQueue&lt;Runnable&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于保存任务并将其传递给工作线程的队列。我们不需要那个工作队列。poll（）返回null必然意味着工作队列。isEmpty（），因此仅依靠isEmpty来查看队列是否为空（例如，在决定是否从关闭转换为清理时，我们必须这样做）。这适用于特殊用途队列，例如允许poll（）返回null的DelayQueues，即使延迟过期后poll（）可能返回非null。</td>
</tr>
<tr>
<td align="center"><strong>mainLock: ReentrantLock</strong></td>
<td align="center">new ReentrantLock()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">锁定工人集合和相关簿记的访问权限。虽然我们可以使用某种类型的并发集，但事实证明，通常最好使用锁。其中一个原因是它序列化了中断工人，从而避免了不必要的中断风暴，尤其是在关机期间。否则，退出线程将同时中断那些尚未中断的线程。它还简化了一些与最大池大小等相关的统计数据簿记。我们还在shutdown和shutdownNow上保持主锁，以确保workers集稳定，同时分别检查中断和实际中断的权限。</td>
</tr>
<tr>
<td align="center"><strong>workers: HashSet&lt;Worker&gt;</strong></td>
<td align="center">new HashSet<Worker>()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">包含池中所有工作线程的集合。仅在持有主锁时访问。</td>
</tr>
<tr>
<td align="center"><strong>termination: Condition</strong></td>
<td align="center">mainLock.newCondition()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">等待条件支持等待终止</td>
</tr>
<tr>
<td align="center"><strong>largestPoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">这条赛道是游泳池规模最大的赛道。只能在主锁下访问。</td>
</tr>
<tr>
<td align="center"><strong>completedTaskCount: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">已完成任务的计数器。仅在工作线程终止时更新。只能在主锁下访问。</td>
</tr>
<tr>
<td align="center"><strong>threadFactory: ThreadFactory</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">新螺纹的工厂。所有线程都是使用此工厂创建的（通过方法addWorker）。所有调用者都必须为addWorker失败做好准备，这可能反映了系统或用户限制线程数量的策略。即使不将其视为错误，创建线程的失败也可能会导致新任务被拒绝或现有任务仍停留在队列中。我们更进一步，保留池不变量，即使在遇到错误（如OutOfMemoryError）时也是如此，这些错误可能会在尝试创建线程时抛出。由于需要在线程中分配本机堆栈，此类错误非常常见。启动后，用户将希望执行清理池关闭以进行清理。可能会有足够的内存来完成清理代码，而不会遇到另一个OutOfMemoryError。</td>
</tr>
<tr>
<td align="center"><strong>handler: RejectedExecutionHandler</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在execute中饱和或关闭时调用处理程序。</td>
</tr>
<tr>
<td align="center"><strong>keepAliveTime: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">空闲线程等待工作的超时（纳秒）。当存在超过corePoolSize或allowCoreThreadTimeOut时，线程使用此超时。否则，他们将永远等待新的工作。</td>
</tr>
<tr>
<td align="center"><strong>allowCoreThreadTimeOut: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果为false（默认），则核心线程即使在空闲时也保持活动状态。如果为true，则核心线程使用keepAliveTime超时等待工作。</td>
</tr>
<tr>
<td align="center"><strong>corePoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Core pool size是保持活动的最小工作线程数（不允许超时等），除非设置了allowCoreThreadTimeOut，在这种情况下，最小值为零。</td>
</tr>
<tr>
<td align="center"><strong>maximumPoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">最大池大小。请注意，实际最大值由容量内部限定。</td>
</tr>
<tr>
<td align="center"><strong>defaultHandler: RejectedExecutionHandler</strong></td>
<td align="center">new AbortPolicy()</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">默认的被拒绝执行处理程序</td>
</tr>
<tr>
<td align="center"><strong>shutdownPerm: RuntimePermission</strong></td>
<td align="center">new RuntimePermission(“modifyThread”)</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">shutdown和ShutddownNow的调用方需要权限。我们还要求（请参见checkShutdownAccess）调用方有权实际中断工作集中的线程（由Thread.interrupt控制，它依赖于ThreadGroup.checkAccess，而ThreadGroup.checkAccess又依赖于SecurityManager.checkAccess）。只有当这些检查通过时才尝试关闭。所有线程的实际调用。中断（请参阅中断工人和中断工人）忽略安全异常，这意味着尝试的中断会以静默方式失败。在关机的情况下，它们不应该失败，除非SecurityManager具有不一致的策略，有时允许访问线程，有时不允许。在这种情况下，未能实际中断线程可能会禁用或延迟完全终止。中断工人的其他用途是建议性的，而实际中断的失败只会延迟对配置更改的响应，因此不会异常处理。</td>
</tr>
<tr>
<td align="center"><strong>acc: AccessControlContext</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">执行终结器时要使用的上下文，或null。</td>
</tr>
<tr>
<td align="center"><strong>ONLY_ONE: boolean</strong></td>
<td align="center">true</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>runStateOf(int c): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>workerCountOf(int c): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ctlOf(int rs, int wc): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runStateLessThan(int c, int s): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">不需要解包ctl的位字段访问器。这取决于位布局和workerCount从不为负。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runStateAtLeast(int c, int s): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isRunning(int c): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareAndIncrementWorkerCount(int expect): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试CAS递增ctl的workerCount字段。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareAndDecrementWorkerCount(int expect): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试CAS递减ctl的workerCount字段。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>decrementWorkerCount(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">递减ctl的workerCount字段。这仅在线程突然终止时调用（请参见processWorkerExit）。在getTask中执行其他递减。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>advanceRunState(int targetState): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将运行状态转换到给定目标，或者至少在给定目标上保留运行状态。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryTerminate(): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果（关闭且池和队列为空）或（停止且池为空），则转换为终止状态。如果有资格终止，但workerCount不为零，则中断空闲工作进程，以确保停机信号传播。必须在可能导致终止的任何操作之后调用此方法——减少工作人员计数或在关机期间从队列中删除任务。该方法是非私有的，允许从ScheduledThreadPoolExecutor进行访问。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>checkShutdownAccess(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果有安全管理器，则确保调用者具有关闭线程的权限（请参阅shutdownPerm）。如果通过，还确保允许调用方中断每个工作线程。即使第一次检查通过，如果SecurityManager特别对待某些线程，这也可能不是真的。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptWorkers(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">中断所有线程，即使处于活动状态。忽略SecurityExceptions（在这种情况下，某些线程可能保持不间断）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptIdleWorkers(boolean onlyOne): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">中断可能正在等待任务的线程（如未锁定所示），以便它们可以检查终止或配置更改。忽略SecurityExceptions（在这种情况下，某些线程可能保持不间断）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptIdleWorkers(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">常见的中断形式，以避免记住布尔参数的含义。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reject(Runnable command): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为给定命令调用被拒绝的执行处理程序。受ScheduledThreadPoolExecutor保护的包。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>onShutdown(): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在调用shutdown时执行运行状态转换后的任何进一步清理。此处为no-op，但ScheduledThreadPoolExecutor使用它来取消延迟的任务。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isRunningOrShutdown(boolean shutdownOK): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">ScheduledThreadPoolExecutor需要进行状态检查，以在关机期间启用正在运行的任务。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>drainQueue(): List<Runnable></strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将任务队列排入新列表，通常使用drainTo。但是，如果队列是延迟队列或任何其他类型的队列，轮询或拖拽可能无法删除其中的某些元素，则它会逐个删除它们。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>addWorker(Runnable firstTask, boolean core): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">检查是否可以根据当前池状态和给定边界（核心或最大值）添加新工作线程。如果是这样，将相应地调整工作人员计数，如果可能，将创建并启动一个新的工作人员，将firstTask作为其第一个任务运行。如果池已停止或有资格关闭，则此方法返回false。如果线程工厂在被请求时未能创建线程，它也会返回false。如果由于线程工厂返回null或由于异常（通常是thread.start（）中的OutOfMemoryError），线程创建失败，我们将完全回滚。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>addWorkerFailed(Worker w): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">回滚工作线程创建。-从工作人员中移除工作人员，如果存在-减少工作人员计数-如果该工作人员的存在阻碍了终止，则重新检查是否终止</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>processWorkerExit(Worker w, boolean completedAbruptly): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为垂死的工人执行清理和记账。仅从工作线程调用。除非设置了“突然完成”，否则假定workerCount已被调整以考虑退出。此方法从工作线程集中删除线程，如果由于用户任务异常退出工作线程，或者如果正在运行的工作线程少于corePoolSize，或者队列为非空但没有工作线程，则可能终止池或替换工作线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTask(): Runnable</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">根据当前的配置设置，执行阻塞或定时等待任务，或者如果此工作线程由于以下任何原因必须退出，则返回null：1.存在多个maximumPoolSize工作线程（由于调用setMaximumPoolSize）。2.停止游泳池。3.池已关闭，队列为空。4.此工作线程在等待任务时超时，超时工作线程在超时等待前后都会终止（即“allowCoreThreadTimeOut</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runWorker(Worker w): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">主要工作人员运行循环。重复地从队列中获取任务并执行它们，同时处理许多问题：1.我们可以从初始任务开始，在这种情况下，我们不需要获取第一个任务。否则，只要池在运行，我们就可以从getTask获取任务。如果返回null，则工作进程将由于池状态或配置参数的更改而退出。其他退出源于外部代码中的异常抛出，在这种情况下，CompletedJustly保持不变，这通常会导致processWorkerExit替换此线程。2.在运行任何任务之前，获取锁以防止在任务执行时发生其他池中断，然后我们确保除非池停止，否则此线程没有中断集。3.每次任务运行之前都会调用beforeExecute，这可能会引发异常，在这种情况下，我们会导致线程死亡（使用CompletedArjustly true中断循环），而不处理任务。4.假设beforeExecute正常完成，我们运行任务，收集其抛出的任何异常以发送给afterExecute。我们分别处理RuntimeException、Error（这两个规范都保证我们可以捕获）和任意可丢弃文件。因为我们无法在Runnable内回收和丢弃。运行时，我们将它们包装在退出时的错误中（到线程的UncaughtExceptionHandler）。任何抛出的异常也会保守地导致线程死亡。5.完成任务后。运行完成后，我们调用afterExecute，它也可能引发异常，这也会导致线程死亡。根据JLS第14.20节，此例外情况将有效，即使任务已完成。奔跑和投掷。异常机制的最终效果是，afterExecute和线程的UncaughtExceptionHandler具有我们所能提供的关于用户代码遇到的任何问题的准确信息。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定的初始参数和默认线程工厂以及被拒绝的执行处理程序创建新的“ThreadPoolExecutor”。使用“执行器”工厂方法之一而不是此通用构造函数可能更方便。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定的初始参数和默认拒绝执行处理程序创建新的“ThreadPoolExecutor”。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定的初始参数和默认线程工厂创建新的“ThreadPoolExecutor”。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用给定的初始参数创建新的“ThreadPoolExecutor”。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>execute(Runnable command): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">在将来的某个时候执行给定的任务。任务可以在新线程或现有池线程中执行。如果由于此执行器已关闭或已达到其容量而无法提交任务执行，则该任务将由当前的“RejectedExecutionHandler”处理。</td>
<td align="left">RejectedExecutionException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>shutdown(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">启动有序关机，执行以前提交的任务，但不接受新任务。如果调用已经关闭，则调用没有额外的效果<p> 此方法不会等待以前提交的任务完成执行。使用“#awaitTermination”完成此操作。</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>shutdownNow(): List<Runnable></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务列表。从该方法返回时，这些任务将从任务队列中排出（删除）<p> 此方法不会等待主动执行的任务终止。使用“#awaitTermination”完成此操作<p> 除了尽最大努力尝试停止处理正在积极执行的任务之外，没有其他保证。此实现通过“线程中断”取消任务，因此任何无法响应中断的任务都可能永远不会终止。</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isShutdown(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isTerminating(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此执行器在‘#shutdown‘或‘＃shutdownNow‘之后正在终止，但尚未完全终止，则返回true。此方法可能对调试有用。关闭后足够长时间内报告的“true”返回可能表示提交的任务忽略或抑制了中断，导致此执行器无法正确终止。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isTerminated(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitTermination(long timeout, TimeUnit unit): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>finalize(): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">当此执行器不再被引用且没有线程时调用“shutdown”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setThreadFactory(ThreadFactory threadFactory): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">设置用于创建新线程的线程工厂。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getThreadFactory(): ThreadFactory</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回用于创建新线程的线程工厂。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setRejectedExecutionHandler(RejectedExecutionHandler handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为不可执行的任务设置新处理程序。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getRejectedExecutionHandler(): RejectedExecutionHandler</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回不可执行任务的当前处理程序。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setCorePoolSize(int corePoolSize): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">设置线程的核心数。这将覆盖构造函数中设置的任何值。如果新值小于当前值，则多余的现有线程将在下次空闲时终止。如果较大，如果需要，将启动新线程以执行任何排队任务。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getCorePoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回核心线程数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>prestartCoreThread(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">启动核心线程，使其空闲等待工作。这将覆盖仅在执行新任务时启动核心线程的默认策略。如果所有核心线程都已启动，此方法将返回“false”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ensurePrestart(): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">与prestartCoreThread相同，不同之处在于即使corePoolSize为0，也安排至少启动一个线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>prestartAllCoreThreads(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">启动所有核心线程，使它们空闲等待工作。这将覆盖仅在执行新任务时启动核心线程的默认策略。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>allowsCoreThreadTimeOut(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此池允许核心线程超时，并在keepAlive时间内没有任务到达时终止，则返回true，如果新任务到达时需要替换。如果为true，应用于非核心线程的相同保持活动策略也适用于核心线程。如果为false（默认值），则核心线程永远不会因缺少传入任务而终止。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>allowCoreThreadTimeOut(boolean value): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">设置控制核心线程是否可能超时并在保持活动时间内没有任务到达时终止的策略，如果需要，在新任务到达时替换。如果为false，则核心线程永远不会因缺少传入任务而终止。如果为true，应用于非核心线程的相同保持活动策略也适用于核心线程。为避免连续更换线程，设置“true”时，保持活动时间必须大于零。通常应在主动使用池之前调用此方法。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>setMaximumPoolSize(int maximumPoolSize): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">设置允许的最大线程数。这将覆盖构造函数中设置的任何值。如果新值小于当前值，则多余的现有线程将在下次空闲时终止。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getMaximumPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回允许的最大线程数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setKeepAliveTime(long time, TimeUnit unit): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">设置线程在终止前保持空闲的时间限制。如果池中的线程数超过了当前的核心数，则在等待这段时间而不处理任务后，多余的线程将被终止。这将覆盖构造函数中设置的任何值。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getKeepAliveTime(TimeUnit unit): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回线程保持活动时间，即超过核心池大小的线程在终止前可能保持空闲的时间量。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueue(): BlockingQueue<Runnable></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此执行器使用的任务队列。对任务队列的访问主要用于调试和监视。此队列可能正在使用中。检索任务队列不会阻止队列中的任务执行。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>remove(Runnable task): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果存在此任务，则将其从执行器的内部队列中移除，从而导致尚未启动的任务无法运行<p> 该方法可以用作抵消方案的一部分。它可能无法删除在放入内部队列之前已转换为其他形式的任务。例如，使用“提交”输入的任务可能会转换为维护“未来”状态的表单。然而，在这种情况下，可以使用方法“#purge”删除已取消的期货。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>purge(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试从工作队列中删除所有已取消的“未来”任务。此方法可用于存储回收操作，对功能没有其他影响。取消的任务永远不会执行，但可能会累积在工作队列中，直到工作线程可以主动删除它们。调用此方法会尝试立即删除它们。但是，如果存在其他线程的干扰，此方法可能无法删除任务。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回池中当前线程数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getActiveCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回正在积极执行任务的线程的近似数目。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLargestPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回池中同时存在的最大线程数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTaskCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回计划执行的任务的大致总数。由于任务和线程的状态在计算过程中可能会动态变化，因此返回值仅为近似值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCompletedTaskCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回已完成执行的任务的大致总数。由于任务和线程的状态在计算过程中可能会动态变化，因此返回值只是一个近似值，但在连续调用中不会减少。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回标识此池及其状态的字符串，包括运行状态的指示以及估计的工作线程和任务计数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>beforeExecute(Thread t, Runnable r): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">方法在给定线程中执行给定Runnable之前调用。此方法由执行任务“r”的线程“t”调用，可用于重新初始化ThreadLocals或执行日志记录<p> 这个实现什么都不做，但可以在子类中自定义。注意：为了正确嵌套多个重写，子类通常应该调用’super’。在此方法结尾处的“beforeExecute”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>afterExecute(Runnable r, Throwable t): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">方法在给定Runnable的执行完成时调用。此方法由执行任务的线程调用。如果非空，则可丢弃的是导致执行突然终止的未捕获的“RuntimeException”或“Error”<p> 这个实现什么都不做，但可以在子类中自定义。注意：为了正确嵌套多个重写，子类通常应该调用’super’。此方法开头的“afterExecute”<p> <b>注意：</b>当操作显式或通过“提交”等方法包含在任务中（如“FutureTask”）时，这些任务对象捕捉并维护计算异常，因此它们不会导致突然终止，内部异常不会传递给此方法。如果您想在这种方法中捕获这两种故障，您可以进一步探索这种情况，在这个示例子类中，如果任务已中止，则打印直接原因或底层异常：＜pre＞‘类ExtendedExecutor扩展ThreadPoolExecutor｛protected void afterExecute（Runnable r，Throwable t）｛super.afterExeuction（r，t）；if（t&#x3D;&#x3D;null&amp;&amp;r instanceof Future＜？＞）｛try｛Object result&#x3D;（（Future＞？＞）r.get（）；‘catch（CancelationException ce）｛t&#x3D;ce；｝catch（ExecutionException ee）{t&#x3D;ee.getCause（）；}捕捉（中断异常ie）{Thread.currentThread（）.interrupt（）；}如果（t！&#x3D;null）System.out。println（t）；}}</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>terminated(): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">方法在执行器终止时调用。默认实现不执行任何操作。注意：为了正确嵌套多个重写，子类通常应该调用’super’。在该方法中终止。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ThreadPoolExecutor-Worker"><a href="#ThreadPoolExecutor-Worker" class="headerlink" title="ThreadPoolExecutor$Worker"></a><a href="./ThreadPoolExecutor$Worker.html">ThreadPoolExecutor$Worker</a></h3><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor$CallerRunsPolicy"></a><a href="./ThreadPoolExecutor$CallerRunsPolicy.html">ThreadPoolExecutor$CallerRunsPolicy</a></h3><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor$AbortPolicy"></a><a href="./ThreadPoolExecutor$AbortPolicy.html">ThreadPoolExecutor$AbortPolicy</a></h3><h3 id="ThreadPoolExecutor-DiscardPolicy"><a href="#ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="ThreadPoolExecutor$DiscardPolicy"></a><a href="./ThreadPoolExecutor$DiscardPolicy.html">ThreadPoolExecutor$DiscardPolicy</a></h3><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor$DiscardOldestPolicy"></a><a href="./ThreadPoolExecutor$DiscardOldestPolicy.html">ThreadPoolExecutor$DiscardOldestPolicy</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
