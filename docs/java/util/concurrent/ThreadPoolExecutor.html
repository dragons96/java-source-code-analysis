<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ThreadPoolExecutor.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"},"main":[{"text":"java","type":"label","children":[{"text":"util","type":"label","children":[{"text":"concurrent","type":"label","children":[{"text":"AbstractExecutorService","type":"link","path":"AbstractExecutorService.html"}]}]}]}]}},"config":{"timezone":"Asia/Shanghai","root":"/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ThreadPoolExecutor</strong></td>
<td align="center">class</td>
<td align="center">AbstractExecutorService</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ctl: AtomicInteger</strong></td>
<td align="center">new AtomicInteger(ctlOf(RUNNING, 0))</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState,    indicating whether running, shutting down etc  In order to pack them into one int, we limit workerCount to (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 billion) otherwise representable. If this is ever an issue in the future, the variable can be changed to be an AtomicLong, and the shift&#x2F;mask constants below adjusted. But until the need arises, this code is a bit faster and simpler using an int.  The workerCount is the number of workers that have been permitted to start and not permitted to stop.  The value may be transiently different from the actual number of live threads, for example when a ThreadFactory fails to create a thread when asked, and when exiting threads are still performing bookkeeping before terminating. The user-visible pool size is reported as the current size of the workers set.  The runState provides the main lifecycle control, taking on values:  RUNNING:  Accept new tasks and process queued tasks SHUTDOWN: Don’t accept new tasks, but process queued tasks STOP:     Don’t accept new tasks, don’t process queued tasks, and interrupt in-progress tasks TIDYING:  All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method TERMINATED: terminated() has completed  The numerical order among these values matters, to allow ordered comparisons. The runState monotonically increases over time, but need not hit each state. The transitions are:  RUNNING -&gt; SHUTDOWN On invocation of shutdown(), perhaps implicitly in finalize() (RUNNING or SHUTDOWN) -&gt; STOP On invocation of shutdownNow() SHUTDOWN -&gt; TIDYING When both queue and pool are empty STOP -&gt; TIDYING When pool is empty TIDYING -&gt; TERMINATED When the terminated() hook method has completed  Threads waiting in awaitTermination() will return when the state reaches TERMINATED.  Detecting the transition from SHUTDOWN to TIDYING is less straightforward than you’d like because the queue may become empty after non-empty and vice versa during SHUTDOWN state, but we can only terminate if, after seeing that it is empty, we see that workerCount is 0 (which sometimes entails a recheck – see below).</td>
</tr>
<tr>
<td align="center"><strong>COUNT_BITS: int</strong></td>
<td align="center">Integer.SIZE - 3</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CAPACITY: int</strong></td>
<td align="center">(1 &lt;&lt; COUNT_BITS) - 1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>RUNNING: int</strong></td>
<td align="center">-1 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SHUTDOWN: int</strong></td>
<td align="center">0 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>STOP: int</strong></td>
<td align="center">1 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TIDYING: int</strong></td>
<td align="center">2 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TERMINATED: int</strong></td>
<td align="center">3 &lt;&lt; COUNT_BITS</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>workQueue: BlockingQueue&lt;Runnable&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The queue used for holding tasks and handing off to worker threads.  We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING).  This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire.</td>
</tr>
<tr>
<td align="center"><strong>mainLock: ReentrantLock</strong></td>
<td align="center">new ReentrantLock()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Lock held on access to workers set and related bookkeeping. While we could use a concurrent set of some sort, it turns out to be generally preferable to use a lock. Among the reasons is that this serializes interruptIdleWorkers, which avoids unnecessary interrupt storms, especially during shutdown. Otherwise exiting threads would concurrently interrupt those that have not yet interrupted. It also simplifies some of the associated statistics bookkeeping of largestPoolSize etc. We also hold mainLock on shutdown and shutdownNow, for the sake of ensuring workers set is stable while separately checking permission to interrupt and actually interrupting.</td>
</tr>
<tr>
<td align="center"><strong>(): HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;</strong></td>
<td align="center">new HashSet<Worker>()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Set containing all worker threads in pool. Accessed only when holding mainLock.</td>
</tr>
<tr>
<td align="center"><strong>termination: Condition</strong></td>
<td align="center">mainLock.newCondition()</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Wait condition to support awaitTermination</td>
</tr>
<tr>
<td align="center"><strong>largestPoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tracks largest attained pool size. Accessed only under mainLock.</td>
</tr>
<tr>
<td align="center"><strong>completedTaskCount: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Counter for completed tasks. Updated only on termination of worker threads. Accessed only under mainLock.</td>
</tr>
<tr>
<td align="center"><strong>threadFactory: ThreadFactory</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Factory for new threads. All threads are created using this factory (via method addWorker).  All callers must be prepared for addWorker to fail, which may reflect a system or user’s policy limiting the number of threads.  Even though it is not treated as an error, failure to create threads may result in new tasks being rejected or existing ones remaining stuck in the queue.  We go further and preserve pool invariants even in the face of errors such as OutOfMemoryError, that might be thrown while trying to create threads.  Such errors are rather common due to the need to allocate a native stack in Thread.start, and users will want to perform clean pool shutdown to clean up.  There will likely be enough memory available for the cleanup code to complete without encountering yet another OutOfMemoryError.</td>
</tr>
<tr>
<td align="center"><strong>handler: RejectedExecutionHandler</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Handler called when saturated or shutdown in execute.</td>
</tr>
<tr>
<td align="center"><strong>keepAliveTime: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Timeout in nanoseconds for idle threads waiting for work. Threads use this timeout when there are more than corePoolSize present or if allowCoreThreadTimeOut. Otherwise they wait forever for new work.</td>
</tr>
<tr>
<td align="center"><strong>allowCoreThreadTimeOut: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If false (default), core threads stay alive even when idle. If true, core threads use keepAliveTime to time out waiting for work.</td>
</tr>
<tr>
<td align="center"><strong>corePoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Core pool size is the minimum number of workers to keep alive (and not allow to time out etc) unless allowCoreThreadTimeOut is set, in which case the minimum is zero.</td>
</tr>
<tr>
<td align="center"><strong>maximumPoolSize: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Maximum pool size. Note that the actual maximum is internally bounded by CAPACITY.</td>
</tr>
<tr>
<td align="center"><strong>defaultHandler: RejectedExecutionHandler</strong></td>
<td align="center">new AbortPolicy()</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The default rejected execution handler</td>
</tr>
<tr>
<td align="center"><strong>shutdownPerm: RuntimePermission</strong></td>
<td align="center">new RuntimePermission(“modifyThread”)</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Permission required for callers of shutdown and shutdownNow. We additionally require (see checkShutdownAccess) that callers have permission to actually interrupt threads in the worker set (as governed by Thread.interrupt, which relies on ThreadGroup.checkAccess, which in turn relies on SecurityManager.checkAccess). Shutdowns are attempted only if these checks pass.  All actual invocations of Thread.interrupt (see interruptIdleWorkers and interruptWorkers) ignore SecurityExceptions, meaning that the attempted interrupts silently fail. In the case of shutdown, they should not fail unless the SecurityManager has inconsistent policies, sometimes allowing access to a thread and sometimes not. In such cases, failure to actually interrupt threads may disable or delay full termination. Other uses of interruptIdleWorkers are advisory, and failure to actually interrupt will merely delay response to configuration changes so is not handled exceptionally.</td>
</tr>
<tr>
<td align="center"><strong>acc: AccessControlContext</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The context to be used when executing the finalizer, or null.</td>
</tr>
<tr>
<td align="center"><strong>ONLY_ONE: boolean</strong></td>
<td align="center">true</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>runStateLessThan(int c, int s): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Bit field accessors that don’t require unpacking ctl. These depend on the bit layout and on workerCount being never negative.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runStateAtLeast(int c, int s): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isRunning(int c): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareAndIncrementWorkerCount(int expect): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to CAS-increment the workerCount field of ctl.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compareAndDecrementWorkerCount(int expect): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to CAS-decrement the workerCount field of ctl.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>decrementWorkerCount(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Decrements the workerCount field of ctl. This is called only on abrupt termination of a thread (see processWorkerExit). Other decrements are performed within getTask.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>advanceRunState(int targetState): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Transitions runState to given target, or leaves it alone if already at least the given target.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryTerminate(): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty).  If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible – reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>checkShutdownAccess(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If there is a security manager, makes sure caller has permission to shut down threads in general (see shutdownPerm). If this passes, additionally makes sure the caller is allowed to interrupt each worker thread. This might not be true even if first check passed, if the SecurityManager treats some threads specially.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptWorkers(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Interrupts all threads, even if active. Ignores SecurityExceptions (in which case some threads may remain uninterrupted).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptIdleWorkers(boolean onlyOne): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Interrupts threads that might be waiting for tasks (as indicated by not being locked) so they can check for termination or configuration changes. Ignores SecurityExceptions (in which case some threads may remain uninterrupted).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>interruptIdleWorkers(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Common form of interruptIdleWorkers, to avoid having to remember what the boolean argument means.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reject(Runnable command): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Invokes the rejected execution handler for the given command. Package-protected for use by ScheduledThreadPoolExecutor.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>onShutdown()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Performs any further cleanup following run state transition on invocation of shutdown.  A no-op here, but used by ScheduledThreadPoolExecutor to cancel delayed tasks.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isRunningOrShutdown(boolean shutdownOK): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">State check needed by ScheduledThreadPoolExecutor to enable running tasks during shutdown.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>drainQueue(): List<Runnable></strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Drains the task queue into a new list, normally using drainTo. But if the queue is a DelayQueue or any other kind of queue for which poll or drainTo may fail to remove some elements, it deletes them one by one.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>addWorker(Runnable firstTask, boolean core): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Checks if a new worker can be added with respect to current pool state and the given bound (either core or maximum). If so, the worker count is adjusted accordingly, and, if possible, a new worker is created and started, running firstTask as its first task. This method returns false if the pool is stopped or eligible to shut down. It also returns false if the thread factory fails to create a thread when asked.  If the thread creation fails, either due to the thread factory returning null, or due to an exception (typically OutOfMemoryError in Thread.start()), we roll back cleanly.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>addWorkerFailed(Worker w): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>processWorkerExit(Worker w, boolean completedAbruptly): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit.  This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTask(): Runnable</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Performs blocking or timed wait for a task, depending on current configuration settings, or returns null if this worker must exit because of any of: 1. There are more than maximumPoolSize workers (due to a call to setMaximumPoolSize). 2. The pool is stopped. 3. The pool is shutdown and the queue is empty. 4. This worker timed out waiting for a task, and timed-out workers are subject to termination (that is, ‘allowCoreThreadTimeOut</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>runWorker(Worker w): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Main worker run loop.  Repeatedly gets tasks from queue and executes them, while coping with a number of issues:  1. We may start out with an initial task, in which case we don’t need to get the first one. Otherwise, as long as pool is running, we get tasks from getTask. If it returns null then the worker exits due to changed pool state or configuration parameters.  Other exits result from exception throws in external code, in which case completedAbruptly holds, which usually leads processWorkerExit to replace this thread.  2. Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set.  3. Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task.  4. Assuming beforeExecute completes normally, we run the task, gathering any of its thrown exceptions to send to afterExecute. We separately handle RuntimeException, Error (both of which the specs guarantee that we trap) and arbitrary Throwables. Because we cannot rethrow Throwables within Runnable.run, we wrap them within Errors on the way out (to the thread’s UncaughtExceptionHandler).  Any thrown exception also conservatively causes thread to die.  5. After task.run completes, we call afterExecute, which may also throw an exception, which will also cause thread to die. According to JLS Sec 14.20, this exception is the one that will be in effect even if task.run throws.  The net effect of the exception mechanics is that afterExecute and the thread’s UncaughtExceptionHandler have as accurate information as we can provide about any problems encountered by user code.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new ‘ThreadPoolExecutor’ with the given initial parameters and default thread factory and rejected execution handler. It may be more convenient to use one of the ‘Executors’ factory methods instead of this general purpose constructor.</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new ‘ThreadPoolExecutor’ with the given initial parameters and default rejected execution handler.</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new ‘ThreadPoolExecutor’ with the given initial parameters and default thread factory.</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new ‘ThreadPoolExecutor’ with the given initial parameters.</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>execute(Runnable command): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Executes the given task sometime in the future.  The task may execute in a new thread or in an existing pooled thread.  If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current ‘RejectedExecutionHandler’.</td>
<td align="left">NullPointerException<br/>RejectedExecutionException</td>
</tr>
<tr>
<td align="center"><strong>shutdown(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down.  <p>This method does not wait for previously submitted tasks to complete execution.  Use ‘#awaitTermination awaitTermination’ to do that.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>shutdownNow(): List<Runnable></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. These tasks are drained (removed) from the task queue upon return from this method.  <p>This method does not wait for actively executing tasks to terminate.  Use ‘#awaitTermination awaitTermination’ to do that.  <p>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks.  This implementation cancels tasks via ‘Thread#interrupt’, so any task that fails to respond to interrupts may never terminate.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isShutdown(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isTerminating(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns true if this executor is in the process of terminating after ‘#shutdown’ or ‘#shutdownNow’ but has not completely terminated.  This method may be useful for debugging. A return of ‘true’ reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isTerminated(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>awaitTermination(long timeout, TimeUnit unit): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">InterruptedException</td>
</tr>
<tr>
<td align="center"><strong>finalize(): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Invokes ‘shutdown’ when this executor is no longer referenced and it has no threads.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setThreadFactory(ThreadFactory threadFactory): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the thread factory used to create new threads.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getThreadFactory(): ThreadFactory</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the thread factory used to create new threads.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setRejectedExecutionHandler(RejectedExecutionHandler handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets a new handler for unexecutable tasks.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getRejectedExecutionHandler(): RejectedExecutionHandler</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the current handler for unexecutable tasks.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setCorePoolSize(int corePoolSize): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the core number of threads.  This overrides any value set in the constructor.  If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.  If larger, new threads will, if needed, be started to execute any queued tasks.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getCorePoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the core number of threads.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>prestartCoreThread(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return ‘false’ if all core threads have already been started.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ensurePrestart()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>prestartAllCoreThreads(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>allowsCoreThreadTimeOut(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive. When true, the same keep-alive policy applying to non-core threads applies also to core threads. When false (the default), core threads are never terminated due to lack of incoming tasks.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>allowCoreThreadTimeOut(boolean value): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive. When false, core threads are never terminated due to lack of incoming tasks. When true, the same keep-alive policy applying to non-core threads applies also to core threads. To avoid continual thread replacement, the keep-alive time must be greater than zero when setting ‘true’. This method should in general be called before the pool is actively used.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>setMaximumPoolSize(int maximumPoolSize): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getMaximumPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the maximum allowed number of threads.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setKeepAliveTime(long time, TimeUnit unit): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets the time limit for which threads may remain idle before being terminated.  If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads will be terminated.  This overrides any value set in the constructor.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getKeepAliveTime(TimeUnit unit): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the thread keep-alive time, which is the amount of time that threads in excess of the core pool size may remain idle before being terminated.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getQueue(): BlockingQueue<Runnable></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use.  Retrieving the task queue does not prevent queued tasks from executing.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>remove(Runnable task): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes this task from the executor’s internal queue if it is present, thus causing it not to be run if it has not already started.  <p>This method may be useful as one part of a cancellation scheme.  It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using ‘submit’ might be converted into a form that maintains ‘Future’ status. However, in such cases, method ‘#purge’ may be used to remove those Futures that have been cancelled.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>purge(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tries to remove from the work queue all ‘Future’ tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the current number of threads in the pool.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getActiveCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the approximate number of threads that are actively executing tasks.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLargestPoolSize(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the largest number of threads that have ever simultaneously been in the pool.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTaskCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCompletedTaskCount(): long</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ThreadPoolExecutor-Worker"><a href="#ThreadPoolExecutor-Worker" class="headerlink" title="ThreadPoolExecutor$Worker"></a><a href="./ThreadPoolExecutor$Worker.html">ThreadPoolExecutor$Worker</a></h3><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor$CallerRunsPolicy"></a><a href="./ThreadPoolExecutor$CallerRunsPolicy.html">ThreadPoolExecutor$CallerRunsPolicy</a></h3><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor$AbortPolicy"></a><a href="./ThreadPoolExecutor$AbortPolicy.html">ThreadPoolExecutor$AbortPolicy</a></h3><h3 id="ThreadPoolExecutor-DiscardPolicy"><a href="#ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="ThreadPoolExecutor$DiscardPolicy"></a><a href="./ThreadPoolExecutor$DiscardPolicy.html">ThreadPoolExecutor$DiscardPolicy</a></h3><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor$DiscardOldestPolicy"></a><a href="./ThreadPoolExecutor$DiscardOldestPolicy.html">ThreadPoolExecutor$DiscardOldestPolicy</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
