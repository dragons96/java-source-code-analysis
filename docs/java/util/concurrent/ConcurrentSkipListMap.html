<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ConcurrentSkipListMap.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"},"main":[{"text":"java","type":"label","children":[{"text":"util","type":"label","children":[{"text":"concurrent","type":"label","children":[{"text":"AbstractExecutorService","type":"link","path":"AbstractExecutorService.html"}]}]}]}]}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ConcurrentSkipListMap-lt-K-V-gt"><a href="#ConcurrentSkipListMap-lt-K-V-gt" class="headerlink" title="ConcurrentSkipListMap&lt;K,V&gt;"></a>ConcurrentSkipListMap&lt;K,V&gt;</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">父接口</th>
<th align="center">泛型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ConcurrentSkipListMap&lt;K,V&gt;</strong></td>
<td align="center">class</td>
<td align="center">AbstractMap&lt;K,V&gt;implements</td>
<td align="center">ConcurrentNavigableMap&lt;K,V&gt;,Cloneable,Serializable</td>
<td align="center">&lt;K&gt;,&lt;V&gt;</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>serialVersionUID: long</strong></td>
<td align="center">-8627078645895051609L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">This class implements a tree-like two-dimensionally linked skip list in which the index levels are represented in separate nodes from the base nodes holding data.  There are two reasons for taking this approach instead of the usual array-based structure: 1) Array based implementations seem to encounter more complexity and overhead 2) We can use cheaper algorithms for the heavily-traversed index lists than can be used for the base lists.  Here’s a picture of some of the basics for a possible list with 2 levels of index:  Head nodes          Index nodes +-+    right        +-+                      +-+</td>
</tr>
<tr>
<td align="center"><strong>BASE_HEADER: Object</strong></td>
<td align="center">new Object()</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Special value used to identify base-level header</td>
</tr>
<tr>
<td align="center"><strong>head: HeadIndex&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">The topmost head index of the skiplist.</td>
</tr>
<tr>
<td align="center"><strong>comparator: Comparator&lt;? super K&gt;</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The comparator used to maintain order in this map, or null if using natural ordering.  (Non-private to simplify access in nested classes.) @serial</td>
</tr>
<tr>
<td align="center"><strong>keySet: KeySet&lt;K&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Lazily initialized key set</td>
</tr>
<tr>
<td align="center"><strong>entrySet: EntrySet&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Lazily initialized entry set</td>
</tr>
<tr>
<td align="center"><strong>values: Values&lt;V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Lazily initialized values collection</td>
</tr>
<tr>
<td align="center"><strong>descendingMap: ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Lazily initialized descending key set</td>
</tr>
<tr>
<td align="center"><strong>EQ: int</strong></td>
<td align="center">1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">—————- Relational operations ————–</td>
</tr>
<tr>
<td align="center"><strong>LT: int</strong></td>
<td align="center">2</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>GT: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>UNSAFE: sun.misc.Unsafe</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>headOffset: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SECONDARY: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>initialize(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initializes or resets state. Needed by constructors, clone, clear, readObject. and ConcurrentSkipListSet.clone. (Note that comparator must be separately initialized.)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>casHead(HeadIndex&lt;K,V&gt; cmp, HeadIndex&lt;K,V&gt; val): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">compareAndSet head node</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>cpr(Comparator c, Object x, Object y): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Compares using comparator or natural ordering if null. Called only by methods that have performed required type checks.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findPredecessor(Object key, Comparator&lt;? super K&gt; cmp): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a base-level node with key strictly less than given key, or the base-level header if there is no such node.  Also unlinks indexes to deleted nodes found along the way.  Callers rely on this side-effect of clearing indices to deleted nodes.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findNode(Object key): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns node holding key or null if no such, clearing out any deleted nodes seen along the way.  Repeatedly traverses at base-level looking for key starting at predecessor returned from findPredecessor, processing base-level deletions as encountered. Some callers rely on this side-effect of clearing deleted nodes.  Restarts occur, at traversal step centered on node n, if:  (1) After reading n’s next field, n is no longer assumed predecessor b’s current successor, which means that we don’t have a consistent 3-node snapshot and so cannot unlink any subsequent deleted nodes encountered.  (2) n’s value field is null, indicating n is deleted, in which case we help out an ongoing structural deletion before retrying.  Even though there are cases where such unlinking doesn’t require restart, they aren’t sorted out here because doing so would not usually outweigh cost of restarting.  (3) n is a marker or n’s predecessor’s value field is null, indicating (among other possibilities) that findPredecessor returned a deleted node. We can’t unlink the node because we don’t know its predecessor, so rely on another call to findPredecessor to notice and return some earlier predecessor, which it will do. This check is only strictly needed at beginning of loop, (and the b.value check isn’t strictly needed at all) but is done each iteration to help avoid contention with other threads by callers that will fail to be able to change links, and so will retry anyway.  The traversal loops in doPut, doRemove, and findNear all include the same three kinds of checks. And specialized versions appear in findFirst, and findLast and their variants. They can’t easily share code because each uses the reads of fields held in locals occurring in the orders they were performed.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doGet(Object key): V</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Gets value for key. Almost the same as findNode, but returns the found value (to avoid retries during re-reads)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doPut(K key, V value, boolean onlyIfAbsent): V</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Main insertion method.  Adds element if not present, or replaces value if present and onlyIfAbsent is false.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemove(Object key, Object value): V</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Main deletion method. Locates node, nulls value, appends a deletion marker, unlinks predecessor, removes associated index nodes, and possibly reduces head index level.  Index nodes are cleared out simply by calling findPredecessor. which unlinks indexes to deleted nodes found along path to key, which will include the indexes to this node.  This is done unconditionally. We can’t check beforehand whether there are index nodes because it might be the case that some or all indexes hadn’t been inserted yet for this node during initial search for it, and we’d like to ensure lack of garbage retention, so must call to be sure.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryReduceLevel(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Possibly reduce head level if it has no nodes.  This method can (rarely) make mistakes, in which case levels can disappear even though they are about to contain index nodes. This impacts performance, not correctness.  To minimize mistakes as well as to reduce hysteresis, the level is reduced by one only if the topmost three levels look empty. Also, if the removed level looks non-empty after CAS, we try to change it back quick before anyone notices our mistake! (This trick works pretty well because this method will practically never make mistakes unless current thread stalls immediately before first CAS, in which case it is very unlikely to stall again immediately afterwards, so will recover.)  We put up with all this rather than just let levels grow because otherwise, even a small map that has undergone a large number of insertions and removals will have a lot of levels, slowing down access more than would an occasional unwanted reduction.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findFirst(): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Specialized variant of findNode to get first valid node.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemoveFirstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes first entry; returns its snapshot.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clearIndexToFirst(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Clears out index nodes associated with deleted first entry.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemoveLastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes last entry; returns its snapshot. Specialized variant of doRemove.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findLast(): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Specialized version of find to get last valid node.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findPredecessorOfLast(): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Specialized variant of findPredecessor to get predecessor of last valid node.  Needed when removing the last entry.  It is possible that all successors of returned node will have been deleted upon return, in which case this method can be retried.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findNear(K key, int rel, Comparator&lt;? super K&gt; cmp): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Utility for ceiling, floor, lower, higher methods.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNear(K key, int rel): AbstractMap.SimpleImmutableEntry&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns SimpleImmutableEntry for results of findNear.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap()</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a new, empty map, sorted according to the ‘Comparable natural ordering’ of the keys.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a new, empty map, sorted according to the specified comparator.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a new map containing the same mappings as the given map, sorted according to the ‘Comparable natural ordering’ of the keys.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a new map containing the same mappings and using the same ordering as the specified sorted map.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>clone(): ConcurrentSkipListMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a shallow copy of this ‘ConcurrentSkipListMap’ instance. (The keys and values themselves are not cloned.)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>buildFromSorted(SortedMap&lt;K, ? extends V&gt; map): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Streamlined bulk insertion to initialize from elements of given sorted map.  Call only from constructor or clone method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>writeObject(java.io.ObjectOutputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Saves this map to a stream (that is, serializes it).</td>
<td align="left">java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>readObject(final java.io.ObjectInputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reconstitutes this map from a stream (that is, deserializes it).</td>
<td align="left">ClassNotFoundException<br/>java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>containsKey(Object key): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns ‘true’ if this map contains a mapping for the specified key.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>get(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the value to which the specified key is mapped, or ‘null’ if this map contains no mapping for the key.  <p>More formally, if this map contains a mapping from a key ‘k’ to a value ‘v’ such that ‘key’ compares equal to ‘k’ according to the map’s ordering, then this method returns ‘v’; otherwise it returns ‘null’. (There can be at most one such mapping.)</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>getOrDefault(Object key, V defaultValue): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>put(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>remove(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes the mapping for the specified key from this map if present.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>containsValue(Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns ‘true’ if this map maps one or more keys to the specified value.  This operation requires time linear in the map size. Additionally, it is possible for the map to change during execution of this method, in which case the returned result may be inaccurate.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>size(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the number of key-value mappings in this map.  If this map contains more than ‘Integer.MAX_VALUE’ elements, it returns ‘Integer.MAX_VALUE’.  <p>Beware that, unlike in most collections, this method is <em>NOT</em> a constant-time operation. Because of the asynchronous nature of these maps, determining the current number of elements requires traversing them all to count them. Additionally, it is possible for the size to change during execution of this method, in which case the returned result will be inaccurate. Thus, this method is typically not very useful in concurrent applications.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isEmpty(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns ‘true’ if this map contains no key-value mappings.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clear(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes all of the mappings from this map.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless ‘null’.  The function is <em>NOT</em> guaranteed to be applied once atomically only if the value is not present.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is <em>NOT</em> guaranteed to be applied once atomically.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>compute(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Attempts to compute a mapping for the specified key and its current mapped value (or ‘null’ if there is no current mapping). The function is <em>NOT</em> guaranteed to be applied once atomically.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>merge(K key, V value,BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If the specified key is not already associated with a value, associates it with the given value.  Otherwise, replaces the value with the results of the given remapping function, or removes if ‘null’. The function is <em>NOT</em> guaranteed to be applied once atomically.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>keySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘NavigableSet’ view of the keys contained in this map.  <p>The set’s iterator returns the keys in ascending order. The set’s spliterator additionally reports ‘Spliterator#CONCURRENT’, ‘Spliterator#NONNULL’, ‘Spliterator#SORTED’ and ‘Spliterator#ORDERED’, with an encounter order that is ascending key order.  The spliterator’s comparator (see ‘java.util.Spliterator#getComparator()’) is ‘null’ if the map’s comparator (see ‘#comparator()’) is ‘null’. Otherwise, the spliterator’s comparator is the same as or imposes the same total ordering as the map’s comparator.  <p>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.  The set supports element removal, which removes the corresponding mapping from the map, via the ‘Iterator.remove’, ‘Set.remove’, ‘removeAll’, ‘retainAll’, and ‘clear’ operations.  It does not support the ‘add’ or ‘addAll’ operations.  <p>The view’s iterators and spliterators are <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.  <p>This method is equivalent to method ‘navigableKeySet’.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>navigableKeySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>values(): Collection<V></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collection’ view of the values contained in this map. <p>The collection’s iterator returns the values in ascending order of the corresponding keys. The collections’s spliterator additionally reports ‘Spliterator#CONCURRENT’, ‘Spliterator#NONNULL’ and ‘Spliterator#ORDERED’, with an encounter order that is ascending order of the corresponding keys.  <p>The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa.  The collection supports element removal, which removes the corresponding mapping from the map, via the ‘Iterator.remove’, ‘Collection.remove’, ‘removeAll’, ‘retainAll’ and ‘clear’ operations.  It does not support the ‘add’ or ‘addAll’ operations.  <p>The view’s iterators and spliterators are <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySet(): Set&lt;Map.Entry&lt;K,V&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Set’ view of the mappings contained in this map.  <p>The set’s iterator returns the entries in ascending key order.  The set’s spliterator additionally reports ‘Spliterator#CONCURRENT’, ‘Spliterator#NONNULL’, ‘Spliterator#SORTED’ and ‘Spliterator#ORDERED’, with an encounter order that is ascending key order.  <p>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.  The set supports element removal, which removes the corresponding mapping from the map, via the ‘Iterator.remove’, ‘Set.remove’, ‘removeAll’, ‘retainAll’ and ‘clear’ operations.  It does not support the ‘add’ or ‘addAll’ operations.  <p>The view’s iterators and spliterators are <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.  <p>The ‘Map.Entry’ elements traversed by the ‘iterator’ or ‘spliterator’ do <em>not</em> support the ‘setValue’ operation.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>descendingMap(): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>descendingKeySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(Object o): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Compares the specified object with this map for equality. Returns ‘true’ if the given object is also a map and the two maps represent the same mappings.  More formally, two maps ‘m1’ and ‘m2’ represent the same mappings if ‘m1.entrySet().equals(m2.entrySet())’.  This operation may return misleading results if either map is concurrently modified during execution of this method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>putIfAbsent(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">‘inheritDoc’</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>remove(Object key, Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">‘inheritDoc’</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V oldValue, V newValue): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">‘inheritDoc’</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">‘inheritDoc’</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>comparator(): K&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">—— SortedMap API methods ——</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>firstKey(): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>lastKey(): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>subMap(K fromKey,boolean fromInclusive,K toKey,boolean toInclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>headMap(K toKey,boolean inclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>tailMap(K fromKey,boolean inclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>subMap(K fromKey, K toKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>headMap(K toKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>tailMap(K fromKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>lowerEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the greatest key strictly less than the given key, or ‘null’ if there is no such key. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>lowerKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>floorEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the greatest key less than or equal to the given key, or ‘null’ if there is no such key. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>floorKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ceilingEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the least key greater than or equal to the given key, or ‘null’ if there is no such entry. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>ceilingKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>higherEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the least key strictly greater than the given key, or ‘null’ if there is no such key. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>higherKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>firstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the least key in this map, or ‘null’ if the map is empty. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a key-value mapping associated with the greatest key in this map, or ‘null’ if the map is empty. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollFirstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes and returns a key-value mapping associated with the least key in this map, or ‘null’ if the map is empty. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollLastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Removes and returns a key-value mapping associated with the greatest key in this map, or ‘null’ if the map is empty. The returned entry does <em>not</em> support the ‘Entry.setValue’ method.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>keyIterator()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Base of iterator classes:</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>valueIterator()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entryIterator()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toList(Collection&lt;E&gt; c): List<E></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">View classes are static, delegating to a ConcurrentNavigableMap to allow use by SubMaps, which outweighs the ugliness of needing type-tests for Iterator methods.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEach(BiConsumer&lt;? super K, ? super V&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Submaps returned by ‘ConcurrentSkipListMap’ submap operations represent a subrange of mappings of their underlying maps. Instances of this class support all methods of their underlying maps, differing in that mappings outside their range are ignored, and attempts to add mappings outside their ranges result in ‘IllegalArgumentException’.  Instances of this class are constructed only using the ‘subMap’, ‘headMap’, and ‘tailMap’ methods of their underlying maps.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>keySpliterator(): KeySpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Base class providing common structure for Spliterators. (Although not all that much common functionality; as usual for view classes, details annoyingly vary in key, value, and entry subclasses in ways that are not worth abstracting out for internal classes.)  The basic split strategy is to recursively descend from top level, row by row, descending to next row when either split off, or the end of row is encountered. Control of the number of splits relies on some statistical estimation: The expected remaining number of elements of a skip list when advancing either across or down decreases by about 25%. To make this observation useful, we need to know initial size, which we don’t. But we can just use Integer.MAX_VALUE so that we don’t prematurely zero out while splitting.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>valueSpliterator(): ValueSpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySpliterator(): EntrySpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ConcurrentSkipListMap-Node"><a href="#ConcurrentSkipListMap-Node" class="headerlink" title="ConcurrentSkipListMap$Node"></a><a href="./ConcurrentSkipListMap$Node.html">ConcurrentSkipListMap$Node</a></h3><h3 id="ConcurrentSkipListMap-Index"><a href="#ConcurrentSkipListMap-Index" class="headerlink" title="ConcurrentSkipListMap$Index"></a><a href="./ConcurrentSkipListMap$Index.html">ConcurrentSkipListMap$Index</a></h3><h3 id="ConcurrentSkipListMap-HeadIndex"><a href="#ConcurrentSkipListMap-HeadIndex" class="headerlink" title="ConcurrentSkipListMap$HeadIndex"></a><a href="./ConcurrentSkipListMap$HeadIndex.html">ConcurrentSkipListMap$HeadIndex</a></h3><h3 id="ConcurrentSkipListMap-Iter"><a href="#ConcurrentSkipListMap-Iter" class="headerlink" title="ConcurrentSkipListMap$Iter"></a><a href="./ConcurrentSkipListMap$Iter.html">ConcurrentSkipListMap$Iter</a></h3><h3 id="ConcurrentSkipListMap-ValueIterator"><a href="#ConcurrentSkipListMap-ValueIterator" class="headerlink" title="ConcurrentSkipListMap$ValueIterator"></a><a href="./ConcurrentSkipListMap$ValueIterator.html">ConcurrentSkipListMap$ValueIterator</a></h3><h3 id="ConcurrentSkipListMap-KeyIterator"><a href="#ConcurrentSkipListMap-KeyIterator" class="headerlink" title="ConcurrentSkipListMap$KeyIterator"></a><a href="./ConcurrentSkipListMap$KeyIterator.html">ConcurrentSkipListMap$KeyIterator</a></h3><h3 id="ConcurrentSkipListMap-EntryIterator"><a href="#ConcurrentSkipListMap-EntryIterator" class="headerlink" title="ConcurrentSkipListMap$EntryIterator"></a><a href="./ConcurrentSkipListMap$EntryIterator.html">ConcurrentSkipListMap$EntryIterator</a></h3><h3 id="ConcurrentSkipListMap-KeySet"><a href="#ConcurrentSkipListMap-KeySet" class="headerlink" title="ConcurrentSkipListMap$KeySet"></a><a href="./ConcurrentSkipListMap$KeySet.html">ConcurrentSkipListMap$KeySet</a></h3><h3 id="ConcurrentSkipListMap-Values"><a href="#ConcurrentSkipListMap-Values" class="headerlink" title="ConcurrentSkipListMap$Values"></a><a href="./ConcurrentSkipListMap$Values.html">ConcurrentSkipListMap$Values</a></h3><h3 id="ConcurrentSkipListMap-EntrySet"><a href="#ConcurrentSkipListMap-EntrySet" class="headerlink" title="ConcurrentSkipListMap$EntrySet"></a><a href="./ConcurrentSkipListMap$EntrySet.html">ConcurrentSkipListMap$EntrySet</a></h3><h3 id="ConcurrentSkipListMap-SubMap"><a href="#ConcurrentSkipListMap-SubMap" class="headerlink" title="ConcurrentSkipListMap$SubMap"></a><a href="./ConcurrentSkipListMap$SubMap.html">ConcurrentSkipListMap$SubMap</a></h3><h3 id="ConcurrentSkipListMap-CSLMSpliterator"><a href="#ConcurrentSkipListMap-CSLMSpliterator" class="headerlink" title="ConcurrentSkipListMap$CSLMSpliterator"></a><a href="./ConcurrentSkipListMap$CSLMSpliterator.html">ConcurrentSkipListMap$CSLMSpliterator</a></h3><h3 id="ConcurrentSkipListMap-KeySpliterator"><a href="#ConcurrentSkipListMap-KeySpliterator" class="headerlink" title="ConcurrentSkipListMap$KeySpliterator"></a><a href="./ConcurrentSkipListMap$KeySpliterator.html">ConcurrentSkipListMap$KeySpliterator</a></h3><h3 id="ConcurrentSkipListMap-ValueSpliterator"><a href="#ConcurrentSkipListMap-ValueSpliterator" class="headerlink" title="ConcurrentSkipListMap$ValueSpliterator"></a><a href="./ConcurrentSkipListMap$ValueSpliterator.html">ConcurrentSkipListMap$ValueSpliterator</a></h3><h3 id="ConcurrentSkipListMap-EntrySpliterator"><a href="#ConcurrentSkipListMap-EntrySpliterator" class="headerlink" title="ConcurrentSkipListMap$EntrySpliterator"></a><a href="./ConcurrentSkipListMap$EntrySpliterator.html">ConcurrentSkipListMap$EntrySpliterator</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
