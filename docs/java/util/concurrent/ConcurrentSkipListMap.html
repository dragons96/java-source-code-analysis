<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/ConcurrentSkipListMap.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ConcurrentSkipListMap-lt-K-V-gt"><a href="#ConcurrentSkipListMap-lt-K-V-gt" class="headerlink" title="ConcurrentSkipListMap&lt;K,V&gt;"></a>ConcurrentSkipListMap&lt;K,V&gt;</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">父接口</th>
<th align="center">泛型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.ConcurrentSkipListMap&lt;K,V&gt;</strong></td>
<td align="center">class</td>
<td align="center">AbstractMap&lt;K,V&gt;implements</td>
<td align="center">ConcurrentNavigableMap&lt;K,V&gt;,Cloneable,Serializable</td>
<td align="center">&lt;K&gt;,&lt;V&gt;</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>serialVersionUID: long</strong></td>
<td align="center">-8627078645895051609L</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">This class implements a tree-like two-dimensionally linked skip list in which the index levels are represented in separate nodes from the base nodes holding data.  There are two reasons for taking this approach instead of the usual array-based structure: 1) Array based implementations seem to encounter more complexity and overhead 2) We can use cheaper algorithms for the heavily-traversed index lists than can be used for the base lists.  Here’s a picture of some of the basics for a possible list with 2 levels of index:  Head nodes          Index nodes +-+    right        +-+                      +-+</td>
</tr>
<tr>
<td align="center"><strong>BASE_HEADER: Object</strong></td>
<td align="center">new Object()</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于标识基本级别标头的特殊值</td>
</tr>
<tr>
<td align="center"><strong>head: HeadIndex&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">技工的最高头部指数。</td>
</tr>
<tr>
<td align="center"><strong>comparator: Comparator&lt;? super K&gt;</strong></td>
<td align="center">null</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于维持此映射中的顺序的比较器，如果使用自然顺序，则为空。（非私有以简化嵌套类中的访问。）@serial</td>
</tr>
<tr>
<td align="center"><strong>keySet: KeySet&lt;K&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">延迟初始化密钥集</td>
</tr>
<tr>
<td align="center"><strong>entrySet: EntrySet&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">延迟初始化条目集</td>
</tr>
<tr>
<td align="center"><strong>values: Values&lt;V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">延迟初始化值集合</td>
</tr>
<tr>
<td align="center"><strong>descendingMap: ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">延迟初始化递减键集</td>
</tr>
<tr>
<td align="center"><strong>EQ: int</strong></td>
<td align="center">1</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">—————-关系运算————–</td>
</tr>
<tr>
<td align="center"><strong>LT: int</strong></td>
<td align="center">2</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>GT: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>UNSAFE: sun.misc.Unsafe</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>headOffset: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SECONDARY: long</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>initialize(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">初始化或重置状态。构造函数、克隆、清除、readObject所需。和ConcurrentSkipListSet.clone。（请注意，比较器必须单独初始化。）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>casHead(HeadIndex&lt;K,V&gt; cmp, HeadIndex&lt;K,V&gt; val): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">比较数据集头节点</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>cpr(Comparator c, Object x, Object y): int</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果为空，则使用比较器或自然排序进行比较。仅由已执行所需类型检查的方法调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findPredecessor(Object key, Comparator&lt;? super K&gt; cmp): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回键严格小于给定键的基级节点，如果没有这样的节点，则返回基级标头。还将索引与沿途发现的已删除节点解除链接。调用方依赖于清除已删除节点的索引的这种副作用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findNode(Object key): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回持有key的节点，如果没有，则返回null，清除沿途看到的任何已删除节点。在基础级别重复遍历，查找从findPredecessor返回的前置项开始的键，并在遇到时处理基础级别的删除。一些调用方依赖于清除已删除节点的这种副作用。在以节点n为中心的遍历步骤中，如果：（1）读取n的下一个字段后，n不再被假定为前置节点b的当前后继节点，这意味着我们没有一致的3节点快照，因此无法取消遇到的任何后续已删除节点的链接。（2） n的值字段为空，表示n被删除，在这种情况下，我们在重试之前帮助进行结构删除。即使在某些情况下，这种取消链接不需要重新启动，这里也没有对它们进行分类，因为这样做通常不会超过重新启动的成本。（3） n是一个标记，或者n的前置节点的值字段为空，表示（除其他可能性外）FindPrecessor返回了一个已删除的节点。我们无法取消节点的链接，因为我们不知道它的前置节点，所以请依靠对FindPrecessor的另一个调用来注意并返回一些较早的前置节点。此检查仅在循环开始时严格需要（而b.value检查根本不严格需要），但在每次迭代中都会进行，以帮助避免调用方与其他线程发生争用，因为调用方无法更改链接，因此无论如何都会重试。doPut、doRemove和findNear中的遍历循环都包含相同的三种检查。专用版本出现在findFirst和findLast及其变体中。他们不能很容易地共享代码，因为每个人都使用以局部变量保存的字段的读取，这些字段按执行顺序出现。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doGet(Object key): V</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取键的值。与findNode几乎相同，但返回找到的值（以避免在重新读取期间重试）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doPut(K key, V value, boolean onlyIfAbsent): V</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">主要插入方法。如果不存在，则添加元素；如果存在且onlyFabSent为false，则替换值。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemove(Object key, Object value): V</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">主删除方法。定位节点，空值，附加删除标记，取消前一个节点的链接，删除关联的索引节点，并可能降低头索引级别。只需调用findPredecessor即可清除索引节点。它将索引与沿键路径找到的已删除节点解除链接，键路径将包括该节点的索引。这是无条件的。我们无法事先检查是否存在索引节点，因为可能在初始搜索该节点时，尚未插入该节点的部分或所有索引，并且我们希望确保没有垃圾保留，因此必须调用以确保。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tryReduceLevel(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果没有节点，可能会降低头部高度。这种方法可能（很少）出错，在这种情况下，级别可能会消失，即使它们即将包含索引节点。这会影响性能，而不是正确性。为了最大限度地减少错误并减少滞后，仅当最上面的三个级别看起来为空时，级别才会减少一。此外，如果在CAS后删除的级别看起来不为空，我们会尝试在任何人注意到我们的错误之前快速将其更改回原来的级别！（这个技巧非常有效，因为这种方法实际上永远不会出错，除非当前线程在第一个CAS之前立即停止，在这种情况下，它不太可能在之后立即再次停止，所以它会恢复。）我们忍受了这一切，而不是仅仅让级别增长，因为否则，即使是一张经历了大量插入和移除的小地图也会有很多级别，这会比偶尔不必要的减少更慢访问速度。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findFirst(): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">findNode的特殊变体，用于获取第一个有效节点。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemoveFirstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">删除第一个条目；返回其快照。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clearIndexToFirst(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">清除与已删除的第一个条目关联的索引节点。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>doRemoveLastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">删除最后一个条目；返回其快照。doRemove的特殊变体。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findLast(): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">查找的专用版本，以获取最后一个有效节点。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findPredecessorOfLast(): Node&lt;K,V&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">findPredecessor的特殊变体，用于获取最后一个有效节点的前置节点。删除最后一个条目时需要。返回时，返回节点的所有后续节点都可能已被删除，在这种情况下，可以重试此方法。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>findNear(K key, int rel, Comparator&lt;? super K&gt; cmp): Node&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">天花板、地板、较低和较高方法的实用程序。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNear(K key, int rel): AbstractMap.SimpleImmutableEntry&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回findNear结果的SimpleImutableEntry。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap()</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">构建一个新的空映射，根据键的“可比自然顺序”进行排序。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">构造一个新的空映射，根据指定的比较器进行排序。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">构造一个新映射，其中包含与给定映射相同的映射，并根据键的“可比较自然顺序”排序。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">构造一个新映射，该映射包含与指定的排序映射相同的映射并使用相同的顺序。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>clone(): ConcurrentSkipListMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此“ConcurrentSkipListMap”实例的浅层副本。（不会克隆键和值本身。）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>buildFromSorted(SortedMap&lt;K, ? extends V&gt; map): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">简化了批量插入以从给定排序映射的元素初始化。仅从构造函数或克隆方法调用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>writeObject(java.io.ObjectOutputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将此映射保存到流（即，将其序列化）。</td>
<td align="left">java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>readObject(final java.io.ObjectInputStream s): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从流中重构此映射（即，将其反序列化）。</td>
<td align="left">ClassNotFoundException<br/>java.io.IOException</td>
</tr>
<tr>
<td align="center"><strong>containsKey(Object key): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此映射包含指定键的映射，则返回“true”。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>get(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回指定键映射到的值，如果此映射不包含该键的映射，则返回“null”<p> 更正式地说，如果该映射包含从键“k”到值“v”的映射，使得“键”根据映射的顺序比较等于“k”，则该方法返回“v”；否则返回“null”。（最多可以有一个这样的映射。）</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>getOrDefault(Object key, V defaultValue): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回指定键映射到的值，如果此映射不包含该键的映射，则返回给定的默认值。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>put(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则替换旧值。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>remove(Object key): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从该映射中删除指定键的映射（如果存在）。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>containsValue(Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此映射将一个或多个键映射到指定值，则返回“true”。此操作要求贴图大小具有时间线性。此外，在执行此方法期间，映射可能会更改，在这种情况下，返回的结果可能不准确。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>size(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中的键值映射数。如果此映射包含大于“整数”。对于“MAX_VALUE”元素，它返回“Integer.MAX_VALUE”<p> 请注意，与大多数集合不同，此方法不是</em>恒定时间操作。由于这些映射的异步性质，确定当前元素数需要遍历所有元素以对其进行计数。此外，在执行此方法期间，大小可能会更改，在这种情况下，返回的结果将不准确。因此，这种方法在并发应用程序中通常不是很有用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isEmpty(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此映射不包含键值映射，则返回“true”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clear(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">从该映射中删除所有映射。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定的键尚未与值关联，则尝试使用给定的映射函数计算其值，并将其输入此映射，除非“null”。函数＜em＞不＜&#x2F;em＞保证仅在值不存在时原子应用一次。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定键的值存在，则尝试计算给定键及其当前映射值的新映射。函数＜em＞不能保证原子应用一次。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">尝试计算指定键及其当前映射值的映射（如果没有当前映射，则为“null”）。函数＜em＞不能保证原子应用一次。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果指定的键尚未与值关联，则将其与给定值关联。否则，用给定重映射函数的结果替换该值，或者如果为“null”，则删除该值。函数＜em＞不能保证原子应用一次。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>keySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的键的“NavigableSet”视图<p> 集合的迭代器按升序返回键。集合的拆分器还报告“拆分器并发”、“拆分器非空”、“拆分器排序”和“拆分器排序”，相遇顺序为键升序。如果映射的比较器（请参见“#comparator（）”）为“null”，则拆分器的比较仪（请参见“java.util.spliterator#GetComparators（）”）是“null”。否则，拆分器的比较器与映射图的比较仪相同，或施加相同的总排序<p> 集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。该集合支持元素移除，即通过“迭代器”从映射中移除相应的映射。删除“”集。移除、移除全部、保留和清除操作。它不支持“添加”或“添加所有”操作<p> 视图的迭代器和拆分器是弱一致的<p> 该方法等同于方法“navigableKeySet”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>navigableKeySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>values(): Collection<V></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的值的“集合”视图<p> 集合的迭代器按相应键的升序返回值。集合的拆分器还报告“拆分器并发”、“拆分器非空”和“拆分器有序”，相遇顺序为相应键的升序<p> 集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。集合支持元素移除，通过“迭代器”从映射中移除相应的映射。删除“”集合。删除、删除、保留和清除操作。它不支持“添加”或“添加所有”操作<p> 视图的迭代器和拆分器是弱一致的。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySet(): Set&lt;Map.Entry&lt;K,V&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回此映射中包含的映射的“集合”视图<p> 集合的迭代器以升序键顺序返回条目。集合的拆分器还报告“拆分器并发”、“拆分器非空”、“拆分器排序”和“拆分器排序”，相遇顺序为键升序<p> 集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。该集合支持元素移除，即通过“迭代器”从映射中移除相应的映射。删除“”集。删除、删除、保留和清除操作。它不支持“添加”或“添加所有”操作<p> 视图的迭代器和拆分器是弱一致的<p> 地图。“迭代器”或“拆分器”遍历的Entry元素不支持“setValue”操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>descendingMap(): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>descendingKeySet(): NavigableSet<K></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(Object o): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">将指定对象与此映射进行相等性比较。如果给定对象也是映射，并且两个映射表示相同的映射，则返回“true”。更正式地说，如果“m1.entrySet（）.equals（m2.entrySet（））”，则两个映射“m1”和“m2”表示相同的映射。如果在执行此方法期间同时修改任一映射，则此操作可能会返回误导性结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>putIfAbsent(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>remove(Object key, Object value): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V oldValue, V newValue): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>replace(K key, V value): V</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“继承文档”</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>comparator(): K&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">——SortedMap API方法——</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>firstKey(): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>lastKey(): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>headMap(K toKey, boolean inclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>tailMap(K fromKey, boolean inclusive): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>subMap(K fromKey, K toKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>headMap(K toKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>tailMap(K fromKey): ConcurrentNavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>lowerEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与严格小于给定键的最大键关联的键值映射，如果没有这样的键，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>lowerKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>floorEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与小于或等于给定键的最大键相关联的键值映射，如果没有此类键，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>floorKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>ceilingEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与大于或等于给定键的最小键相关联的键值映射，如果没有此类项，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>ceilingKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>higherEntry(K key): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与严格大于给定键的最小键关联的键值映射，如果没有这样的键，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>higherKey(K key): K</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">NullPointerException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>firstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与此映射中最小键关联的键值映射，如果映射为空，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回与此映射中最大键关联的键值映射，如果映射为空，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollFirstEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">移除并返回与此映射中最小键关联的键值映射，如果映射为空，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pollLastEntry(): Map.Entry&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">移除并返回与此映射中最大键关联的键值映射，如果映射为空，则返回“null”。返回的条目不支持</em>条目。setValue方法。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>keyIterator(): Iterator<K></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">迭代器类的基：</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>valueIterator(): Iterator<V></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entryIterator(): Iterator&lt;Map.Entry&lt;K,V&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toList(Collection&lt;E&gt; c): List<E></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">视图类是静态的，委托给ConcurrentNavigableMap以允许子映射使用，这超过了迭代器方法需要类型测试的丑陋。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEach(BiConsumer&lt;? super K, ? super V&gt; action): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“ConcurrentSkipListMap”子映射操作返回的子映射表示其基础映射的映射子范围。该类的实例支持其基础映射的所有方法，不同之处在于忽略其范围之外的映射，尝试添加其范围以外的映射会导致“IllegalArgumentException”。此类的实例仅使用其基础映射的“subMap”、“headMap”和“tailMap”方法构造。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>keySpliterator(): KeySpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">为拆分器提供通用结构的基类。（虽然不是所有常见的功能；与视图类一样，key、value和entry子类的细节变化令人烦恼，不值得为内部类抽象出来。）基本拆分策略是从顶层逐行递归下降，在遇到拆分或行结束时下降到下一行。分割数的控制依赖于一些统计估计：当跨越或向下推进时，跳过列表的预期剩余元素数减少约25%。为了使这个观察有用，我们需要知道初始大小，而我们不知道。但我们可以只使用整数。MAX_ VALUE，这样我们在分裂时不会过早地归零。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>valueSpliterator(): ValueSpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>entrySpliterator(): EntrySpliterator&lt;K,V&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="ConcurrentSkipListMap-Node"><a href="#ConcurrentSkipListMap-Node" class="headerlink" title="ConcurrentSkipListMap$Node"></a><a href="./ConcurrentSkipListMap$Node.html">ConcurrentSkipListMap$Node</a></h3><h3 id="ConcurrentSkipListMap-Index"><a href="#ConcurrentSkipListMap-Index" class="headerlink" title="ConcurrentSkipListMap$Index"></a><a href="./ConcurrentSkipListMap$Index.html">ConcurrentSkipListMap$Index</a></h3><h3 id="ConcurrentSkipListMap-HeadIndex"><a href="#ConcurrentSkipListMap-HeadIndex" class="headerlink" title="ConcurrentSkipListMap$HeadIndex"></a><a href="./ConcurrentSkipListMap$HeadIndex.html">ConcurrentSkipListMap$HeadIndex</a></h3><h3 id="ConcurrentSkipListMap-Iter"><a href="#ConcurrentSkipListMap-Iter" class="headerlink" title="ConcurrentSkipListMap$Iter"></a><a href="./ConcurrentSkipListMap$Iter.html">ConcurrentSkipListMap$Iter</a></h3><h3 id="ConcurrentSkipListMap-ValueIterator"><a href="#ConcurrentSkipListMap-ValueIterator" class="headerlink" title="ConcurrentSkipListMap$ValueIterator"></a><a href="./ConcurrentSkipListMap$ValueIterator.html">ConcurrentSkipListMap$ValueIterator</a></h3><h3 id="ConcurrentSkipListMap-KeyIterator"><a href="#ConcurrentSkipListMap-KeyIterator" class="headerlink" title="ConcurrentSkipListMap$KeyIterator"></a><a href="./ConcurrentSkipListMap$KeyIterator.html">ConcurrentSkipListMap$KeyIterator</a></h3><h3 id="ConcurrentSkipListMap-EntryIterator"><a href="#ConcurrentSkipListMap-EntryIterator" class="headerlink" title="ConcurrentSkipListMap$EntryIterator"></a><a href="./ConcurrentSkipListMap$EntryIterator.html">ConcurrentSkipListMap$EntryIterator</a></h3><h3 id="ConcurrentSkipListMap-KeySet"><a href="#ConcurrentSkipListMap-KeySet" class="headerlink" title="ConcurrentSkipListMap$KeySet"></a><a href="./ConcurrentSkipListMap$KeySet.html">ConcurrentSkipListMap$KeySet</a></h3><h3 id="ConcurrentSkipListMap-Values"><a href="#ConcurrentSkipListMap-Values" class="headerlink" title="ConcurrentSkipListMap$Values"></a><a href="./ConcurrentSkipListMap$Values.html">ConcurrentSkipListMap$Values</a></h3><h3 id="ConcurrentSkipListMap-EntrySet"><a href="#ConcurrentSkipListMap-EntrySet" class="headerlink" title="ConcurrentSkipListMap$EntrySet"></a><a href="./ConcurrentSkipListMap$EntrySet.html">ConcurrentSkipListMap$EntrySet</a></h3><h3 id="ConcurrentSkipListMap-SubMap"><a href="#ConcurrentSkipListMap-SubMap" class="headerlink" title="ConcurrentSkipListMap$SubMap"></a><a href="./ConcurrentSkipListMap$SubMap.html">ConcurrentSkipListMap$SubMap</a></h3><h3 id="ConcurrentSkipListMap-CSLMSpliterator"><a href="#ConcurrentSkipListMap-CSLMSpliterator" class="headerlink" title="ConcurrentSkipListMap$CSLMSpliterator"></a><a href="./ConcurrentSkipListMap$CSLMSpliterator.html">ConcurrentSkipListMap$CSLMSpliterator</a></h3><h3 id="ConcurrentSkipListMap-KeySpliterator"><a href="#ConcurrentSkipListMap-KeySpliterator" class="headerlink" title="ConcurrentSkipListMap$KeySpliterator"></a><a href="./ConcurrentSkipListMap$KeySpliterator.html">ConcurrentSkipListMap$KeySpliterator</a></h3><h3 id="ConcurrentSkipListMap-ValueSpliterator"><a href="#ConcurrentSkipListMap-ValueSpliterator" class="headerlink" title="ConcurrentSkipListMap$ValueSpliterator"></a><a href="./ConcurrentSkipListMap$ValueSpliterator.html">ConcurrentSkipListMap$ValueSpliterator</a></h3><h3 id="ConcurrentSkipListMap-EntrySpliterator"><a href="#ConcurrentSkipListMap-EntrySpliterator" class="headerlink" title="ConcurrentSkipListMap$EntrySpliterator"></a><a href="./ConcurrentSkipListMap$EntrySpliterator.html">ConcurrentSkipListMap$EntrySpliterator</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
