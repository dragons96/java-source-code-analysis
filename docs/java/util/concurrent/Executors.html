<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/concurrent/Executors.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.concurrent.Executors</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>newFixedThreadPool(int nThreads): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池重用在共享无界队列中运行的固定数量的线程。在任何时候，最多“n线程”将是活动的处理任务。如果在所有线程都处于活动状态时提交其他任务，则它们将在队列中等待，直到有线程可用。如果任何线程在关机前的执行过程中由于故障而终止，那么如果需要执行后续任务，将使用一个新线程来代替它。池中的线程将一直存在，直到它显式为“ExecutorService#shutdown”。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>newWorkStealingPool(int parallelism): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池维护足够的线程以支持给定的并行级别，并可以使用多个队列来减少争用。并行度级别对应于积极参与或可参与任务处理的最大线程数。线程的实际数量可以动态地增长和收缩。工作窃取池不保证提交任务的执行顺序。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>newWorkStealingPool(): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用所有“Runtime#AvailableProcessor可用处理器”作为其目标并行度级别，创建窃取工作线程池。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newFixedThreadPool(int nThreads, ThreadFactory threadFactory): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池重用在共享无界队列中运行的固定数量的线程，在需要时使用提供的ThreadFactory创建新线程。在任何时候，最多“n线程”将是活动的处理任务。如果在所有线程都处于活动状态时提交其他任务，则它们将在队列中等待，直到有线程可用。如果任何线程在关机前的执行过程中由于故障而终止，那么如果需要执行后续任务，将使用一个新线程来代替它。池中的线程将一直存在，直到它显式为“ExecutorService#shutdown”。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>newSingleThreadExecutor(): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个执行器，该执行器使用在无界队列中运行的单个工作线程。（但请注意，如果此单线程在关机前的执行过程中由于故障而终止，则在需要执行后续任务时，将替换一个新线程。）任务保证按顺序执行，并且在任何给定时间都不会有多个任务处于活动状态。与其他等效的“newFixedThreadPool（1）”不同，返回的执行器保证不可重新配置以使用其他线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newSingleThreadExecutor(ThreadFactory threadFactory): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个执行器，该执行器使用在无界队列中运行的单个工作线程，并在需要时使用提供的ThreadFactory创建新线程。与其他等效的“newFixedThreadPool（1，threadFactory）”不同，返回的执行器保证不可重新配置以使用其他线程。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>newCachedThreadPool(): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池根据需要创建新线程，但在以前构建的线程可用时将重用这些线程。这些池通常会提高执行许多短期异步任务的程序的性能。调用“execute”将重用以前构造的线程（如果可用）。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。六十秒未使用的线程将被终止并从缓存中删除。因此，空闲时间足够长的池不会消耗任何资源。请注意，可以使用“ThreadPoolExecutor”构造函数创建具有类似属性但细节不同（例如，超时参数）的池。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newCachedThreadPool(ThreadFactory threadFactory): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构建的线程，并在需要时使用提供的ThreadFactory创建新线程。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>newSingleThreadScheduledExecutor(): ScheduledExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个单线程执行器，该执行器可以安排命令在给定延迟后运行或定期执行。（但请注意，如果此单线程在关机前的执行过程中由于故障而终止，则在需要执行后续任务时，将替换一个新线程。）任务保证按顺序执行，并且在任何给定时间都不会有多个任务处于活动状态。与其他等价的“newScheduledThreadPool（1）”不同，返回的执行器保证不可重新配置以使用其他线程。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newSingleThreadScheduledExecutor(ThreadFactory threadFactory): ScheduledExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个单线程执行器，该执行器可以安排命令在给定延迟后运行或定期执行。（但请注意，如果此单线程在关机前的执行过程中由于故障而终止，则在需要执行后续任务时，将替换一个新线程。）任务保证按顺序执行，并且在任何给定时间都不会有多个任务处于活动状态。与其他等价的“newScheduledThreadPool（1，threadFactory）”不同，返回的执行器保证不可重新配置以使用其他线程。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>newScheduledThreadPool(int corePoolSize): ScheduledExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池可以安排命令在给定延迟后运行或定期执行。</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory): ScheduledExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">创建一个线程池，该线程池可以安排命令在给定延迟后运行或定期执行。</td>
<td align="left">IllegalArgumentException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>unconfigurableExecutorService(ExecutorService executor): ExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个对象，该对象将所有定义的“ExecutorService”方法委托给给定的执行器，但不委托任何其他可能使用强制转换访问的方法。这提供了一种安全地“冻结”配置并禁止对给定具体实现进行调优的方法。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>unconfigurableScheduledExecutorService(ScheduledExecutorService executor): ScheduledExecutorService</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个对象，该对象将所有定义的“ScheduledExecutorService”方法委托给给定的执行器，但不委托任何其他可能使用强制转换访问的方法。这提供了一种安全地“冻结”配置并禁止对给定具体实现进行调优的方法。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>defaultThreadFactory(): ThreadFactory</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回用于创建新线程的默认线程工厂。此工厂在同一“线程组”中创建执行器使用的所有新线程。如果存在“java.lang.SecurityManager”，它将使用“System#getSecurityManager”组，否则将使用调用此“defaultThreadFactory”方法的线程组。每个新线程被创建为非守护进程线程，优先级设置为“线程”中的较小者。NORM_PRIORITY’和线程组中允许的最大优先级。新线程的名称可通过<em>池-N-Thread-M</em>的“Thread#getName”访问，其中<em>N</em>，是此工厂的序列号，<em>M</em>是此工厂创建的线程的序列号。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>privilegedThreadFactory(): ThreadFactory</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回用于创建与当前线程具有相同权限的新线程的线程工厂。此工厂使用与“Executors#defaultThreadFactory”相同的设置创建线程，此外，还将新线程的AccessControlContext和contextClassLoader设置为与调用此“privilegedThreadFactory”方法的线程相同。可以在“AccessController#doPrivileged AccessController”中创建新的“privilegedThreadFactory”。doPrivileged’操作设置当前线程的访问控制上下文，以创建在该操作中保留选定权限设置的线程<p> 请注意，虽然在此类线程中运行的任务将具有与当前线程相同的访问控制和类加载器设置，但它们不需要具有相同的“java.lang.ThreadLocal”或“java.lang.InheritableThreadLocal”值。如有必要，在“ThreadPoolExecutor”子类中运行任何任务之前，可以使用“ThreadpoolExecuter#beforeExecute（thread，Runnable）”，设置或重置线程局部变量的特定值。此外，如果需要初始化工作线程以使其具有与其他指定线程相同的InheritableThreadLocal设置，则可以创建自定义ThreadFactory，该线程在其中等待并请求创建将继承其值的其他线程。</td>
<td align="left">AccessControlException</td>
</tr>
<tr>
<td align="center"><strong>callable(Runnable task, T result): Callable<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时运行给定任务并返回给定结果。这在将需要“可调用”的方法应用于其他无结果的操作时非常有用。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>callable(Runnable task): Callable<Object></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时运行给定任务并返回“null”。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>callable(final PrivilegedAction&lt;?&gt; action): Callable<Object></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时运行给定的特权操作并返回其结果。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>callable(final PrivilegedExceptionAction&lt;?&gt; action): Callable<Object></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时运行给定的特权异常操作并返回其结果。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>privilegedCallable(Callable&lt;T&gt; callable): Callable<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时将在当前访问控制上下文下执行给定的“可调用”。此方法通常应在“AccessController#doPrivileged AccessController”中调用。doPrivileged’操作创建可调用项，如果可能，可调用项将在该操作中保持的选定权限设置下执行；或者，如果不可能，抛出关联的“AccessControlException”。</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable): Callable<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“可调用”对象，该对象在调用时将在当前访问控制上下文下执行给定的“可调用”，当前上下文类加载器作为上下文类加加载器。此方法通常应在“AccessController#doPrivileged AccessController”中调用。doPrivileged’操作创建可调用项，如果可能，可调用项将在该操作中保持的选定权限设置下执行；或者，如果不可能，抛出关联的“AccessControlException”。</td>
<td align="left">NullPointerException<br/>AccessControlException</td>
</tr>
<tr>
<td align="center"><strong>Executors()</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">无法实例化。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Executors-RunnableAdapter"><a href="#Executors-RunnableAdapter" class="headerlink" title="Executors$RunnableAdapter"></a><a href="./Executors$RunnableAdapter.html">Executors$RunnableAdapter</a></h3><h3 id="Executors-PrivilegedCallable"><a href="#Executors-PrivilegedCallable" class="headerlink" title="Executors$PrivilegedCallable"></a><a href="./Executors$PrivilegedCallable.html">Executors$PrivilegedCallable</a></h3><h3 id="Executors-PrivilegedCallableUsingCurrentClassLoader"><a href="#Executors-PrivilegedCallableUsingCurrentClassLoader" class="headerlink" title="Executors$PrivilegedCallableUsingCurrentClassLoader"></a><a href="./Executors$PrivilegedCallableUsingCurrentClassLoader.html">Executors$PrivilegedCallableUsingCurrentClassLoader</a></h3><h3 id="Executors-DefaultThreadFactory"><a href="#Executors-DefaultThreadFactory" class="headerlink" title="Executors$DefaultThreadFactory"></a><a href="./Executors$DefaultThreadFactory.html">Executors$DefaultThreadFactory</a></h3><h3 id="Executors-PrivilegedThreadFactory"><a href="#Executors-PrivilegedThreadFactory" class="headerlink" title="Executors$PrivilegedThreadFactory"></a><a href="./Executors$PrivilegedThreadFactory.html">Executors$PrivilegedThreadFactory</a></h3><h3 id="Executors-DelegatedExecutorService"><a href="#Executors-DelegatedExecutorService" class="headerlink" title="Executors$DelegatedExecutorService"></a><a href="./Executors$DelegatedExecutorService.html">Executors$DelegatedExecutorService</a></h3><h3 id="Executors-FinalizableDelegatedExecutorService"><a href="#Executors-FinalizableDelegatedExecutorService" class="headerlink" title="Executors$FinalizableDelegatedExecutorService"></a><a href="./Executors$FinalizableDelegatedExecutorService.html">Executors$FinalizableDelegatedExecutorService</a></h3><h3 id="Executors-DelegatedScheduledExecutorService"><a href="#Executors-DelegatedScheduledExecutorService" class="headerlink" title="Executors$DelegatedScheduledExecutorService"></a><a href="./Executors$DelegatedScheduledExecutorService.html">Executors$DelegatedScheduledExecutorService</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
