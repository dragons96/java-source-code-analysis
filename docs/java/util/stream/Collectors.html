<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/stream/Collectors.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.stream.Collectors</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CH_NOID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.emptySet()</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>throwingMerger(): BinaryOperator<T></strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a merge function, suitable for use in ‘Map#merge(Object, Object, BiFunction) Map.merge()’ or ‘#toMap(Function, Function, BinaryOperator) toMap()’, which always throws ‘IllegalStateException’.  This can be used to enforce the assumption that the elements being collected are distinct.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>castingIdentity(): R&gt;</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toCollection(Supplier&lt;C&gt; collectionFactory): C&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates the input elements into a new ‘Collection’, in encounter order.  The ‘Collection’ is created by the provided factory.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toList(): List<T>&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates the input elements into a new ‘List’. There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘List’ returned; if more control over the returned ‘List’ is required, use ‘#toCollection(Supplier)’.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toSet(): Set<T>&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates the input elements into a new ‘Set’. There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘Set’ returned; if more control over the returned ‘Set’ is required, use ‘#toCollection(Supplier)’.  <p>This is an ‘Collector.Characteristics#UNORDERED unordered’ Collector.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that concatenates the input elements into a ‘String’, in encounter order.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(CharSequence delimiter): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that concatenates the input elements, separated by the specified delimiter, in encounter order.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>mapMerger(BinaryOperator&lt;V&gt; mergeFunction)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">‘BinaryOperator<Map>‘ that merges the contents of its right argument into its left argument, using the provided merge function to handle duplicate keys.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>mapping(Function&lt;? super T, ? extends U&gt; mapper,Collector&lt;? super U, A, R&gt; downstream): R&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Adapts a ‘Collector’ accepting elements of type ‘U’ to one accepting elements of type ‘T’ by applying a mapping function to each input element before accumulation.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher): Collector&lt;T,A,RR&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Adapts a ‘Collector’ to perform an additional finishing transformation.  For example, one could adapt the ‘#toList()’ collector to always produce an immutable list with: <pre>'List<String> people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>counting()</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ accepting elements of type ‘T’ that counts the number of input elements.  If no elements are present, the result is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>minBy(Comparator&lt;? super T&gt; comparator)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the minimal element according to a given ‘Comparator’, described as an ‘Optional<T>‘.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>maxBy(Comparator&lt;? super T&gt; comparator)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the maximal element according to a given ‘Comparator’, described as an ‘Optional<T>‘.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingInt(ToIntFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the sum of a integer-valued function applied to the input elements.  If no elements are present, the result is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingLong(ToLongFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the sum of a long-valued function applied to the input elements.  If no elements are present, the result is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the sum of a double-valued function applied to the input elements.  If no elements are present, the result is 0.  <p>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results.  If any recorded value is a ‘NaN’ or the sum is at any point a ‘NaN’ then the sum will be ‘NaN’.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sumWithCompensation(double[] intermediateSum, double value): double[]</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Incorporate a new double value using Kahan summation compensation summation.  High-order bits of the sum are in intermediateSum[0], low-order bits of the sum are in intermediateSum[1], any additional elements are application-specific.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>computeFinalSum(double[] summands): double</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">If the compensated sum is spuriously NaN from accumulating one or more same-signed infinite values, return the correctly-signed infinity stored in the simple sum.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingInt(ToIntFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the arithmetic mean of an integer-valued function applied to the input elements.  If no elements are present, the result is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingLong(ToLongFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the arithmetic mean of a long-valued function applied to the input elements.  If no elements are present, the result is 0.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that produces the arithmetic mean of a double-valued function applied to the input elements.  If no elements are present, the result is 0.  <p>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results.  If any recorded value is a ‘NaN’ or the sum is at any point a ‘NaN’ then the average will be ‘NaN’.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(T identity, BinaryOperator&lt;T&gt; op)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which performs a reduction of its input elements under a specified ‘BinaryOperator’ using the provided identity.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>boxSupplier(T identity): Supplier&lt;T[]&gt;</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(BinaryOperator&lt;T&gt; op)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which performs a reduction of its input elements under a specified ‘BinaryOperator’.  The result is described as an ‘Optional<T>‘.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(U identity,Function&lt;? super T, ? extends U&gt; mapper,BinaryOperator&lt;U&gt; op): U&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which performs a reduction of its input elements under a specified mapping function and ‘BinaryOperator’. This is a generalization of ‘#reducing(Object, BinaryOperator)’ which allows a transformation of the elements before reduction.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ implementing a “group by” operation on input elements of type ‘T’, grouping elements according to a classification function, and returning the results in a ‘Map’.  <p>The classification function maps elements to some key type ‘K’. The collector produces a ‘Map&lt;K, List<T>&gt;’ whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are ‘List’s containing the input elements which map to the associated key under the classification function.  <p>There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘Map’ or ‘List’ objects returned.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ implementing a cascaded “group by” operation on input elements of type ‘T’, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream ‘Collector’.  <p>The classification function maps elements to some key type ‘K’. The downstream collector operates on elements of type ‘T’ and produces a result of type ‘D’. The resulting collector produces a ‘Map&lt;K, D&gt;’.  <p>There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘Map’ returned.  <p>For example, to compute the set of last names of people in each city: <pre>'Map<City, Set<String>> namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet())));'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream): M&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ implementing a cascaded “group by” operation on input elements of type ‘T’, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream ‘Collector’.  The ‘Map’ produced by the Collector is created with the supplied factory function.  <p>The classification function maps elements to some key type ‘K’. The downstream collector operates on elements of type ‘T’ and produces a result of type ‘D’. The resulting collector produces a ‘Map&lt;K, D&gt;’.  <p>For example, to compute the set of last names of people in each city, where the city names are sorted: <pre>'Map<City, Set<String>> namesByCity = people.stream().collect(groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet())));'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ implementing a “group by” operation on input elements of type ‘T’, grouping elements according to a classification function.  <p>This is a ‘Collector.Characteristics#CONCURRENT concurrent’ and ‘Collector.Characteristics#UNORDERED unordered’ Collector.  <p>The classification function maps elements to some key type ‘K’. The collector produces a ‘ConcurrentMap&lt;K, List<T>&gt;’ whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are ‘List’s containing the input elements which map to the associated key under the classification function.  <p>There are no guarantees on the type, mutability, or serializability of the ‘Map’ or ‘List’ objects returned, or of the thread-safety of the ‘List’ objects returned.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ implementing a cascaded “group by” operation on input elements of type ‘T’, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream ‘Collector’.  <p>This is a ‘Collector.Characteristics#CONCURRENT concurrent’ and ‘Collector.Characteristics#UNORDERED unordered’ Collector.  <p>The classification function maps elements to some key type ‘K’. The downstream collector operates on elements of type ‘T’ and produces a result of type ‘D’. The resulting collector produces a ‘Map&lt;K, D&gt;’.  <p>For example, to compute the set of last names of people in each city, where the city names are sorted: <pre>'ConcurrentMap<City, Set<String>> namesByCity = people.stream().collect(groupingByConcurrent(Person::getCity, mapping(Person::getLastName, toSet())));'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream): M&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ implementing a cascaded “group by” operation on input elements of type ‘T’, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream ‘Collector’.  The ‘ConcurrentMap’ produced by the Collector is created with the supplied factory function.  <p>This is a ‘Collector.Characteristics#CONCURRENT concurrent’ and ‘Collector.Characteristics#UNORDERED unordered’ Collector.  <p>The classification function maps elements to some key type ‘K’. The downstream collector operates on elements of type ‘T’ and produces a result of type ‘D’. The resulting collector produces a ‘Map&lt;K, D&gt;’.  <p>For example, to compute the set of last names of people in each city, where the city names are sorted: <pre>'ConcurrentMap<City, Set<String>> namesByCity = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new, mapping(Person::getLastName, toSet())));'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>partitioningBy(Predicate&lt;? super T&gt; predicate): List<T>&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which partitions the input elements according to a ‘Predicate’, and organizes them into a ‘Map&lt;Boolean, List<T>&gt;’.  There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘Map’ returned.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>partitioningBy(Predicate&lt;? super T&gt; predicate,Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which partitions the input elements according to a ‘Predicate’, reduces the values in each partition according to another ‘Collector’, and organizes them into a ‘Map&lt;Boolean, D&gt;’ whose values are the result of the downstream reduction.  <p>There are no guarantees on the type, mutability, serializability, or thread-safety of the ‘Map’ returned.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper): Map&lt;K,U&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates elements into a ‘Map’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), an ‘IllegalStateException’ is thrown when the collection operation is performed.  If the mapped keys may have duplicates, use ‘#toMap(Function, Function, BinaryOperator)’ instead.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction): Map&lt;K,U&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates elements into a ‘Map’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction,Supplier&lt;M&gt; mapSupplier): M&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ that accumulates elements into a ‘Map’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.  The ‘Map’ is created by a provided supplier function.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper): ConcurrentMap&lt;K,U&gt;&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ that accumulates elements into a ‘ConcurrentMap’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), an ‘IllegalStateException’ is thrown when the collection operation is performed.  If the mapped keys may have duplicates, use ‘#toConcurrentMap(Function, Function, BinaryOperator)’ instead.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ that accumulates elements into a ‘ConcurrentMap’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction,Supplier&lt;M&gt; mapSupplier): M&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a concurrent ‘Collector’ that accumulates elements into a ‘ConcurrentMap’ whose keys and values are the result of applying the provided mapping functions to the input elements.  <p>If the mapped keys contains duplicates (according to ‘Object#equals(Object)’), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.  The ‘ConcurrentMap’ is created by a provided supplier function.  <p>This is a ‘Collector.Characteristics#CONCURRENT concurrent’ and ‘Collector.Characteristics#UNORDERED unordered’ Collector.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingInt(ToIntFunction&lt;? super T&gt; mapper): IntSummaryStatistics&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which applies an ‘int’-producing mapping function to each input element, and returns summary statistics for the resulting values.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingLong(ToLongFunction&lt;? super T&gt; mapper): LongSummaryStatistics&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which applies an ‘long’-producing mapping function to each input element, and returns summary statistics for the resulting values.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper): DoubleSummaryStatistics&gt;</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Collector’ which applies an ‘double’-producing mapping function to each input element, and returns summary statistics for the resulting values.</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Collectors-CollectorImpl"><a href="#Collectors-CollectorImpl" class="headerlink" title="Collectors$CollectorImpl"></a><a href="./Collectors$CollectorImpl.html">Collectors$CollectorImpl</a></h3><h3 id="Collectors-Partition"><a href="#Collectors-Partition" class="headerlink" title="Collectors$Partition"></a><a href="./Collectors$Partition.html">Collectors$Partition</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
