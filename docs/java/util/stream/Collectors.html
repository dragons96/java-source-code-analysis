<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/stream/Collectors.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.stream.Collectors</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CH_CONCURRENT_ID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.CONCURRENT, Collector.Characteristics.UNORDERED, Collector.Characteristics.IDENTITY_FINISH))</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CH_CONCURRENT_NOID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.CONCURRENT, Collector.Characteristics.UNORDERED))</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CH_ID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH))</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CH_UNORDERED_ID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED, Collector.Characteristics.IDENTITY_FINISH))</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>CH_NOID: Set&lt;Collector.Characteristics&gt;</strong></td>
<td align="center">Collections.emptySet()</td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Collectors()</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>throwingMerger(): BinaryOperator<T></strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个合并函数，适用于“Map#merge（Object，Object，BiFunction）”映射。merge（）’或“#toMap（函数、函数、二进制运算符）toMap（）”，它总是抛出“IllegalStateException”。这可以用来强制执行所收集的元素是不同的假设。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>castingIdentity(): R&gt;</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toCollection(Supplier&lt;C&gt; collectionFactory): C&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，按遇到顺序将输入元素累积到新的“集合”中。“集合”由提供的工厂创建。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toList(): List<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，将输入元素累积到新的“列表”中。对于返回的“列表”的类型、可变性、可序列化性或线程安全性没有任何保证；如果需要对返回的“列表”进行更多控制，请使用“#toCollection（Supplier）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toSet(): Set<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，将输入元素累加到新的“集合”中。对于返回的“Set”的类型、可变性、可序列化性或线程安全性没有任何保证；如果需要对返回的“集合”进行更多控制，请使用“#toCollection（Supplier）”<p> 这是一个“收藏家”。“无序”和“无序”收集器的特征。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器按遇到顺序将输入元素连接成一个“字符串”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(CharSequence delimiter): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器按相遇顺序连接由指定分隔符分隔的输入元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix): String&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器按相遇顺序连接输入元素（由指定的分隔符分隔），并带有指定的前缀和后缀。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>mapMerger(BinaryOperator&lt;V&gt; mergeFunction): BinaryOperator<M></strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">“BinaryOperator＜Map＞”，它使用提供的合并函数处理重复键，将右参数的内容合并到左参数中。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream): R&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">通过在累加之前对每个输入元素应用映射函数，将接受“U”类型元素的“收集器”适配为接受“T”类型元素之一。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher): Collector&lt;T,A,RR&gt;</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">调整“收集器”以执行额外的精加工转换。例如，可以调整“#toList（）”收集器，使其始终生成一个不可变列表，其中包含：＜pre＞list＜String＞people＝people.stream（）。collect（collectingAndThen（toList（），Collections:：unmodifiableList））；’</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>counting(): Long&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个接受类型为“T”的元素的“收集器”，该收集器计算输入元素的数量。如果不存在元素，则结果为0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>minBy(Comparator&lt;? super T&gt; comparator): Optional<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器根据给定的“比较器”生成最小元素，称为“可选<T>”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>maxBy(Comparator&lt;? super T&gt; comparator): Optional<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器根据给定的“比较器”生成最大元素，称为“可选<T>”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingInt(ToIntFunction&lt;? super T&gt; mapper): Integer&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的整数值函数的和。如果不存在元素，则结果为0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingLong(ToLongFunction&lt;? super T&gt; mapper): Long&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的长值函数的和。如果不存在元素，则结果为0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summingDouble(ToDoubleFunction&lt;? super T&gt; mapper): Double&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的双值函数的和。如果不存在任何元素，则结果为0。<p>返回的和可能因记录值的顺序而不同，这是由于累积舍入误差以及不同大小的值造成的。通过增加绝对量值排序的值往往会产生更准确的结果。如果任何记录值为“NaN”，或总和在任何点为“NaN”，则总和为“NaNN”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sumWithCompensation(double[] intermediateSum, double value): double[]</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用Kahan求和补偿求和合并新的双值。和的高位为中间值[0]，和的低位为中间值[1]，任何附加元素都是特定于应用的。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>computeFinalSum(double[] summands): double</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果补偿和由于累积一个或多个相同的带符号无穷大值而被误认为是NaN，则返回存储在简单和中的正确带符号的无穷大。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingInt(ToIntFunction&lt;? super T&gt; mapper): Double&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的整数值函数的算术平均值。如果不存在元素，则结果为0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingLong(ToLongFunction&lt;? super T&gt; mapper): Double&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的长值函数的算术平均值。如果不存在元素，则结果为0。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper): Double&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器生成应用于输入元素的双值函数的算术平均值。如果不存在任何元素，则结果为0。<p>返回的平均值可能因记录值的顺序而不同，这是由于累积舍入误差以及不同大小的值。通过增加绝对量值排序的值往往会产生更准确的结果。如果任何记录值为“NaN”，或任何点的总和为“NaN”，则平均值为“NaN”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(T identity, BinaryOperator&lt;T&gt; op): T&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器使用提供的标识在指定的“BinaryOperator”下执行输入元素的缩减。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>boxSupplier(T identity): Supplier&lt;T[]&gt;</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(BinaryOperator&lt;T&gt; op): Optional<T>&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器在指定的“BinaryOperator”下执行输入元素的缩减。结果被描述为“可选<T>”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op): U&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，它在指定的映射函数和“BinaryOperator”下执行输入元素的缩减。这是“#reduced（Object，BinaryOperator）”的泛化，它允许在归约之前对元素进行变换。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier): List<T>&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，对“T”类型的输入元素执行“分组依据”操作，根据分类函数对元素进行分组，并在“映射”中返回结果<p> 分类函数将元素映射到某个键类型“K”。收集器生成一个“Map&lt;K，List<T>&gt;”，其键是将分类函数应用于输入元素后产生的值，其对应值是包含映射到分类函数下关联键的输入元素的“List”<p> 对于返回的“Map”或“List”对象的类型、可变性、可序列化性或线程安全性没有任何保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，对“T”类型的输入元素执行级联“分组操作”，根据分类函数对元素进行分组，然后使用指定的下游“收集器”对与给定键关联的值执行缩减操作<p> 分类函数将元素映射到某个键类型“K”。下游收集器对类型为“T”的元素进行操作，并生成类型为“D”的结果。生成的收集器生成一个“Map&lt;K，D&gt;”<p> 对于返回的“映射”的类型、可变性、可序列化性或线程安全性没有任何保证<p> 例如，要计算每个城市中人们的姓氏集：＜pre＞‘Map＜city，设置＜String＞＞namebycity&#x3D;people.stream（）。collect（groupingBy（Person:：getCity，映射（Person：：getLastName，toSet（））；’</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream): M&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，对“T”类型的输入元素执行级联“分组操作”，根据分类函数对元素进行分组，然后使用指定的下游“收集器”对与给定键关联的值执行缩减操作。收集器生成的“映射”是使用提供的工厂函数创建的<p> 分类函数将元素映射到某个键类型“K”。下游收集器对类型为“T”的元素进行操作，并生成类型为“D”的结果。生成的收集器生成一个“Map&lt;K，D&gt;”<p> 例如，要计算每个城市中人们的姓氏集，其中城市名称被排序：＜pre＞‘Map＜city，set＜String＞namebycity＝people.stream（）。collect（groupingBy（Person:：getCity，TreeMap:：new，映射（Person：：getLastName，toSet（））；’</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier): List<T>&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，该收集器对“T”类型的输入元素执行“分组依据”操作，根据分类函数对元素进行分组<p> 这是一个“收藏家”。特征#CONCURRENT“和”收集器。“无序”和“无序”收集器的特征<p> 分类函数将元素映射到某个键类型“K”。收集器生成一个“ConcurrentMap&lt;K，List<T>&gt;”，其键是将分类函数应用于输入元素后产生的值，其对应值是包含映射到分类函数下关联键的输入元素的“List”<p> 对于返回的“Map”或“List”对象的类型、可变性或可序列化性，或者返回的“List”的线程安全性，没有任何保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，对“T”类型的输入元素执行级联“分组操作”，根据分类函数对元素进行分组，然后使用指定的下游“收集器”对与给定键关联的值执行缩减操作<p> 这是一个“收藏家”。特征#CONCURRENT“和”收集器。“无序”和“无序”收集器的特征<p> 分类函数将元素映射到某个键类型“K”。下游收集器对类型为“T”的元素进行操作，并生成类型为“D”的结果。生成的收集器生成一个“Map&lt;K，D&gt;”<p> 例如，要计算每个城市中人们的姓氏集，其中城市名称被排序：＜pre＞‘ConcurrentMap＜city，set＜String＞＞namebycity＝people.stream（）。collect（groupingByConcurrent（Person:：getCity，映射（Person：：getLastName，toSet（））；’</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream): M&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，对“T”类型的输入元素执行级联“分组操作”，根据分类函数对元素进行分组，然后使用指定的下游“收集器”对与给定键关联的值执行缩减操作。收集器生成的“ConcurrentMap”是使用提供的工厂函数创建的<p> 这是一个“收藏家”。特征#CONCURRENT“和”收集器。“无序”和“无序”收集器的特征<p> 分类函数将元素映射到某个键类型“K”。下游收集器对类型为“T”的元素进行操作，并生成类型为“D”的结果。生成的收集器生成一个“Map&lt;K，D&gt;”<p> 例如，要计算每个城市中人们的姓氏集，其中城市名称被排序：＜pre＞‘ConcurrentMap＜city，set＜String＞＞namebycity＝people.stream（）。collect（groupingBy（Person:：getCity，ConcurrentSkipListMap:：new，映射（Person：：getLastName，toSet（））；’</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>partitioningBy(Predicate&lt;? super T&gt; predicate): List<T>&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，它根据一个“谓词”对输入元素进行分区，并将它们组织成一个“Map&lt;Boolean，List<T>&gt;”。对于返回的“映射”的类型、可变性、可序列化性或线程安全性没有任何保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream): D&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，它根据一个“谓词”划分输入元素，根据另一个“采集器”减少每个分区中的值，并将它们组织成一个“Map＜Boolean，D＞”，其值是下游减少的结果<p> 对于返回的“映射”的类型、可变性、可序列化性或线程安全性没有任何保证。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper): Map&lt;K,U&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器将元素累积到“映射”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”，则在执行收集操作时会引发“IllegalStateException”。如果映射的键可能有重复项，请改用“#toMap（函数、函数、二进制运算符）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction): Map&lt;K,U&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器将元素累积到“映射”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”），则值映射函数将应用于每个相等元素，并使用提供的合并函数合并结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier): M&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器将元素累积到“映射”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”），则值映射函数将应用于每个相等元素，并使用提供的合并函数合并结果。“地图”由提供的供应商功能创建。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper): ConcurrentMap&lt;K,U&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，该收集器将元素累积到“ConcurrentMap”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”，则在执行收集操作时会引发“IllegalStateException”。如果映射的键可能有重复项，请改用“#toConcurrentMap（函数、函数、二进制运算符）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction): ConcurrentMap&lt;K,U&gt;&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，该收集器将元素累积到“ConcurrentMap”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”），则值映射函数将应用于每个相等元素，并使用提供的合并函数合并结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier): M&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个并发“收集器”，该收集器将元素累积到“ConcurrentMap”中，其键和值是将提供的映射函数应用于输入元素的结果<p> 如果映射的键包含重复项（根据“Object#equals（Object）”），则值映射函数将应用于每个相等元素，并使用提供的合并函数合并结果。“ConcurrentMap”由提供的供应商功能创建<p> 这是一个“收藏家”。特征#CONCURRENT“和”收集器。“无序”和“无序”收集器的特征。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingInt(ToIntFunction&lt;? super T&gt; mapper): IntSummaryStatistics&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器对每个输入元素应用生成“int”的映射函数，并返回结果值的汇总统计信息。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingLong(ToLongFunction&lt;? super T&gt; mapper): LongSummaryStatistics&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，它对每个输入元素应用一个“长”生成映射函数，并返回结果值的汇总统计信息。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper): DoubleSummaryStatistics&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回一个“收集器”，该收集器对每个输入元素应用“双精度”生成映射函数，并返回结果值的汇总统计信息。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Collectors-CollectorImpl"><a href="#Collectors-CollectorImpl" class="headerlink" title="Collectors$CollectorImpl"></a><a href="./Collectors$CollectorImpl.html">Collectors$CollectorImpl</a></h3><h3 id="Collectors-Partition"><a href="#Collectors-Partition" class="headerlink" title="Collectors$Partition"></a><a href="./Collectors$Partition.html">Collectors$Partition</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
