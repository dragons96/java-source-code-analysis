<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/stream/AbstractPipeline.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="AbstractPipeline-lt-E-IN-E-OUT-S-extends-BaseStream-lt-E-OUT-S-gt-gt"><a href="#AbstractPipeline-lt-E-IN-E-OUT-S-extends-BaseStream-lt-E-OUT-S-gt-gt" class="headerlink" title="AbstractPipeline&lt;E_IN, E_OUT, S extends BaseStream&lt;E_OUT, S&gt;&gt;"></a>AbstractPipeline&lt;E_IN, E_OUT, S extends BaseStream&lt;E_OUT, S&gt;&gt;</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">父接口</th>
<th align="center">泛型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.stream.AbstractPipeline&lt;E_IN, E_OUT, S extends BaseStream&lt;E_OUT, S&gt;&gt;</strong></td>
<td align="center">abstract class</td>
<td align="center">PipelineHelper&lt;E_OUT&gt;</td>
<td align="center">BaseStream&lt;E_OUT,S&gt;</td>
<td align="center">&lt;E_IN&gt;,&lt;E_OUT&gt;,&lt;S extends BaseStream&lt;E_OUT&gt;,&lt;S&gt;</td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>MSG_STREAM_LINKED: String</strong></td>
<td align="center">“stream has already been operated upon or closed”</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>MSG_CONSUMED: String</strong></td>
<td align="center">“source already consumed or closed”</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sourceOrOpFlags: int</strong></td>
<td align="center">0</td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">此管道对象表示的中间操作的操作标志。</td>
</tr>
<tr>
<td align="center"><strong>depth: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">此管道对象和流源之间的中间操作数（如果是连续的），或者前一个有状态的（如果是并行的）。在管道准备评估时有效。</td>
</tr>
<tr>
<td align="center"><strong>combinedFlags: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">源和所有操作的组合源和操作标志，包括此管道对象表示的操作。在管道准备评估时有效。</td>
</tr>
<tr>
<td align="center"><strong>sourceSpliterator: Spliterator&lt;?&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">源极分离器。仅对顶部管道有效。在使用管道之前，如果非null，则｛@code sourceSupplier｝必须为null。在使用管道之后，如果非null，则将设置为null。</td>
</tr>
<tr>
<td align="center"><strong>sourceSupplier: Supplier&lt;? extends Spliterator&lt;?&gt;&gt;</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">源供应商。仅对顶部管道有效。在使用管道之前，如果非null，则｛@code sourceSpliterator｝必须为null。在使用管道之后，如果非null，则将设置为null。</td>
</tr>
<tr>
<td align="center"><strong>linkedOrConsumed: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此管道已链接或使用，则为True</td>
</tr>
<tr>
<td align="center"><strong>sourceAnyStateful: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果管道中存在任何有状态操作，则为True；仅对源阶段有效。</td>
</tr>
<tr>
<td align="center"><strong>sourceCloseAction: Runnable</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>parallel: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果管道是并行的，则为True，否则管道是顺序的；仅对源阶段有效。</td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>AbstractPipeline(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source, int sourceFlags, boolean parallel)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">流管道头部的构造函数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>AbstractPipeline(Spliterator&lt;?&gt; source, int sourceFlags, boolean parallel)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">流管道头部的构造函数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, int opFlags)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">用于将中间操作阶段附加到现有管道上的构造函数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp): R</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用终端操作评估管道以产生结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>evaluateToArrayNode(IntFunction&lt;E_OUT[]&gt; generator): Node<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">收集从管道阶段输出的元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sourceStageSpliterator(): Spliterator<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">如果此管道级是源级，则获取源级拆分器。调用此方法并成功返回后，将使用管道。</td>
<td align="left">IllegalStateException</td>
</tr>
<tr>
<td align="center"><strong>sequential(): S</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>parallel(): S</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>close(): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>onClose(Runnable closeHandler): S</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>spliterator(): Spliterator<E_OUT></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isParallel(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getStreamFlags(): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">返回流源和所有中间操作的流标志的组合。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sourceSpliterator(int terminalFlags): Spliterator&lt;?&gt;</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">获取此管道阶段的源拆分器。对于顺序或无状态并行管道，这是源拆分器。对于有状态并行管道，这是一个拆分器，描述直到并包括最近的有状态操作的所有计算结果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getSourceShape(): StreamShape</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>exactOutputSizeIfKnown(Spliterator&lt;P_IN&gt; spliterator): long</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>wrapAndCopyInto(S sink, Spliterator&lt;P_IN&gt; spliterator): S</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>copyIntoWithCancel(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getStreamAndOpFlags(): int</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isOrdered(): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>wrapSink(Sink&lt;E_OUT&gt; sink): Sink<P_IN></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>wrapSpliterator(Spliterator&lt;P_IN&gt; sourceSpliterator): Spliterator<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>evaluate(Spliterator&lt;P_IN&gt; spliterator, boolean flatten, IntFunction&lt;E_OUT[]&gt; generator): Node<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getOutputShape(): StreamShape</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">获取管道的输出形状。如果管道是头部，则其输出形状对应于源的形状。否则，它的输出形状对应于关联操作的输出形状。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>evaluateToNode(PipelineHelper&lt;E_OUT&gt; helper, Spliterator&lt;P_IN&gt; spliterator, boolean flattenTree, IntFunction&lt;E_OUT[]&gt; generator): Node<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">将管道输出的元素收集到保存此形状元素的节点中。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>wrap(PipelineHelper&lt;E_OUT&gt; ph, Supplier&lt;Spliterator&lt;P_IN&gt;&gt; supplier, boolean isParallel): Spliterator<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">创建一个拆分器，该拆分器包装与此流形状兼容的源拆分器以及与“PipelineHelper”关联的操作。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lazySpliterator(Supplier&lt;? extends Spliterator&lt;E_OUT&gt;&gt; supplier): Spliterator<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">创建一个惰性拆分器，当在惰性拆分器上调用方法时，该拆分器包装并获取拆分器提供的数据。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>forEachWithCancel(Spliterator&lt;E_OUT&gt; spliterator, Sink&lt;E_OUT&gt; sink): void</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">穿过与此流形状兼容的分离器的元件，将这些元件推入水槽。如果接收器请求取消，则不会再拉动或推动其他元件。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>makeNodeBuilder(long exactSizeIfKnown, IntFunction&lt;E_OUT[]&gt; generator): Node.Builder<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">使节点生成器与此流形状兼容。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>opIsStateful(): boolean</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">返回此操作是否有状态。如果它是有状态的，则必须重写方法“#OpeValueParallel（PipelineHelper，java.util.Spliterator，java.util.function.IntFunction）”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>opWrapSink(int flags, Sink&lt;E_OUT&gt; sink): Sink<E_IN></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">接受将接收此操作结果的“接收器”，并返回一个“接收器”，该“接收器”接受此操作输入类型的元素并执行该操作，将结果传递给提供的“接收器”。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>opEvaluateParallel(PipelineHelper&lt;E_OUT&gt; helper, Spliterator&lt;P_IN&gt; spliterator, IntFunction&lt;E_OUT[]&gt; generator): Node<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用描述上游中间操作的指定“PipelineHelper”对操作执行并行评估。仅对有状态操作调用。如果“#opIsStateful（）”返回true，则实现必须覆盖默认实现。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>opEvaluateParallelLazy(PipelineHelper&lt;E_OUT&gt; helper, Spliterator&lt;P_IN&gt; spliterator): Spliterator<E_OUT></strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">使用指定的描述上游中间操作的“PipelineHelper”返回描述操作并行计算的“拆分器”。仅对有状态操作调用。此处无需（尽管可以接受）对结果进行完整计算；如果可能，最好通过延迟评估的拆分器描述结果。</td>
<td align="left"></td>
</tr>
</tbody></table>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
