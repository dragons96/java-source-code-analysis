<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/util/Collections.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.util.Collections</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>BINARYSEARCH_THRESHOLD: int</strong></td>
<td align="center">5000</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tuning parameters for algorithms - Many of the List algorithms have two implementations, one of which is appropriate for RandomAccess lists, the other for “sequential.”  Often, the random access variant yields better performance on small sequential access lists.  The tuning parameters below determine the cutoff point for what constitutes a “small” sequential access list for each algorithm.  The values below were empirically determined to work well for LinkedList. Hopefully they should be reasonable for other sequential access List implementations.  Those doing performance work on this code would do well to validate the values of these parameters from time to time. (The first word of each tuning parameter name is the algorithm to which it applies.)</td>
</tr>
<tr>
<td align="center"><strong>REVERSE_THRESHOLD: int</strong></td>
<td align="center">18</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>SHUFFLE_THRESHOLD: int</strong></td>
<td align="center">5</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>FILL_THRESHOLD: int</strong></td>
<td align="center">25</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ROTATE_THRESHOLD: int</strong></td>
<td align="center">100</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>COPY_THRESHOLD: int</strong></td>
<td align="center">10</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>REPLACEALL_THRESHOLD: int</strong></td>
<td align="center">11</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>INDEXOFSUBLIST_THRESHOLD: int</strong></td>
<td align="center">35</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>r: Random</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Collections()</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sort(List&lt;T&gt; list): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sorts the specified list into ascending order, according to the ‘Comparable natural ordering’ of its elements. All elements in the list must implement the ‘Comparable’ interface.  Furthermore, all elements in the list must be <i>mutually comparable</i> (that is, ‘e1.compareTo(e2)’ must not throw a ‘ClassCastException’ for any elements ‘e1’ and ‘e2’ in the list).  <p>This sort is guaranteed to be <i>stable</i>:  equal elements will not be reordered as a result of the sort.  <p>The specified list must be modifiable, but need not be resizable.</td>
<td align="left">ClassCastException<br/>IllegalArgumentException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sorts the specified list according to the order induced by the specified comparator.  All elements in the list must be <i>mutually comparable</i> using the specified comparator (that is, ‘c.compare(e1, e2)’ must not throw a ‘ClassCastException’ for any elements ‘e1’ and ‘e2’ in the list).  <p>This sort is guaranteed to be <i>stable</i>:  equal elements will not be reordered as a result of the sort.  <p>The specified list must be modifiable, but need not be resizable.</td>
<td align="left">ClassCastException<br/>IllegalArgumentException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Searches the specified list for the specified object using the binary search algorithm.  The list must be sorted into ascending order according to the ‘Comparable natural ordering’ of its elements (as by the ‘#sort(List)’ method) prior to making this call.  If it is not sorted, the results are undefined.  If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found.  <p>This method runs in log(n) time for a “random access” list (which provides near-constant-time positional access).  If the specified list does not implement the ‘RandomAccess’ interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.</td>
<td align="left">ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>get(ListIterator&lt;? extends T&gt; i, int index): T</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Gets the ith element from the given list by repositioning the specified list listIterator.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Searches the specified list for the specified object using the binary search algorithm.  The list must be sorted into ascending order according to the specified comparator (as by the ‘#sort(List, Comparator) sort(List, Comparator)’ method), prior to making this call.  If it is not sorted, the results are undefined.  If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found.  <p>This method runs in log(n) time for a “random access” list (which provides near-constant-time positional access).  If the specified list does not implement the ‘RandomAccess’ interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.</td>
<td align="left">ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>indexedBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>iteratorBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reverse(List&lt;?&gt; list): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reverses the order of the elements in the specified list.<p>  This method runs in linear time.</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>shuffle(List&lt;?&gt; list): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Randomly permutes the specified list using a default source of randomness.  All permutations occur with approximately equal likelihood.  <p>The hedge “approximately” is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity.  <p>This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the “current position”.  Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive.  <p>This method runs in linear time.  If the specified list does not implement the ‘RandomAccess’ interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list.  This avoids the quadratic behavior that would result from shuffling a “sequential access” list in place.</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>shuffle(List&lt;?&gt; list, Random rnd): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Randomly permute the specified list using the specified source of randomness.  All permutations occur with equal likelihood assuming that the source of randomness is fair.<p>  This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the “current position”.  Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive.<p>  This method runs in linear time.  If the specified list does not implement the ‘RandomAccess’ interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list.  This avoids the quadratic behavior that would result from shuffling a “sequential access” list in place.</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>swap(List&lt;?&gt; list, int i, int j): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)</td>
<td align="left">IndexOutOfBoundsException</td>
</tr>
<tr>
<td align="center"><strong>swap(Object[] arr, int i, int j): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Swaps the two specified elements in the specified array.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fill(List&lt;? super T&gt; list, T obj): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Replaces all of the elements of the specified list with the specified element. <p>  This method runs in linear time.</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Copies all of the elements from one list into another.  After the operation, the index of each copied element in the destination list will be identical to its index in the source list.  The destination list must be at least as long as the source list.  If it is longer, the remaining elements in the destination list are unaffected. <p>  This method runs in linear time.</td>
<td align="left">IndexOutOfBoundsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>min(Collection&lt;? extends T&gt; coll): T</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the minimum element of the given collection, according to the <i>natural ordering</i> of its elements.  All elements in the collection must implement the <tt>Comparable</tt> interface. Furthermore, all elements in the collection must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the collection).<p>  This method iterates over the entire collection, hence it requires time proportional to the size of the collection.</td>
<td align="left">ClassCastException<br/>NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp): T</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the minimum element of the given collection, according to the order induced by the specified comparator.  All elements in the collection must be <i>mutually comparable</i> by the specified comparator (that is, <tt>comp.compare(e1, e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the collection).<p>  This method iterates over the entire collection, hence it requires time proportional to the size of the collection.</td>
<td align="left">ClassCastException<br/>NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>max(Collection&lt;? extends T&gt; coll): T</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the maximum element of the given collection, according to the <i>natural ordering</i> of its elements.  All elements in the collection must implement the <tt>Comparable</tt> interface. Furthermore, all elements in the collection must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the collection).<p>  This method iterates over the entire collection, hence it requires time proportional to the size of the collection.</td>
<td align="left">ClassCastException<br/>NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp): T</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the maximum element of the given collection, according to the order induced by the specified comparator.  All elements in the collection must be <i>mutually comparable</i> by the specified comparator (that is, <tt>comp.compare(e1, e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and <tt>e2</tt> in the collection).<p>  This method iterates over the entire collection, hence it requires time proportional to the size of the collection.</td>
<td align="left">ClassCastException<br/>NoSuchElementException</td>
</tr>
<tr>
<td align="center"><strong>rotate(List&lt;?&gt; list, int distance): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Rotates the elements in the specified list by the specified distance. After calling this method, the element at index <tt>i</tt> will be the element previously at index <tt>(i - distance)</tt> mod <tt>list.size()</tt>, for all values of <tt>i</tt> between <tt>0</tt> and <tt>list.size()-1</tt>, inclusive.  (This method has no effect on the size of the list.)  <p>For example, suppose <tt>list</tt> comprises<tt> [t, a, n, k, s]</tt>. After invoking <tt>Collections.rotate(list, 1)</tt> (or <tt>Collections.rotate(list, -4)</tt>), <tt>list</tt> will comprise <tt>[s, t, a, n, k]</tt>.  <p>Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements.  For example, the following idiom moves the element at index <tt>j</tt> forward to position <tt>k</tt> (which must be greater than or equal to <tt>j</tt>): <pre> Collections.rotate(list.subList(j, k+1), -1); </pre> To make this concrete, suppose <tt>list</tt> comprises <tt>[a, b, c, d, e]</tt>.  To move the element at index <tt>1</tt> (<tt>b</tt>) forward two positions, perform the following invocation: <pre> Collections.rotate(l.subList(1, 4), -1); </pre> The resulting list is <tt>[a, c, d, b, e]</tt>.  <p>To move more than one element forward, increase the absolute value of the rotation distance.  To move elements backward, use a positive shift distance.  <p>If the specified list is small or implements the ‘RandomAccess’ interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element.  If necessary, the process is repeated on the second and successive elements, until the rotation is complete.  If the specified list is large and doesn’t implement the <tt>RandomAccess</tt> interface, this implementation breaks the list into two sublist views around index <tt>-distance mod size</tt>. Then the ‘#reverse(List)’ method is invoked on each sublist view, and finally it is invoked on the entire list.  For a more complete description of both algorithms, see Section 2.3 of Jon Bentley’s <i>Programming Pearls</i> (Addison-Wesley, 1986).</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>rotate1(List&lt;T&gt; list, int distance): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>rotate2(List&lt;?&gt; list, int distance): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>replaceAll(List&lt;T&gt; list, T oldVal, T newVal): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Replaces all occurrences of one specified value in a list with another. More formally, replaces with <tt>newVal</tt> each element <tt>e</tt> in <tt>list</tt> such that <tt>(oldVal&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : oldVal.equals(e))</tt>. (This method has no effect on the size of the list.)</td>
<td align="left">UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.  More formally, returns the lowest index <tt>i</tt> such that ‘source.subList(i, i+target.size()).equals(target)’, or -1 if there is no such index.  (Returns -1 if ‘target.size() &gt; source.size()’)  <p>This implementation uses the “brute force” technique of scanning over the source list, looking for a match with the target at each location in turn.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lastIndexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence.  More formally, returns the highest index <tt>i</tt> such that ‘source.subList(i, i+target.size()).equals(target)’, or -1 if there is no such index.  (Returns -1 if ‘target.size() &gt; source.size()’)  <p>This implementation uses the “brute force” technique of iterating over the source list, looking for a match with the target at each location in turn.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableCollection(Collection&lt;? extends T&gt; c): Collection<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified collection.  This method allows modules to provide users with “read-only” access to internal collections.  Query operations on the returned collection “read through” to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned collection does <i>not</i> pass the hashCode and equals operations through to the backing collection, but relies on <tt>Object</tt>‘s <tt>equals</tt> and <tt>hashCode</tt> methods.  This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list.<p>  The returned collection will be serializable if the specified collection is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableSet(Set&lt;? extends T&gt; s): Set<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified set.  This method allows modules to provide users with “read-only” access to internal sets. Query operations on the returned set “read through” to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned set will be serializable if the specified set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableSortedSet(SortedSet&lt;T&gt; s): SortedSet<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified sorted set.  This method allows modules to provide users with “read-only” access to internal sorted sets.  Query operations on the returned sorted set “read through” to the specified sorted set.  Attempts to modify the returned sorted set, whether direct, via its iterator, or via its <tt>subSet</tt>, <tt>headSet</tt>, or <tt>tailSet</tt> views, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned sorted set will be serializable if the specified sorted set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableNavigableSet(NavigableSet&lt;T&gt; s): NavigableSet<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified navigable set.  This method allows modules to provide users with “read-only” access to internal navigable sets.  Query operations on the returned navigable set “read through” to the specified navigable set.  Attempts to modify the returned navigable set, whether direct, via its iterator, or via its ‘subSet’, ‘headSet’, or ‘tailSet’ views, result in an ‘UnsupportedOperationException’.<p>  The returned navigable set will be serializable if the specified navigable set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableList(List&lt;? extends T&gt; list): List<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified list.  This method allows modules to provide users with “read-only” access to internal lists.  Query operations on the returned list “read through” to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement ‘RandomAccess’ if the specified list does.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m): Map&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified map.  This method allows modules to provide users with “read-only” access to internal maps.  Query operations on the returned map “read through” to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned map will be serializable if the specified map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m): SortedMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified sorted map.  This method allows modules to provide users with “read-only” access to internal sorted maps.  Query operations on the returned sorted map “read through” to the specified sorted map.  Attempts to modify the returned sorted map, whether direct, via its collection views, or via its <tt>subMap</tt>, <tt>headMap</tt>, or <tt>tailMap</tt> views, result in an <tt>UnsupportedOperationException</tt>.<p>  The returned sorted map will be serializable if the specified sorted map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m): NavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an unmodifiable view of the specified navigable map.  This method allows modules to provide users with “read-only” access to internal navigable maps.  Query operations on the returned navigable map “read through” to the specified navigable map.  Attempts to modify the returned navigable map, whether direct, via its collection views, or via its ‘subMap’, ‘headMap’, or ‘tailMap’ views, result in an ‘UnsupportedOperationException’.<p>  The returned navigable map will be serializable if the specified navigable map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedCollection(Collection&lt;T&gt; c): Collection<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) collection backed by the specified collection.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing collection is accomplished through the returned collection.<p>  It is imperative that the user manually synchronize on the returned collection when traversing it via ‘Iterator’, ‘Spliterator’ or ‘Stream’: <pre> Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned collection does <i>not</i> pass the ‘hashCode’ and ‘equals’ operations through to the backing collection, but relies on ‘Object’’s equals and hashCode methods.  This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list.<p>  The returned collection will be serializable if the specified collection is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedCollection(Collection&lt;T&gt; c, Object mutex): Collection<T></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedSet(Set&lt;T&gt; s): Set<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) set backed by the specified set.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing set is accomplished through the returned set.<p>  It is imperative that the user manually synchronize on the returned set when iterating over it: <pre> Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned set will be serializable if the specified set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedSet(Set&lt;T&gt; s, Object mutex): Set<T></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedSortedSet(SortedSet&lt;T&gt; s): SortedSet<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) sorted set backed by the specified sorted set.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing sorted set is accomplished through the returned sorted set (or its views).<p>  It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its <tt>subSet</tt>, <tt>headSet</tt>, or <tt>tailSet</tt> views. <pre> SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> or: <pre> SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { Iterator i = s2.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned sorted set will be serializable if the specified sorted set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedNavigableSet(NavigableSet&lt;T&gt; s): NavigableSet<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) navigable set backed by the specified navigable set.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing navigable set is accomplished through the returned navigable set (or its views).<p>  It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its ‘subSet’, ‘headSet’, or ‘tailSet’ views. <pre> NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> or: <pre> NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { Iterator i = s2.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned navigable set will be serializable if the specified navigable set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedList(List&lt;T&gt; list): List<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) list backed by the specified list.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing list is accomplished through the returned list.<p>  It is imperative that the user manually synchronize on the returned list when iterating over it: <pre> List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned list will be serializable if the specified list is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedList(List&lt;T&gt; list, Object mutex): List<T></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedMap(Map&lt;K,V&gt; m): Map&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) map backed by the specified map.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing map is accomplished through the returned map.<p>  It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views: <pre> Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); ... synchronized (m) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned map will be serializable if the specified map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedSortedMap(SortedMap&lt;K,V&gt; m): SortedMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) sorted map backed by the specified sorted map.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing sorted map is accomplished through the returned sorted map (or its views).<p>  It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its <tt>subMap</tt>, <tt>headMap</tt> or <tt>tailMap</tt> views. <pre> SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); ... synchronized (m) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> or: <pre> SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); ... synchronized (m) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned sorted map will be serializable if the specified sorted map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m): NavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a synchronized (thread-safe) navigable map backed by the specified navigable map.  In order to guarantee serial access, it is critical that <strong>all</strong> access to the backing navigable map is accomplished through the returned navigable map (or its views).<p>  It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its ‘subMap’, ‘headMap’ or ‘tailMap’ views. <pre> NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); ... synchronized (m) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> or: <pre> NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); ... synchronized (m) { Iterator i = s.iterator(); while (i.hasNext()) foo(i.next()); } </pre> Failure to follow this advice may result in non-deterministic behavior.  <p>The returned navigable map will be serializable if the specified navigable map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>checkedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type): Collection<E></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ‘ClassCastException’.  Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is <i>guaranteed</i> that the collection cannot contain an incorrectly typed element.  <p>The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts.  Usually this is not a problem, as the compiler issues warnings on all such unchecked operations.  There are, however, times when static type checking alone is not sufficient.  For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type.  <p>Another use of dynamically typesafe views is debugging.  Suppose a program fails with a ‘ClassCastException’, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem.  If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration: <pre> 'Collection<String> c = new HashSet<>();'</pre> may be replaced temporarily by this one: <pre> 'Collection<String> c = Collections.checkedCollection( new HashSet<>(), String.class);'</pre> Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem.  Once the problem is fixed, the modified declaration may be reverted back to the original.  <p>The returned collection does <i>not</i> pass the hashCode and equals operations through to the backing collection, but relies on ‘Object’’s ‘equals’ and ‘hashCode’ methods.  This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list.  <p>The returned collection will be serializable if the specified collection is serializable.  <p>Since ‘null’ is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>zeroLengthArray(Class&lt;T&gt; type): T[]</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyIterator(): Iterator<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyListIterator(): ListIterator<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a list iterator that has no elements.  More precisely,  <ul> <li>‘Iterator#hasNext hasNext’ and ‘ListIterator#hasPrevious hasPrevious’ always return ‘false’.</li> <li>‘Iterator#next next’ and ‘ListIterator#previous previous’ always throw ‘NoSuchElementException’.</li> <li>‘Iterator#remove remove’ and ‘ListIterator#set set’ always throw ‘IllegalStateException’.</li> <li>‘ListIterator#add add’ always throws ‘UnsupportedOperationException’.</li> <li>‘ListIterator#nextIndex nextIndex’ always returns ‘0’.</li> <li>‘ListIterator#previousIndex previousIndex’ always returns ‘-1’.</li> </ul>  <p>Implementations of this method are permitted, but not required, to return the same object from multiple invocations.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyEnumeration(): Enumeration<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an enumeration that has no elements.  More precisely,  <ul> <li>‘Enumeration#hasMoreElements hasMoreElements’ always returns ‘false’.</li> <li> ‘Enumeration#nextElement nextElement’ always throws ‘NoSuchElementException’.</li> </ul>  <p>Implementations of this method are permitted, but not required, to return the same object from multiple invocations.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptySet(): Set<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty set (immutable).  This set is serializable. Unlike the like-named field, this method is parameterized.  <p>This example illustrates the type-safe way to obtain an empty set: <pre> Set&lt;String&gt; s = Collections.emptySet(); </pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptySortedSet(): SortedSet<E></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty sorted set (immutable).  This set is serializable.  <p>This example illustrates the type-safe way to obtain an empty sorted set: <pre> 'SortedSet<String> s = Collections.emptySortedSet();'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyNavigableSet(): NavigableSet<E></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty navigable set (immutable).  This set is serializable.  <p>This example illustrates the type-safe way to obtain an empty navigable set: <pre> 'NavigableSet<String> s = Collections.emptyNavigableSet();'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyList(): List<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty list (immutable).  This list is serializable.  <p>This example illustrates the type-safe way to obtain an empty list: <pre> List&lt;String&gt; s = Collections.emptyList(); </pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyMap(): Map&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty map (immutable).  This map is serializable.  <p>This example illustrates the type-safe way to obtain an empty map: <pre> Map&lt;String, Date&gt; s = Collections.emptyMap(); </pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptySortedMap(): SortedMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty sorted map (immutable).  This map is serializable.  <p>This example illustrates the type-safe way to obtain an empty map: <pre> 'SortedMap<String, Date> s = Collections.emptySortedMap();'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>emptyNavigableMap(): NavigableMap&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an empty navigable map (immutable).  This map is serializable.  <p>This example illustrates the type-safe way to obtain an empty map: <pre> 'NavigableMap<String, Date> s = Collections.emptyNavigableMap();'</pre></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singleton(T o): Set<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an immutable set containing only the specified object. The returned set is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singletonIterator(final E e): Iterator<E></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singletonSpliterator(final T element): Spliterator<T></strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a ‘Spliterator’ with only the specified element</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singletonList(T o): List<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an immutable list containing only the specified object. The returned list is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singletonMap(K key, V value): Map&lt;K,V&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an immutable map, mapping only the specified key to the specified value.  The returned map is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>nCopies(int n, T o): List<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an immutable list consisting of <tt>n</tt> copies of the specified object.  The newly allocated data object is tiny (it contains a single reference to the data object).  This method is useful in combination with the <tt>List.addAll</tt> method to grow lists. The returned list is serializable.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>reverseOrder(): Comparator<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a comparator that imposes the reverse of the <em>natural ordering</em> on a collection of objects that implement the ‘Comparable’ interface.  (The natural ordering is the ordering imposed by the objects’ own ‘compareTo’ method.)  This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the ‘Comparable’ interface in reverse-natural-order.  For example, suppose ‘a’ is an array of strings. Then: <pre> Arrays.sort(a, Collections.reverseOrder()); </pre> sorts the array in reverse-lexicographic (alphabetical) order.<p>  The returned comparator is serializable.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>reverseOrder(Comparator&lt;T&gt; cmp): Comparator<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a comparator that imposes the reverse ordering of the specified comparator.  If the specified comparator is ‘null’, this method is equivalent to ‘#reverseOrder()’ (in other words, it returns a comparator that imposes the reverse of the <em>natural ordering</em> on a collection of objects that implement the Comparable interface).  <p>The returned comparator is serializable (assuming the specified comparator is also serializable or ‘null’).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>enumeration(final Collection&lt;T&gt; c): Enumeration<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an enumeration over the specified collection.  This provides interoperability with legacy APIs that require an enumeration as input.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>list(Enumeration&lt;T&gt; e): ArrayList<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration.  This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>eq(Object o1, Object o2): boolean</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns true if the specified arguments are equal, or both null.  NB: Do not replace with Object.equals until JDK-8015417 is resolved.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>frequency(Collection&lt;?&gt; c, Object o): int</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the number of elements in the specified collection equal to the specified object.  More formally, returns the number of elements <tt>e</tt> in the collection such that <tt>(o &#x3D;&#x3D; null ? e &#x3D;&#x3D; null : o.equals(e))</tt>.</td>
<td align="left">NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns ‘true’ if the two specified collections have no elements in common.  <p>Care must be exercised if this method is used on collections that do not comply with the general contract for ‘Collection’. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation).  If either collection uses a nonstandard equality test (as does a ‘SortedSet’ whose ordering is not <em>compatible with equals</em>, or the key set of an ‘IdentityHashMap’), both collections must use the same nonstandard equality test, or the result of this method is undefined.  <p>Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections.  <p>Note that it is permissible to pass the same collection in both parameters, in which case the method will return ‘true’ if and only if the collection is empty.</td>
<td align="left">ClassCastException<br/>NullPointerException</td>
</tr>
<tr>
<td align="center"><strong>addAll(Collection&lt;? super T&gt; c, T… elements): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of <tt>c.addAll(Arrays.asList(elements))</tt>, but this method is likely to run significantly faster under most implementations.  <p>When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection: <pre> Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); </pre></td>
<td align="left">IllegalArgumentException<br/>NullPointerException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>newSetFromMap(Map&lt;E, Boolean&gt; map): Set<E></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a set backed by the specified map.  The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map.  In essence, this factory method provides a ‘Set’ implementation corresponding to any ‘Map’ implementation.  There is no need to use this method on a ‘Map’ implementation that already has a corresponding ‘Set’ implementation (such as ‘HashMap’ or ‘TreeMap’).  <p>Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its <tt>keySet</tt> view, with one exception.  The <tt>addAll</tt> method is implemented as a sequence of <tt>put</tt> invocations on the backing map.  <p>The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns.  These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment: <pre> Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap( new WeakHashMap&lt;Object, Boolean&gt;()); </pre></td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>asLifoQueue(Deque&lt;T&gt; deque): Queue<T></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a view of a ‘Deque’ as a Last-in-first-out (Lifo) ‘Queue’. Method <tt>add</tt> is mapped to <tt>push</tt>, <tt>remove</tt> is mapped to <tt>pop</tt> and so on. This view can be useful when you would like to use a method requiring a <tt>Queue</tt> but you need Lifo ordering.  <p>Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception.  The ‘Queue#addAll addAll’ method is implemented as a sequence of ‘Deque#addFirst addFirst’ invocations on the backing deque.</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Collections-UnmodifiableCollection"><a href="#Collections-UnmodifiableCollection" class="headerlink" title="Collections$UnmodifiableCollection"></a><a href="./Collections$UnmodifiableCollection.html">Collections$UnmodifiableCollection</a></h3><h3 id="Collections-UnmodifiableSet"><a href="#Collections-UnmodifiableSet" class="headerlink" title="Collections$UnmodifiableSet"></a><a href="./Collections$UnmodifiableSet.html">Collections$UnmodifiableSet</a></h3><h3 id="Collections-UnmodifiableSortedSet"><a href="#Collections-UnmodifiableSortedSet" class="headerlink" title="Collections$UnmodifiableSortedSet"></a><a href="./Collections$UnmodifiableSortedSet.html">Collections$UnmodifiableSortedSet</a></h3><h3 id="Collections-UnmodifiableNavigableSet"><a href="#Collections-UnmodifiableNavigableSet" class="headerlink" title="Collections$UnmodifiableNavigableSet"></a><a href="./Collections$UnmodifiableNavigableSet.html">Collections$UnmodifiableNavigableSet</a></h3><h3 id="Collections-UnmodifiableList"><a href="#Collections-UnmodifiableList" class="headerlink" title="Collections$UnmodifiableList"></a><a href="./Collections$UnmodifiableList.html">Collections$UnmodifiableList</a></h3><h3 id="Collections-UnmodifiableRandomAccessList"><a href="#Collections-UnmodifiableRandomAccessList" class="headerlink" title="Collections$UnmodifiableRandomAccessList"></a><a href="./Collections$UnmodifiableRandomAccessList.html">Collections$UnmodifiableRandomAccessList</a></h3><h3 id="Collections-UnmodifiableMap"><a href="#Collections-UnmodifiableMap" class="headerlink" title="Collections$UnmodifiableMap"></a><a href="./Collections$UnmodifiableMap.html">Collections$UnmodifiableMap</a></h3><h3 id="Collections-UnmodifiableSortedMap"><a href="#Collections-UnmodifiableSortedMap" class="headerlink" title="Collections$UnmodifiableSortedMap"></a><a href="./Collections$UnmodifiableSortedMap.html">Collections$UnmodifiableSortedMap</a></h3><h3 id="Collections-UnmodifiableNavigableMap"><a href="#Collections-UnmodifiableNavigableMap" class="headerlink" title="Collections$UnmodifiableNavigableMap"></a><a href="./Collections$UnmodifiableNavigableMap.html">Collections$UnmodifiableNavigableMap</a></h3><h3 id="Collections-SynchronizedCollection"><a href="#Collections-SynchronizedCollection" class="headerlink" title="Collections$SynchronizedCollection"></a><a href="./Collections$SynchronizedCollection.html">Collections$SynchronizedCollection</a></h3><h3 id="Collections-SynchronizedSet"><a href="#Collections-SynchronizedSet" class="headerlink" title="Collections$SynchronizedSet"></a><a href="./Collections$SynchronizedSet.html">Collections$SynchronizedSet</a></h3><h3 id="Collections-SynchronizedSortedSet"><a href="#Collections-SynchronizedSortedSet" class="headerlink" title="Collections$SynchronizedSortedSet"></a><a href="./Collections$SynchronizedSortedSet.html">Collections$SynchronizedSortedSet</a></h3><h3 id="Collections-SynchronizedNavigableSet"><a href="#Collections-SynchronizedNavigableSet" class="headerlink" title="Collections$SynchronizedNavigableSet"></a><a href="./Collections$SynchronizedNavigableSet.html">Collections$SynchronizedNavigableSet</a></h3><h3 id="Collections-SynchronizedList"><a href="#Collections-SynchronizedList" class="headerlink" title="Collections$SynchronizedList"></a><a href="./Collections$SynchronizedList.html">Collections$SynchronizedList</a></h3><h3 id="Collections-SynchronizedRandomAccessList"><a href="#Collections-SynchronizedRandomAccessList" class="headerlink" title="Collections$SynchronizedRandomAccessList"></a><a href="./Collections$SynchronizedRandomAccessList.html">Collections$SynchronizedRandomAccessList</a></h3><h3 id="Collections-SynchronizedMap"><a href="#Collections-SynchronizedMap" class="headerlink" title="Collections$SynchronizedMap"></a><a href="./Collections$SynchronizedMap.html">Collections$SynchronizedMap</a></h3><h3 id="Collections-SynchronizedSortedMap"><a href="#Collections-SynchronizedSortedMap" class="headerlink" title="Collections$SynchronizedSortedMap"></a><a href="./Collections$SynchronizedSortedMap.html">Collections$SynchronizedSortedMap</a></h3><h3 id="Collections-SynchronizedNavigableMap"><a href="#Collections-SynchronizedNavigableMap" class="headerlink" title="Collections$SynchronizedNavigableMap"></a><a href="./Collections$SynchronizedNavigableMap.html">Collections$SynchronizedNavigableMap</a></h3><h3 id="Collections-CheckedCollection"><a href="#Collections-CheckedCollection" class="headerlink" title="Collections$CheckedCollection"></a><a href="./Collections$CheckedCollection.html">Collections$CheckedCollection</a></h3><h3 id="Collections-EmptyIterator"><a href="#Collections-EmptyIterator" class="headerlink" title="Collections$EmptyIterator"></a><a href="./Collections$EmptyIterator.html">Collections$EmptyIterator</a></h3><h3 id="Collections-EmptyListIterator"><a href="#Collections-EmptyListIterator" class="headerlink" title="Collections$EmptyListIterator"></a><a href="./Collections$EmptyListIterator.html">Collections$EmptyListIterator</a></h3><h3 id="Collections-EmptyEnumeration"><a href="#Collections-EmptyEnumeration" class="headerlink" title="Collections$EmptyEnumeration"></a><a href="./Collections$EmptyEnumeration.html">Collections$EmptyEnumeration</a></h3><h3 id="Collections-EmptySet"><a href="#Collections-EmptySet" class="headerlink" title="Collections$EmptySet"></a><a href="./Collections$EmptySet.html">Collections$EmptySet</a></h3><h3 id="Collections-EmptyList"><a href="#Collections-EmptyList" class="headerlink" title="Collections$EmptyList"></a><a href="./Collections$EmptyList.html">Collections$EmptyList</a></h3><h3 id="Collections-EmptyMap"><a href="#Collections-EmptyMap" class="headerlink" title="Collections$EmptyMap"></a><a href="./Collections$EmptyMap.html">Collections$EmptyMap</a></h3><h3 id="Collections-SingletonSet"><a href="#Collections-SingletonSet" class="headerlink" title="Collections$SingletonSet"></a><a href="./Collections$SingletonSet.html">Collections$SingletonSet</a></h3><h3 id="Collections-SingletonList"><a href="#Collections-SingletonList" class="headerlink" title="Collections$SingletonList"></a><a href="./Collections$SingletonList.html">Collections$SingletonList</a></h3><h3 id="Collections-SingletonMap"><a href="#Collections-SingletonMap" class="headerlink" title="Collections$SingletonMap"></a><a href="./Collections$SingletonMap.html">Collections$SingletonMap</a></h3><h3 id="Collections-CopiesList"><a href="#Collections-CopiesList" class="headerlink" title="Collections$CopiesList"></a><a href="./Collections$CopiesList.html">Collections$CopiesList</a></h3><h3 id="Collections-ReverseComparator"><a href="#Collections-ReverseComparator" class="headerlink" title="Collections$ReverseComparator"></a><a href="./Collections$ReverseComparator.html">Collections$ReverseComparator</a></h3><h3 id="Collections-ReverseComparator2"><a href="#Collections-ReverseComparator2" class="headerlink" title="Collections$ReverseComparator2"></a><a href="./Collections$ReverseComparator2.html">Collections$ReverseComparator2</a></h3><h3 id="Collections-SetFromMap"><a href="#Collections-SetFromMap" class="headerlink" title="Collections$SetFromMap"></a><a href="./Collections$SetFromMap.html">Collections$SetFromMap</a></h3><h3 id="Collections-AsLIFOQueue"><a href="#Collections-AsLIFOQueue" class="headerlink" title="Collections$AsLIFOQueue"></a><a href="./Collections$AsLIFOQueue.html">Collections$AsLIFOQueue</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
