<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/nio/channels/AsynchronousSocketChannel.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父接口</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.nio.channels.AsynchronousSocketChannel</strong></td>
<td align="center">abstract class</td>
<td align="center">AsynchronousByteChannel,NetworkChannel</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>provider: AsynchronousChannelProvider</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>AsynchronousSocketChannel(AsynchronousChannelProvider provider)</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initializes a new instance of this class.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>provider(): AsynchronousChannelProvider</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the provider that created this channel.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>open(AsynchronousChannelGroup group): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens an asynchronous socket channel.  <p> The new channel is created by invoking the ‘AsynchronousChannelProvider#openAsynchronousSocketChannel openAsynchronousSocketChannel’ method on the ‘AsynchronousChannelProvider’ that created the group. If the group parameter is ‘null’ then the resulting channel is created by the system-wide default provider, and bound to the <em>default group</em>.</td>
<td align="left">ShutdownChannelGroupException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>open(): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens an asynchronous socket channel.  <p> This method returns an asynchronous socket channel that is bound to the <em>default group</em>.This method is equivalent to evaluating the expression: <blockquote><pre> open((AsynchronousChannelGroup)null); </pre></blockquote></td>
<td align="left">IOException</td>
</tr>
<tr>
<td align="center"><strong>bind(SocketAddress local): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
<td align="left">ClosedChannelException<br/>SecurityException<br/>UnsupportedAddressTypeException<br/>AlreadyBoundException<br/>ConnectionPendingException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>setOption(SocketOption&lt;T&gt; name, T value): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
<td align="left">IOException<br/>ClosedChannelException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>shutdownInput(): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Shutdown the connection for reading without closing the channel.  <p> Once shutdown for reading then further reads on the channel will return ‘-1’, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding read operation is system dependent and therefore not specified. The effect, if any, when there is data in the socket receive buffer that has not been read, or data arrives subsequently, is also system dependent.</td>
<td align="left">IOException<br/>NotYetConnectedException<br/>ClosedChannelException</td>
</tr>
<tr>
<td align="center"><strong>shutdownOutput(): AsynchronousSocketChannel</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Shutdown the connection for writing without closing the channel.  <p> Once shutdown for writing then further attempts to write to the channel will throw ‘ClosedChannelException’. If the output side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding write operation is system dependent and therefore not specified.</td>
<td align="left">IOException<br/>NotYetConnectedException<br/>ClosedChannelException</td>
</tr>
<tr>
<td align="center"><strong>getRemoteAddress(): SocketAddress</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Returns the remote address to which this channel’s socket is connected.  <p> Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type ‘java.net.InetSocketAddress’.</td>
<td align="left">IOException<br/>ClosedChannelException</td>
</tr>
<tr>
<td align="center"><strong>connect(SocketAddress remote, A attachment, CompletionHandler&lt;Void,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Connects this channel.  <p> This method initiates an operation to connect this channel. The ‘handler’ parameter is a completion handler that is invoked when the connection is successfully established or connection cannot be established. If the connection cannot be established then the channel is closed.  <p> This method performs exactly the same security checks as the ‘java.net.Socket’ class.  That is, if a security manager has been installed then this method verifies that its ‘java.lang.SecurityManager#checkConnect checkConnect’ method permits connecting to the address and port number of the given remote endpoint.</td>
<td align="left">ShutdownChannelGroupException<br/>UnresolvedAddressException<br/>SecurityException<br/>UnsupportedAddressTypeException<br/>ConnectionPendingException<br/>AlreadyConnectedException</td>
</tr>
<tr>
<td align="center"><strong>connect(SocketAddress remote): Future<Void></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Connects this channel.  <p> This method initiates an operation to connect this channel. This method behaves in exactly the same manner as the ‘#connect(SocketAddress, Object, CompletionHandler)’ method except that instead of specifying a completion handler, this method returns a ‘Future’ representing the pending result. The ‘Future’’s ‘Future#get() get’ method returns ‘null’ on successful completion.</td>
<td align="left">UnresolvedAddressException<br/>SecurityException<br/>UnsupportedAddressTypeException<br/>ConnectionPendingException<br/>AlreadyConnectedException</td>
</tr>
<tr>
<td align="center"><strong>read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Reads a sequence of bytes from this channel into the given buffer.  <p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The ‘handler’ parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or ‘-1’ if no bytes could be read because the channel has reached end-of-stream.  <p> If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception ‘InterruptedByTimeoutException’. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.  <p> Otherwise this method works in the same manner as the ‘AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)’ method.</td>
<td align="left">ShutdownChannelGroupException<br/>NotYetConnectedException<br/>ReadPendingException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ShutdownChannelGroupException<br/>NotYetConnectedException<br/>ReadPendingException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>read(ByteBuffer dst): Future<Integer></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
<td align="left">NotYetConnectedException<br/>ReadPendingException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>read(ByteBuffer[] dsts, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Long,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Reads a sequence of bytes from this channel into a subsequence of the given buffers. This operation, sometimes called a <em>scattering read</em>, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The ‘handler’ parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or ‘-1’ if no bytes could be read because the channel has reached end-of-stream.  <p> This method initiates a read of up to <i>r</i> bytes from this channel, where <i>r</i> is the total number of bytes remaining in the specified subsequence of the given buffer array, that is,  <blockquote><pre> dsts[offset].remaining() + dsts[offset+1].remaining() + ... + dsts[offset+length-1].remaining()</pre></blockquote>  at the moment that the read is attempted.  <p> Suppose that a byte sequence of length <i>n</i> is read, where <tt>0</tt>&amp;nbsp;<tt>&lt;</tt>&amp;nbsp;<i>n</i>&amp;nbsp;<tt>&lt;&#x3D;</tt>&amp;nbsp;<i>r</i>. Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence are transferred into buffer <tt>dsts[offset]</tt>, up to the next <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence is transferred into the given buffers.  As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer’s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I&#x2F;O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I&#x2F;O operation is performed with the maximum number of buffers allowed by the operating system.  <p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception ‘InterruptedByTimeoutException’. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</td>
<td align="left">ShutdownChannelGroupException<br/>ReadPendingException<br/>IllegalArgumentException<br/>NotYetConnectedException<br/>IndexOutOfBoundsException</td>
</tr>
<tr>
<td align="center"><strong>write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Writes a sequence of bytes to this channel from the given buffer.  <p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The ‘handler’ parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written.  <p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception ‘InterruptedByTimeoutException’. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.  <p> Otherwise this method works in the same manner as the ‘AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)’ method.</td>
<td align="left">ShutdownChannelGroupException<br/>WritePendingException<br/>NotYetConnectedException</td>
</tr>
<tr>
<td align="center"><strong>write(ByteBuffer src, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">ShutdownChannelGroupException<br/>WritePendingException<br/>NotYetConnectedException</td>
</tr>
<tr>
<td align="center"><strong>write(ByteBuffer src): Future<Integer></strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left"></td>
<td align="left">WritePendingException<br/>NotYetConnectedException</td>
</tr>
<tr>
<td align="center"><strong>write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Long,? super A&gt; handler): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a <em>gathering write</em>, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The ‘handler’ parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written.  <p> This method initiates a write of up to <i>r</i> bytes to this channel, where <i>r</i> is the total number of bytes remaining in the specified subsequence of the given buffer array, that is,  <blockquote><pre> srcs[offset].remaining() + srcs[offset+1].remaining() + ... + srcs[offset+length-1].remaining()</pre></blockquote>  at the moment that the write is attempted.  <p> Suppose that a byte sequence of length <i>n</i> is written, where <tt>0</tt>&amp;nbsp;<tt>&lt;</tt>&amp;nbsp;<i>n</i>&amp;nbsp;<tt>&lt;&#x3D;</tt>&amp;nbsp;<i>r</i>. Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence are written from buffer <tt>srcs[offset]</tt>, up to the next <tt>srcs[offset+1].remaining()</tt> bytes are written from buffer <tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is written.  As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer’s limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I&#x2F;O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I&#x2F;O operation is performed with the maximum number of buffers allowed by the operating system.  <p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception ‘InterruptedByTimeoutException’. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</td>
<td align="left">ShutdownChannelGroupException<br/>WritePendingException<br/>NotYetConnectedException<br/>IndexOutOfBoundsException</td>
</tr>
<tr>
<td align="center"><strong>getLocalAddress(): SocketAddress</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="left">‘inheritDoc’ <p> If there is a security manager set, its ‘checkConnect’ method is called with the local address and ‘-1’ as its arguments to see if the operation is allowed. If the operation is not allowed, a ‘SocketAddress’ representing the ‘java.net.InetAddress#getLoopbackAddress loopback’ address and the local port of the channel’s socket is returned.</td>
<td align="left">IOException<br/>ClosedChannelException</td>
</tr>
</tbody></table>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
