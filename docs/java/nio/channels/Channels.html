<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/nio/channels/Channels.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.nio.channels.Channels</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Channels()</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>checkNotNull(Object o, String name): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>writeFullyImpl(WritableByteChannel ch, ByteBuffer bb): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Write all remaining bytes in buffer to the given channel. If the channel is selectable then it must be configured blocking.</td>
<td align="left">IOException</td>
</tr>
<tr>
<td align="center"><strong>writeFully(WritableByteChannel ch, ByteBuffer bb): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Write all remaining bytes in buffer to the given channel.</td>
<td align="left">IOException<br/>IllegalBlockingModeException</td>
</tr>
<tr>
<td align="center"><strong>newInputStream(ReadableByteChannel ch): InputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a stream that reads bytes from the given channel.  <p> The <tt>read</tt> methods of the resulting stream will throw an ‘IllegalBlockingModeException’ if invoked while the underlying channel is in non-blocking mode.  The stream will not be buffered, and it will not support the ‘InputStream#mark mark’ or ‘InputStream#reset reset’ methods.  The stream will be safe for access by multiple concurrent threads.  Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newOutputStream(final WritableByteChannel ch): OutputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a stream that writes bytes to the given channel.  <p> The <tt>write</tt> methods of the resulting stream will throw an ‘IllegalBlockingModeException’ if invoked while the underlying channel is in non-blocking mode.  The stream will not be buffered.  The stream will be safe for access by multiple concurrent threads.  Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newInputStream(final AsynchronousByteChannel ch): InputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a stream that reads bytes from the given channel.  <p> The stream will not be buffered, and it will not support the ‘InputStream#mark mark’ or ‘InputStream#reset reset’ methods.  The stream will be safe for access by multiple concurrent threads.  Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newOutputStream(final AsynchronousByteChannel ch): OutputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a stream that writes bytes to the given channel.  <p> The stream will not be buffered. The stream will be safe for access by multiple concurrent threads.  Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newChannel(final InputStream in): ReadableByteChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a channel that reads bytes from the given stream.  <p> The resulting channel will not be buffered; it will simply redirect its I&#x2F;O operations to the given stream.  Closing the channel will in turn cause the stream to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newChannel(final OutputStream out): WritableByteChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a channel that writes bytes to the given stream.  <p> The resulting channel will not be buffered; it will simply redirect its I&#x2F;O operations to the given stream.  Closing the channel will in turn cause the stream to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newReader(ReadableByteChannel ch, CharsetDecoder dec, int minBufferCap): Reader</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a reader that decodes bytes from the given channel using the given decoder.  <p> The resulting stream will contain an internal input buffer of at least <tt>minBufferCap</tt> bytes.  The stream’s <tt>read</tt> methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an ‘IllegalBlockingModeException’ will be thrown.  The resulting stream will not otherwise be buffered, and it will not support the ‘Reader#mark mark’ or ‘Reader#reset reset’ methods. Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newReader(ReadableByteChannel ch, String csName): Reader</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a reader that decodes bytes from the given channel according to the named charset.  <p> An invocation of this method of the form  <blockquote><pre> Channels.newReader(ch, csname)</pre></blockquote>  behaves in exactly the same way as the expression  <blockquote><pre> Channels.newReader(ch, Charset.forName(csName) .newDecoder(), -1);</pre></blockquote></td>
<td align="left">UnsupportedCharsetException</td>
</tr>
<tr>
<td align="center"><strong>newWriter(final WritableByteChannel ch, final CharsetEncoder enc, final int minBufferCap): Writer</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a writer that encodes characters using the given encoder and writes the resulting bytes to the given channel.  <p> The resulting stream will contain an internal output buffer of at least <tt>minBufferCap</tt> bytes.  The stream’s <tt>write</tt> methods will, as needed, flush the buffer by writing bytes to the underlying channel; if the channel is in non-blocking mode when bytes are to be written then an ‘IllegalBlockingModeException’ will be thrown. The resulting stream will not otherwise be buffered.  Closing the stream will in turn cause the channel to be closed.  </p></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newWriter(WritableByteChannel ch, String csName): Writer</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a writer that encodes characters according to the named charset and writes the resulting bytes to the given channel.  <p> An invocation of this method of the form  <blockquote><pre> Channels.newWriter(ch, csname)</pre></blockquote>  behaves in exactly the same way as the expression  <blockquote><pre> Channels.newWriter(ch, Charset.forName(csName) .newEncoder(), -1);</pre></blockquote></td>
<td align="left">UnsupportedCharsetException</td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Channels-ReadableByteChannelImpl"><a href="#Channels-ReadableByteChannelImpl" class="headerlink" title="Channels$ReadableByteChannelImpl"></a><a href="./Channels$ReadableByteChannelImpl.html">Channels$ReadableByteChannelImpl</a></h3><h3 id="Channels-WritableByteChannelImpl"><a href="#Channels-WritableByteChannelImpl" class="headerlink" title="Channels$WritableByteChannelImpl"></a><a href="./Channels$WritableByteChannelImpl.html">Channels$WritableByteChannelImpl</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
