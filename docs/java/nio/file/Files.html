<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/nio/file/Files.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.nio.file.Files</strong></td>
<td align="center">class</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>BUFFER_SIZE: int</strong></td>
<td align="center">8192</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>MAX_BUFFER_SIZE: int</strong></td>
<td align="center">Integer.MAX_VALUE - 8</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit</td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Files()</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>provider(Path path): FileSystemProvider</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the ‘FileSystemProvider’ to delegate to.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>asUncheckedRunnable(Closeable c): Runnable</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Convert a Closeable to a Runnable by converting checked IOException to UncheckedIOException</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>newInputStream(Path path, OpenOption… options): InputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a file, returning an input stream to read from the file. The stream will not be buffered, and is not required to support the ‘InputStream#mark mark’ or ‘InputStream#reset reset’ methods. The stream will be safe for access by multiple concurrent threads. Reading commences at the beginning of the file. Whether the returned stream is <i>asynchronously closeable</i> and&#x2F;or <i>interruptible</i> is highly file system provider specific and therefore not specified.  <p> The ‘options’ parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the ‘StandardOpenOption#READ READ’ option. In addition to the ‘READ’ option, an implementation may also support additional implementation specific options.</td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>newOutputStream(Path path, OpenOption… options): OutputStream</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens or creates a file, returning an output stream that may be used to write bytes to the file. The resulting stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Whether the returned stream is <i>asynchronously closeable</i> and&#x2F;or <i>interruptible</i> is highly file system provider specific and therefore not specified.  <p> This method opens or creates a file in exactly the manner specified by the ‘#newByteChannel(Path,Set,FileAttribute[]) newByteChannel’ method with the exception that the ‘StandardOpenOption#READ READ’ option may not be present in the array of options. If no options are present then this method works as if the ‘StandardOpenOption#CREATE CREATE’, ‘StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING’, and ‘StandardOpenOption#WRITE WRITE’ options are present. In other words, it opens the file for writing, creating the file if it doesn’t exist, or initially truncating an existing ‘#isRegularFile regular-file’ to a size of ‘0’ if it exists.  <p> <b>Usage Examples:</b> <pre> Path path = ...    OutputStream out = Files.newOutputStream(path);   out = Files.newOutputStream(path, APPEND);   out = Files.newOutputStream(path, CREATE, APPEND);   out = Files.newOutputStream(path, CREATE_NEW); </pre></td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>newByteChannel(Path path, Set&lt;? extends OpenOption&gt; options, FileAttribute&lt;?&gt;… attrs): SeekableByteChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens or creates a file, returning a seekable byte channel to access the file.  <p> The ‘options’ parameter determines how the file is opened. The ‘StandardOpenOption#READ READ’ and ‘StandardOpenOption#WRITE WRITE’ options determine if the file should be opened for reading and&#x2F;or writing. If neither option (or the ‘StandardOpenOption#APPEND APPEND’ option) is present then the file is opened for reading. By default reading or writing commence at the beginning of the file.  <p> In the addition to ‘READ’ and ‘WRITE’, the following options may be present:  <table border=1 cellpadding=5 summary="Options"> <tr> <th>Option</th> <th>Description</th> </tr> <tr> <td> ‘StandardOpenOption#APPEND APPEND’ </td> <td> If this option is present then the file is opened for writing and each invocation of the channel’s ‘write’ method first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. This option may not be used in conjunction with the ‘READ’ or ‘TRUNCATE_EXISTING’ options. </td> </tr> <tr> <td> ‘StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING’ </td> <td> If this option is present then the existing file is truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading. </td> </tr> <tr> <td> ‘StandardOpenOption#CREATE_NEW CREATE_NEW’ </td> <td> If this option is present then a new file is created, failing if the file already exists or is a symbolic link. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading. </td> </tr> <tr> <td > ‘StandardOpenOption#CREATE CREATE’ </td> <td> If this option is present then an existing file is opened if it exists, otherwise a new file is created. This option is ignored if the ‘CREATE_NEW’ option is also present or the file is opened only for reading. </td> </tr> <tr> <td > ‘StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE’ </td> <td> When this option is present then the implementation makes a <em>best effort</em> attempt to delete the file when closed by the ‘SeekableByteChannel#close close’ method. If the ‘close’ method is not invoked then a <em>best effort</em> attempt is made to delete the file when the Java virtual machine terminates. </td> </tr> <tr> <td>‘StandardOpenOption#SPARSE SPARSE’ </td> <td> When creating a new file this option is a <em>hint</em> that the new file will be sparse. This option is ignored when not creating a new file. </td> </tr> <tr> <td> ‘StandardOpenOption#SYNC SYNC’ </td> <td> Requires that every update to the file’s content or metadata be written synchronously to the underlying storage device. (see <a href="package-summary.html#integrity"> Synchronized I&#x2F;O file integrity</a>). </td> </tr> <tr> <td> ‘StandardOpenOption#DSYNC DSYNC’ </td> <td> Requires that every update to the file’s content be written synchronously to the underlying storage device. (see <a href="package-summary.html#integrity"> Synchronized I&#x2F;O file integrity</a>). </td> </tr> </table>  <p> An implementation may also support additional implementation specific options.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when a new file is created.  <p> In the case of the default provider, the returned seekable byte channel is a ‘java.nio.channels.FileChannel’.  <p> <b>Usage Examples:</b> <pre> Path path = ...   ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));    WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));   'FileAttribute<Set<PosixFilePermission>> perms = ...' SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms); </pre></td>
<td align="left">IllegalArgumentException<br/>SecurityException<br/>FileAlreadyExistsException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>newByteChannel(Path path, OpenOption… options): SeekableByteChannel</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens or creates a file, returning a seekable byte channel to access the file.  <p> This method opens or creates a file in exactly the manner specified by the ‘#newByteChannel(Path,Set,FileAttribute[]) newByteChannel’ method.</td>
<td align="left">IllegalArgumentException<br/>SecurityException<br/>FileAlreadyExistsException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>newDirectoryStream(Path dir): DirectoryStream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a directory, returning a ‘DirectoryStream’ to iterate over all entries in the directory. The elements returned by the directory stream’s ‘DirectoryStream#iterator iterator’ are of type ‘Path’, each one representing an entry in the directory. The ‘Path’ objects are obtained as if by ‘Path#resolve(Path) resolving’ the name of the directory entry against ‘dir’.  <p> When not using the try-with-resources construct, then directory stream’s ‘close’ method should be invoked after iteration is completed so as to free any resources held for the open directory.  <p> When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a ‘SecureDirectoryStream’.</td>
<td align="left">NotDirectoryException<br/>IOException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>newDirectoryStream(Path dir, String glob): DirectoryStream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a directory, returning a ‘DirectoryStream’ to iterate over the entries in the directory. The elements returned by the directory stream’s ‘DirectoryStream#iterator iterator’ are of type ‘Path’, each one representing an entry in the directory. The ‘Path’ objects are obtained as if by ‘Path#resolve(Path) resolving’ the name of the directory entry against ‘dir’. The entries returned by the iterator are filtered by matching the ‘String’ representation of their file names against the given <em>globbing</em> pattern.  <p> For example, suppose we want to iterate over the files ending with “.java” in a directory: <pre> Path dir = ... try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, "*.java")) { : } </pre>  <p> The globbing pattern is specified by the ‘FileSystem#getPathMatcher getPathMatcher’ method.  <p> When not using the try-with-resources construct, then directory stream’s ‘close’ method should be invoked after iteration is completed so as to free any resources held for the open directory.  <p> When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a ‘SecureDirectoryStream’.</td>
<td align="left">NotDirectoryException<br/>IOException<br/>java.util.regex.PatternSyntaxException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>newDirectoryStream(Path dir, DirectoryStream.Filter&lt;? super Path&gt; filter): DirectoryStream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a directory, returning a ‘DirectoryStream’ to iterate over the entries in the directory. The elements returned by the directory stream’s ‘DirectoryStream#iterator iterator’ are of type ‘Path’, each one representing an entry in the directory. The ‘Path’ objects are obtained as if by ‘Path#resolve(Path) resolving’ the name of the directory entry against ‘dir’. The entries returned by the iterator are filtered by the given ‘DirectoryStream.Filter filter’.  <p> When not using the try-with-resources construct, then directory stream’s ‘close’ method should be invoked after iteration is completed so as to free any resources held for the open directory.  <p> Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the ‘Iterator#hasNext() hasNext’ or ‘Iterator#next() next’ method. Where an ‘IOException’ is thrown, it results in the ‘hasNext’ or ‘next’ method throwing a ‘DirectoryIteratorException’ with the ‘IOException’ as the cause.  <p> When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a ‘SecureDirectoryStream’.  <p> <b>Usage Example:</b> Suppose we want to iterate over the files in a directory that are larger than 8K. <pre> DirectoryStream.Filter&lt;Path&gt; filter = new DirectoryStream.Filter&lt;Path&gt;() { public boolean accept(Path file) throws IOException { return (Files.size(file) &gt; 8192L); } }; Path dir = ... try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) { : } </pre></td>
<td align="left">NotDirectoryException<br/>IOException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>createFile(Path path, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new and empty file, failing if the file already exists. The check for the existence of the file and the creation of the new file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the directory.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when creating the file. Each attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</td>
<td align="left">SecurityException<br/>IOException<br/>FileAlreadyExistsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new directory. The check for the existence of the file and the creation of the directory if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the directory. The ‘#createDirectories createDirectories’ method should be used where it is required to create all nonexistent parent directories first.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when creating the directory. Each attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</td>
<td align="left">SecurityException<br/>IOException<br/>FileAlreadyExistsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>createDirectories(Path dir, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a directory by creating all nonexistent parent directories first. Unlike the ‘#createDirectory createDirectory’ method, an exception is not thrown if the directory could not be created because it already exists.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when creating the nonexistent directories. Each file attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.  <p> If this method fails, then it may do so after creating some, but not all, of the parent directories.</td>
<td align="left">SecurityException<br/>IOException<br/>FileAlreadyExistsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>createAndCheckIsDirectory(Path dir, FileAttribute&lt;?&gt;… attrs): void</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Used by createDirectories to attempt to create a directory. A no-op if the directory already exists.</td>
<td align="left">IOException</td>
</tr>
<tr>
<td align="center"><strong>createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name. The resulting ‘Path’ is associated with the same ‘FileSystem’ as the given directory.  <p> The details as to how the name of the file is constructed is implementation dependent and therefore not specified. Where possible the ‘prefix’ and ‘suffix’ are used to construct candidate names in the same manner as the ‘java.io.File#createTempFile(String,String,File)’ method.  <p> As with the ‘File.createTempFile’ methods, this method is only part of a temporary-file facility. Where used as a <em>work files</em>, the resulting file may be opened using the ‘StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE’ option so that the file is deleted when the appropriate ‘close’ method is invoked. Alternatively, a ‘Runtime#addShutdownHook shutdown-hook’, or the ‘java.io.File#deleteOnExit’ mechanism may be used to delete the file automatically.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when creating the file. Each attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. When no file attributes are specified, then the resulting file may have more restrictive access permissions to files created by the ‘java.io.File#createTempFile(String,String,File)’ method.</td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name. The resulting ‘Path’ is associated with the default ‘FileSystem’.  <p> This method works in exactly the manner specified by the ‘#createTempFile(Path,String,String,FileAttribute[])’ method for the case that the ‘dir’ parameter is the temporary-file directory.</td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>createTempDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new directory in the specified directory, using the given prefix to generate its name.  The resulting ‘Path’ is associated with the same ‘FileSystem’ as the given directory.  <p> The details as to how the name of the directory is constructed is implementation dependent and therefore not specified. Where possible the ‘prefix’ is used to construct candidate names.  <p> As with the ‘createTempFile’ methods, this method is only part of a temporary-file facility. A ‘Runtime#addShutdownHook shutdown-hook’, or the ‘java.io.File#deleteOnExit’ mechanism may be used to delete the directory automatically.  <p> The ‘attrs’ parameter is optional ‘FileAttribute file-attributes’ to set atomically when creating the directory. Each attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>createTempDirectory(String prefix, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new directory in the default temporary-file directory, using the given prefix to generate its name. The resulting ‘Path’ is associated with the default ‘FileSystem’.  <p> This method works in exactly the manner specified by ‘#createTempDirectory(Path,String,FileAttribute[])’ method for the case that the ‘dir’ parameter is the temporary-file directory.</td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>createSymbolicLink(Path link, Path target, FileAttribute&lt;?&gt;… attrs): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a symbolic link to a target <i>(optional operation)</i>.  <p> The ‘target’ parameter is the target of the link. It may be an ‘Path#isAbsolute absolute’ or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.  <p> The ‘attrs’ parameter is optional ‘FileAttribute attributes’ to set atomically when creating the link. Each attribute is identified by its ‘FileAttribute#name name’. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.  <p> Where symbolic links are supported, but the underlying ‘FileStore’ does not support symbolic links, then this may fail with an ‘IOException’. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw ‘IOException’.</td>
<td align="left">SecurityException<br/>IOException<br/>FileAlreadyExistsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>createLink(Path link, Path existing): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a new link (directory entry) for an existing file <i>(optional operation)</i>.  <p> The ‘link’ parameter locates the directory entry to create. The ‘existing’ parameter is the path to an existing file. This method creates a new directory entry for the file so that it can be accessed using ‘link’ as the path. On some file systems this is known as creating a “hard link”. Whether the file attributes are maintained for the file or for each directory entry is file system specific and therefore not specified. Typically, a file system requires that all links (directory entries) for a file be on the same file system. Furthermore, on some platforms, the Java virtual machine may require to be started with implementation specific privileges to create hard links or to create links to directories.</td>
<td align="left">SecurityException<br/>IOException<br/>FileAlreadyExistsException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>delete(Path path): void</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Deletes a file.  <p> An implementation may require to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations.  If the file is a symbolic link then the symbolic link itself, not the final target of the link, is deleted.  <p> If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the ‘#walkFileTree walkFileTree’ method to delete a directory and all entries in the directory, or an entire <i>file-tree</i> where required.  <p> On some operating systems it may not be possible to remove a file when it is open and in use by this Java virtual machine or other programs.</td>
<td align="left">NoSuchFileException<br/>IOException<br/>DirectoryNotEmptyException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>deleteIfExists(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Deletes a file if it exists.  <p> As with the ‘#delete(Path) delete(Path)’ method, an implementation may need to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations.  If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted.  <p> If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.  <p> On some operating systems it may not be possible to remove a file when it is open and in use by this Java virtual machine or other programs.</td>
<td align="left">SecurityException<br/>IOException<br/>DirectoryNotEmptyException</td>
</tr>
<tr>
<td align="center"><strong>copy(Path source, Path target, CopyOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Copy a file to a target file.  <p> This method copies a file to the target file with the ‘options’ parameter specifying how the copy is performed. By default, the copy fails if the target file already exists or is a symbolic link, except if the source and target are the ‘#isSameFile same’ file, in which case the method completes without copying the file. File attributes are not required to be copied to the target file. If symbolic links are supported, and the file is a symbolic link, then the final target of the link is copied. If the file is a directory then it creates an empty directory in the target location (entries in the directory are not copied). This method can be used with the ‘#walkFileTree walkFileTree’ method to copy a directory and all entries in the directory, or an entire <i>file-tree</i> where required.  <p> The ‘options’ parameter may include any of the following:  <table border=1 cellpadding=5 summary=""> <tr> <th>Option</th> <th>Description</th> </tr> <tr> <td> ‘StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING’ </td> <td> If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced. </td> </tr> <tr> <td> ‘StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES’ </td> <td> Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the ‘BasicFileAttributes#lastModifiedTime last-modified-time’ is copied to the target file if supported by both the source and target file stores. Copying of file timestamps may result in precision loss. </td> </tr> <tr> <td> ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ </td> <td> Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link. In other words, the ‘COPY_ATTRIBUTES’ option may be ignored when copying a symbolic link. </td> </tr> </table>  <p> An implementation of this interface may support additional implementation specific options.  <p> Copying a file is not an atomic operation. If an ‘IOException’ is thrown, then it is possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the ‘REPLACE_EXISTING’ option is specified and the target file exists, then the target file is replaced. The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities.  <p> <b>Usage Example:</b> Suppose we want to copy a file into a directory, giving it the same file name as the source file: <pre> Path source = ... Path newdir = ... Files.copy(source, newdir.resolve(source.getFileName()); </pre></td>
<td align="left">SecurityException<br/>UnsupportedOperationException<br/>IOException<br/>DirectoryNotEmptyException<br/>FileAlreadyExistsException</td>
</tr>
<tr>
<td align="center"><strong>move(Path source, Path target, CopyOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Move or rename a file to a target file.  <p> By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the ‘#isSameFile same’ file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory.  For example, renaming a directory on the same ‘FileStore’ will usually not require moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an ‘IOException’). To move a <i>file tree</i> may involve copying rather than moving directories and this can be done using the ‘#copy copy’ method in conjunction with the ‘#walkFileTree Files.walkFileTree’ utility method.  <p> The ‘options’ parameter may include any of the following:  <table border=1 cellpadding=5 summary=""> <tr> <th>Option</th> <th>Description</th> </tr> <tr> <td> ‘StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING’ </td> <td> If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced. </td> </tr> <tr> <td> ‘StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE’ </td> <td> The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an ‘IOException’. If the move cannot be performed as an atomic file system operation then ‘AtomicMoveNotSupportedException’ is thrown. This can arise, for example, when the target location is on a different ‘FileStore’ and would require that the file be copied, or target location is associated with a different provider to this object. </td> </table>  <p> An implementation of this interface may support additional implementation specific options.  <p> Moving a file will copy the ‘BasicFileAttributes#lastModifiedTime last-modified-time’ to the target file if supported by both source and target file stores. Copying of file timestamps may result in precision loss. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and an ‘IOException’ is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file.  <p> <b>Usage Examples:</b> Suppose we want to rename a file to “newname”, keeping the file in the same directory: <pre> Path source = ... Files.move(source, source.resolveSibling("newname")); </pre> Alternatively, suppose we want to move a file to new directory, keeping the same file name, and replacing any existing file of that name in the directory: <pre> Path source = ... Path newdir = ... Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING); </pre></td>
<td align="left">SecurityException<br/>AtomicMoveNotSupportedException<br/>UnsupportedOperationException<br/>IOException<br/>DirectoryNotEmptyException<br/>FileAlreadyExistsException</td>
</tr>
<tr>
<td align="center"><strong>readSymbolicLink(Path link): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads the target of a symbolic link <i>(optional operation)</i>.  <p> If the file system supports <a href="package-summary.html#links">symbolic links</a> then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned ‘Path’ object will be associated with the same file system as ‘link’.</td>
<td align="left">SecurityException<br/>IOException<br/>NotLinkException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getFileStore(Path path): FileStore</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the ‘FileStore’ representing the file store where a file is located.  <p> Once a reference to the ‘FileStore’ is obtained it is implementation specific if operations on the returned ‘FileStore’, or ‘FileStoreAttributeView’ objects obtained from it, continue to depend on the existence of the file. In particular the behavior is not defined for the case that the file is deleted or moved to a different file store.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>isSameFile(Path path, Path path2): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests if two paths locate the same file.  <p> If both ‘Path’ objects are ‘Path#equals(Object) equal’ then this method returns ‘true’ without checking if the file exists. If the two ‘Path’ objects are associated with different providers then this method returns ‘false’. Otherwise, this method checks if both ‘Path’ objects locate the same file, and depending on the implementation, may require to open or access both files.  <p> If the file system and files remain static, then this method implements an equivalence relation for non-null ‘Paths’. <ul> <li>It is <i>reflexive</i>: for ‘Path’ ‘f’, ‘isSameFile(f,f)’ should return ‘true’. <li>It is <i>symmetric</i>: for two ‘Paths’ ‘f’ and ‘g’, ‘isSameFile(f,g)’ will equal ‘isSameFile(g,f)’. <li>It is <i>transitive</i>: for three ‘Paths’ ‘f’, ‘g’, and ‘h’, if ‘isSameFile(f,g)’ returns ‘true’ and ‘isSameFile(g,h)’ returns ‘true’, then ‘isSameFile(f,h)’ will return return ‘true’. </ul></td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>isHidden(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tells whether or not a file is considered <em>hidden</em>. The exact definition of hidden is platform or provider dependent. On UNIX for example a file is considered to be hidden if its name begins with a period character (‘.’). On Windows a file is considered hidden if it isn’t a directory and the DOS ‘DosFileAttributes#isHidden hidden’ attribute is set.  <p> Depending on the implementation this method may require to access the file system to determine if the file is considered hidden.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>checkWrite(String) checkWrite}</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setAttribute(Path path, String attribute, Object value, LinkOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left">IOException</td>
</tr>
<tr>
<td align="center"><strong>getAttribute(Path path, String attribute, LinkOption… options): Object</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads the value of a file attribute.  <p> The ‘attribute’ parameter identifies the attribute to be read and takes the form: <blockquote> [<i>view-name</i><b>:</b>]<i>attribute-name</i> </blockquote> where square brackets […] delineate an optional component and the character ‘’:’’ stands for itself.  <p> <i>view-name</i> is the ‘FileAttributeView#name name’ of a ‘FileAttributeView’ that identifies a set of file attributes. If not specified then it defaults to ‘“basic”‘, the name of the file attribute view that identifies the basic set of file attributes common to many file systems. <i>attribute-name</i> is the name of the attribute.  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.  <p> <b>Usage Example:</b> Suppose we require the user ID of the file owner on a system that supports a “‘unix’” view: <pre> Path path = ... int uid = (Integer)Files.getAttribute(path, "unix:uid"); </pre></td>
<td align="left">SecurityException<br/>IllegalArgumentException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>readAttributes(Path path, String attributes, LinkOption… options): Map&lt;String,Object&gt;</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads a set of file attributes as a bulk operation.  <p> The ‘attributes’ parameter identifies the attributes to be read and takes the form: <blockquote> [<i>view-name</i><b>:</b>]<i>attribute-list</i> </blockquote> where square brackets […] delineate an optional component and the character ‘’:’’ stands for itself.  <p> <i>view-name</i> is the ‘FileAttributeView#name name’ of a ‘FileAttributeView’ that identifies a set of file attributes. If not specified then it defaults to ‘“basic”‘, the name of the file attribute view that identifies the basic set of file attributes common to many file systems.  <p> The <i>attribute-list</i> component is a comma separated list of zero or more names of attributes to read. If the list contains the value ‘“<em>“‘ then all attributes are read. Attributes that are not supported are ignored and will not be present in the returned map. It is implementation specific if all attributes are read as an atomic operation with respect to other file system operations.  <p> The following examples demonstrate possible values for the ‘attributes’ parameter:  <blockquote> <table border="0" summary="Possible values"> <tr> <td> ‘“</em>“‘ </td> <td> Read all ‘BasicFileAttributes basic-file-attributes’. </td> </tr> <tr> <td> ‘“size,lastModifiedTime,lastAccessTime”‘ </td> <td> Reads the file size, last modified time, and last access time attributes. </td> </tr> <tr> <td> ‘“posix:*”‘ </td> <td> Read all ‘PosixFileAttributes POSIX-file-attributes’. </td> </tr> <tr> <td> ‘“posix:permissions,owner,size”‘ </td> <td> Reads the POSX file permissions, owner, and file size. </td> </tr> </table> </blockquote>  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.</td>
<td align="left">SecurityException<br/>IllegalArgumentException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getPosixFilePermissions(Path path, LinkOption… options): Set<PosixFilePermission></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a file’s POSIX file permissions.  <p> The ‘path’ parameter is associated with a ‘FileSystem’ that supports the ‘PosixFileAttributeView’. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.</td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>setPosixFilePermissions(Path path, Set&lt;PosixFilePermission&gt; perms): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Sets a file’s POSIX permissions.  <p> The ‘path’ parameter is associated with a ‘FileSystem’ that supports the ‘PosixFileAttributeView’. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.</td>
<td align="left">SecurityException<br/>ClassCastException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getOwner(Path path, LinkOption… options): UserPrincipal</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the owner of a file.  <p> The ‘path’ parameter is associated with a file system that supports ‘FileOwnerAttributeView’. This file attribute view provides access to a file attribute that is the owner of the file.</td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>setOwner(Path path, UserPrincipal owner): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Updates the file owner.  <p> The ‘path’ parameter is associated with a file system that supports ‘FileOwnerAttributeView’. This file attribute view provides access to a file attribute that is the owner of the file.  <p> <b>Usage Example:</b> Suppose we want to make “joe” the owner of a file: <pre> Path path = ... UserPrincipalLookupService lookupService = provider(path).getUserPrincipalLookupService(); UserPrincipal joe = lookupService.lookupPrincipalByName("joe"); Files.setOwner(path, joe); </pre></td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>isSymbolicLink(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is a symbolic link.  <p> Where it is required to distinguish an I&#x2F;O exception from the case that the file is not a symbolic link then the file attributes can be read with the ‘#readAttributes(Path,Class,LinkOption[]) readAttributes’ method and the file type tested with the ‘BasicFileAttributes#isSymbolicLink’ method.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isDirectory(Path path, LinkOption… options): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is a directory.  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.  <p> Where it is required to distinguish an I&#x2F;O exception from the case that the file is not a directory then the file attributes can be read with the ‘#readAttributes(Path,Class,LinkOption[]) readAttributes’ method and the file type tested with the ‘BasicFileAttributes#isDirectory’ method.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isRegularFile(Path path, LinkOption… options): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is a regular file with opaque content.  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.  <p> Where it is required to distinguish an I&#x2F;O exception from the case that the file is not a regular file then the file attributes can be read with the ‘#readAttributes(Path,Class,LinkOption[]) readAttributes’ method and the file type tested with the ‘BasicFileAttributes#isRegularFile’ method.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>getLastModifiedTime(Path path, LinkOption… options): FileTime</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a file’s last modified time.  <p> The ‘options’ array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>setLastModifiedTime(Path path, FileTime time): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Updates a file’s last modified time attribute. The file time is converted to the epoch and precision supported by the file system. Converting from finer to coarser granularities result in precision loss. The behavior of this method when attempting to set the last modified time when it is not supported by the file system or is outside the range supported by the underlying file store is not defined. It may or not fail by throwing an ‘IOException’.  <p> <b>Usage Example:</b> Suppose we want to set the last modified time to the current time: <pre> Path path = ... FileTime now = FileTime.fromMillis(System.currentTimeMillis()); Files.setLastModifiedTime(path, now); </pre></td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>size(Path path): long</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the size of a file (in bytes). The size may differ from the actual size on the file system due to compression, support for sparse files, or other reasons. The size of files that are not ‘#isRegularFile regular’ files is implementation specific and therefore unspecified.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>followLinks(LinkOption… options): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns ‘false’ if NOFOLLOW_LINKS is present.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>exists(Path path, LinkOption… options): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file exists.  <p> The ‘options’ parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.  <p> Note that the result of this method is immediately outdated. If this method indicates the file exists then there is no guarantee that a subsequence access will succeed. Care should be taken when using this method in security sensitive applications.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>notExists(Path path, LinkOption… options): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether the file located by this path does not exist. This method is intended for cases where it is required to take action when it can be confirmed that a file does not exist.  <p> The ‘options’ parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option ‘LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS’ is present then symbolic links are not followed.  <p> Note that this method is not the complement of the ‘#exists exists’ method. Where it is not possible to determine if a file exists or not then both methods return ‘false’. As with the ‘exists’ method, the result of this method is immediately outdated. If this method indicates the file does exist then there is no guarantee that a subsequence attempt to create the file will succeed. Care should be taken when using this method in security sensitive applications.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isAccessible(Path path, AccessMode… modes): boolean</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Used by isReadbale, isWritable, isExecutable to test access to a file.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isReadable(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is readable. This method checks that a file exists and that this Java virtual machine has appropriate privileges that would allow it open the file for reading. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations.  <p> Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for reading will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isWritable(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is writable. This method checks that a file exists and that this Java virtual machine has appropriate privileges that would allow it open the file for writing. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations.  <p> Note that result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for writing will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>isExecutable(Path path): boolean</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Tests whether a file is executable. This method checks that a file exists and that this Java virtual machine has appropriate privileges to ‘Runtime#exec execute’ the file. The semantics may differ when checking access to a directory. For example, on UNIX systems, checking for execute access checks that the Java virtual machine has permission to search the directory in order to access file or subdirectories.  <p> Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. Consequently, this method may not be atomic with respect to other file system operations.  <p> Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to execute the file will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</td>
<td align="left">SecurityException</td>
</tr>
<tr>
<td align="center"><strong>walkFileTree(Path start, Set&lt;FileVisitOption&gt; options, int maxDepth, FileVisitor&lt;? super Path&gt; visitor): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Walks a file tree.  <p> This method walks a file tree rooted at a given starting file. The file tree traversal is <em>depth-first</em> with the given ‘FileVisitor’ invoked for each file encountered. File tree traversal completes when all accessible files in the tree have been visited, or a visit method returns a result of ‘FileVisitResult#TERMINATE TERMINATE’. Where a visit method terminates due an ‘IOException’, an uncaught error, or runtime exception, then the traversal is terminated and the error or exception is propagated to the caller of this method.  <p> For each file encountered this method attempts to read its ‘java.nio.file.attribute.BasicFileAttributes’. If the file is not a directory then the ‘FileVisitor#visitFile visitFile’ method is invoked with the file attributes. If the file attributes cannot be read, due to an I&#x2F;O exception, then the ‘FileVisitor#visitFileFailed visitFileFailed’ method is invoked with the I&#x2F;O exception.  <p> Where the file is a directory, and the directory could not be opened, then the ‘visitFileFailed’ method is invoked with the I&#x2F;O exception, after which, the file tree walk continues, by default, at the next <em>sibling</em> of the directory.  <p> Where the directory is opened successfully, then the entries in the directory, and their <em>descendants</em> are visited. When all entries have been visited, or an I&#x2F;O error occurs during iteration of the directory, then the directory is closed and the visitor’s ‘FileVisitor#postVisitDirectory postVisitDirectory’ method is invoked. The file tree walk then continues, by default, at the next <em>sibling</em> of the directory.  <p> By default, symbolic links are not automatically followed by this method. If the ‘options’ parameter contains the ‘FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS’ option then symbolic links are followed. When following links, and the attributes of the target cannot be read, then this method attempts to get the ‘BasicFileAttributes’ of the link. If they can be read then the ‘visitFile’ method is invoked with the attributes of the link (otherwise the ‘visitFileFailed’ method is invoked as specified above).  <p> If the ‘options’ parameter contains the ‘FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS’ option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the ‘java.nio.file.attribute.BasicFileAttributes#fileKey file-key’ of directories, or if file keys are not available, by invoking the ‘#isSameFile isSameFile’ method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I&#x2F;O error, and the ‘FileVisitor#visitFileFailed visitFileFailed’ method is invoked with an instance of ‘FileSystemLoopException’.  <p> The ‘maxDepth’ parameter is the maximum number of levels of directories to visit. A value of ‘0’ means that only the starting file is visited, unless denied by the security manager. A value of ‘Integer#MAX_VALUE MAX_VALUE’ may be used to indicate that all levels should be visited. The ‘visitFile’ method is invoked for all files, including directories, encountered at ‘maxDepth’, unless the basic file attributes cannot be read, in which case the ‘visitFileFailed’ method is invoked.  <p> If a visitor returns a result of ‘null’ then ‘NullPointerException’ is thrown.  <p> When a security manager is installed and it denies access to a file (or directory), then it is ignored and the visitor is not invoked for that file (or directory).</td>
<td align="left">SecurityException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Walks a file tree.  <p> This method works as if invoking it were equivalent to evaluating the expression: <blockquote><pre> walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor) </pre></blockquote> In other words, it does not follow symbolic links, and visits all levels of the file tree.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>newBufferedReader(Path path, Charset cs): BufferedReader</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a file for reading, returning a ‘BufferedReader’ that may be used to read text from the file in an efficient manner. Bytes from the file are decoded into characters using the specified charset. Reading commences at the beginning of the file.  <p> The ‘Reader’ methods that read from the file throw ‘IOException’ if a malformed or unmappable byte sequence is read.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>newBufferedReader(Path path): BufferedReader</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens a file for reading, returning a ‘BufferedReader’ to read text from the file in an efficient manner. Bytes from the file are decoded into characters using the ‘StandardCharsets#UTF_8 UTF-8’ ‘Charset charset’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <pre>'Files.newBufferedReader(path, StandardCharsets.UTF_8)'</pre></td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>newBufferedWriter(Path path, Charset cs, OpenOption… options): BufferedWriter</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens or creates a file for writing, returning a ‘BufferedWriter’ that may be used to write text to the file in an efficient manner. The ‘options’ parameter specifies how the the file is created or opened. If no options are present then this method works as if the ‘StandardOpenOption#CREATE CREATE’, ‘StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING’, and ‘StandardOpenOption#WRITE WRITE’ options are present. In other words, it opens the file for writing, creating the file if it doesn’t exist, or initially truncating an existing ‘#isRegularFile regular-file’ to a size of ‘0’ if it exists.  <p> The ‘Writer’ methods to write text throw ‘IOException’ if the text cannot be encoded using the specified charset.</td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>newBufferedWriter(Path path, OpenOption… options): BufferedWriter</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Opens or creates a file for writing, returning a ‘BufferedWriter’ to write text to the file in an efficient manner. The text is encoded into bytes for writing using the ‘StandardCharsets#UTF_8 UTF-8’ ‘Charset charset’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <pre>'Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)'</pre></td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>copy(InputStream source, OutputStream sink): long</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads all bytes from an input stream and writes them to an output stream.</td>
<td align="left">IOException</td>
</tr>
<tr>
<td align="center"><strong>copy(InputStream in, Path target, CopyOption… options): long</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Copies all bytes from an input stream to a file. On return, the input stream will be at end of stream.  <p> By default, the copy fails if the target file already exists or is a symbolic link. If the ‘StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING’ option is specified, and the target file already exists, then it is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link is replaced. In this release, the ‘REPLACE_EXISTING’ option is the only option required to be supported by this method. Additional options may be supported in future releases.  <p>  If an I&#x2F;O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I&#x2F;O error occurs.  <p> This method may block indefinitely reading from the input stream (or writing to the file). The behavior for the case that the input stream is <i>asynchronously closed</i> or the thread interrupted during the copy is highly input stream and file system provider specific and therefore not specified.  <p> <b>Usage example</b>: Suppose we want to capture a web page and save it to a file: <pre> Path path = ... URI u = URI.create("http: try (InputStream in = u.toURL().openStream()) { Files.copy(in, path); } </pre></td>
<td align="left">SecurityException<br/>FileAlreadyExistsException<br/>IOException<br/>DirectoryNotEmptyException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>copy(Path source, OutputStream out): long</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Copies all bytes from a file to an output stream.  <p> If an I&#x2F;O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I&#x2F;O error occurs.  <p> This method may block indefinitely writing to the output stream (or reading from the file). The behavior for the case that the output stream is <i>asynchronously closed</i> or the thread interrupted during the copy is highly output stream and file system provider specific and therefore not specified.  <p> Note that if the given output stream is ‘java.io.Flushable’ then its ‘java.io.Flushable#flush flush’ method may need to invoked after this method completes so as to flush any buffered output.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>read(InputStream source, int initialSize): byte[]</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads all the bytes from an input stream. Uses ‘initialSize’ as a hint about how many bytes the stream will have.</td>
<td align="left">OutOfMemoryError<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>readAllBytes(Path path): byte[]</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Reads all the bytes from a file. The method ensures that the file is closed when all bytes have been read or an I&#x2F;O error, or other runtime exception, is thrown.  <p> Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading in large files.</td>
<td align="left">OutOfMemoryError<br/>IOException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>readAllLines(Path path, Charset cs): List<String></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Read all lines from a file. This method ensures that the file is closed when all bytes have been read or an I&#x2F;O error, or other runtime exception, is thrown. Bytes from the file are decoded into characters using the specified charset.  <p> This method recognizes the following as line terminators: <ul> <li> <code>&#92;u000D</code> followed by <code>&#92;u000A</code>, CARRIAGE RETURN followed by LINE FEED </li> <li> <code>&#92;u000A</code>, LINE FEED </li> <li> <code>&#92;u000D</code>, CARRIAGE RETURN </li> </ul> <p> Additional Unicode line terminators may be recognized in future releases.  <p> Note that this method is intended for simple cases where it is convenient to read all lines in a single operation. It is not intended for reading in large files.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>readAllLines(Path path): List<String></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Read all lines from a file. Bytes from the file are decoded into characters using the ‘StandardCharsets#UTF_8 UTF-8’ ‘Charset charset’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <pre>'Files.readAllLines(path, StandardCharsets.UTF_8)'</pre></td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>write(Path path, byte[] bytes, OpenOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Writes bytes to a file. The ‘options’ parameter specifies how the the file is created or opened. If no options are present then this method works as if the ‘StandardOpenOption#CREATE CREATE’, ‘StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING’, and ‘StandardOpenOption#WRITE WRITE’ options are present. In other words, it opens the file for writing, creating the file if it doesn’t exist, or initially truncating an existing ‘#isRegularFile regular-file’ to a size of ‘0’. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I&#x2F;O error or other runtime exception is thrown). If an I&#x2F;O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.  <p> <b>Usage example</b>: By default the method creates a new file or overwrites an existing file. Suppose you instead want to append bytes to an existing file: <pre> Path path = ... byte[] bytes = ... Files.write(path, bytes, StandardOpenOption.APPEND); </pre></td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform’s line separator, as defined by the system property ‘line.separator’. Characters are encoded into bytes using the specified charset.  <p> The ‘options’ parameter specifies how the the file is created or opened. If no options are present then this method works as if the ‘StandardOpenOption#CREATE CREATE’, ‘StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING’, and ‘StandardOpenOption#WRITE WRITE’ options are present. In other words, it opens the file for writing, creating the file if it doesn’t exist, or initially truncating an existing ‘#isRegularFile regular-file’ to a size of ‘0’. The method ensures that the file is closed when all lines have been written (or an I&#x2F;O error or other runtime exception is thrown). If an I&#x2F;O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.</td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>write(Path path, Iterable&lt;? extends CharSequence&gt; lines, OpenOption… options): Path</strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Write lines of text to a file. Characters are encoded into bytes using the ‘StandardCharsets#UTF_8 UTF-8’ ‘Charset charset’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <pre>'Files.write(path, lines, StandardCharsets.UTF_8, options);'</pre></td>
<td align="left">SecurityException<br/>IOException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>list(Path dir): Stream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return a lazily populated ‘Stream’, the elements of which are the entries in the directory.  The listing is not recursive.  <p> The elements of the stream are ‘Path’ objects that are obtained as if by ‘Path#resolve(Path) resolving’ the name of the directory entry against ‘dir’. Some file systems maintain special links to the directory itself and the directory’s parent directory. Entries representing these links are not included.  <p> The stream is <i>weakly consistent</i>. It is thread safe but does not freeze the directory while iterating, so it may (or may not) reflect updates to the directory that occur after returning from this method.  <p> The returned stream encapsulates a ‘DirectoryStream’. If timely disposal of file system resources is required, the ‘try’-with-resources construct should be used to ensure that the stream’s ‘Stream#close close’ method is invoked after the stream operations are completed.  <p> Operating on a closed stream behaves as if the end of stream has been reached. Due to read-ahead, one or more elements may be returned after the stream has been closed.  <p> If an ‘IOException’ is thrown when accessing the directory after this method has returned, it is wrapped in an ‘UncheckedIOException’ which will be thrown from the method that caused the access to take place.</td>
<td align="left">NotDirectoryException<br/>IOException<br/>SecurityException</td>
</tr>
<tr>
<td align="center"><strong>walk(Path start, int maxDepth, FileVisitOption… options): Stream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return a ‘Stream’ that is lazily populated with ‘Path’ by walking the file tree rooted at a given starting file.  The file tree is traversed <em>depth-first</em>, the elements in the stream are ‘Path’ objects that are obtained as if by ‘Path#resolve(Path) resolving’ the relative path against ‘start’.  <p> The ‘stream’ walks the file tree as elements are consumed. The ‘Stream’ returned is guaranteed to have at least one element, the starting file itself. For each file visited, the stream attempts to read its ‘BasicFileAttributes’. If the file is a directory and can be opened successfully, entries in the directory, and their <em>descendants</em> will follow the directory in the stream as they are encountered. When all entries have been visited, then the directory is closed. The file tree walk then continues at the next <em>sibling</em> of the directory.  <p> The stream is <i>weakly consistent</i>. It does not freeze the file tree while iterating, so it may (or may not) reflect updates to the file tree that occur after returned from this method.  <p> By default, symbolic links are not automatically followed by this method. If the ‘options’ parameter contains the ‘FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS’ option then symbolic links are followed. When following links, and the attributes of the target cannot be read, then this method attempts to get the ‘BasicFileAttributes’ of the link.  <p> If the ‘options’ parameter contains the ‘FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS’ option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the ‘java.nio.file.attribute.BasicFileAttributes#fileKey file-key’ of directories, or if file keys are not available, by invoking the ‘#isSameFile isSameFile’ method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I&#x2F;O error with an instance of ‘FileSystemLoopException’.  <p> The ‘maxDepth’ parameter is the maximum number of levels of directories to visit. A value of ‘0’ means that only the starting file is visited, unless denied by the security manager. A value of ‘Integer#MAX_VALUE MAX_VALUE’ may be used to indicate that all levels should be visited.  <p> When a security manager is installed and it denies access to a file (or directory), then it is ignored and not included in the stream.  <p> The returned stream encapsulates one or more ‘DirectoryStream’s. If timely disposal of file system resources is required, the ‘try’-with-resources construct should be used to ensure that the stream’s ‘Stream#close close’ method is invoked after the stream operations are completed.  Operating on a closed stream will result in an ‘java.lang.IllegalStateException’.  <p> If an ‘IOException’ is thrown when accessing the directory after this method has returned, it is wrapped in an ‘UncheckedIOException’ which will be thrown from the method that caused the access to take place.</td>
<td align="left">SecurityException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>walk(Path start, FileVisitOption… options): Stream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return a ‘Stream’ that is lazily populated with ‘Path’ by walking the file tree rooted at a given starting file.  The file tree is traversed <em>depth-first</em>, the elements in the stream are ‘Path’ objects that are obtained as if by ‘Path#resolve(Path) resolving’ the relative path against ‘start’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <blockquote><pre> walk(start, Integer.MAX_VALUE, options) </pre></blockquote> In other words, it visits all levels of the file tree.  <p> The returned stream encapsulates one or more ‘DirectoryStream’s. If timely disposal of file system resources is required, the ‘try’-with-resources construct should be used to ensure that the stream’s ‘Stream#close close’ method is invoked after the stream operations are completed.  Operating on a closed stream will result in an ‘java.lang.IllegalStateException’.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>find(Path start, int maxDepth, BiPredicate&lt;Path, BasicFileAttributes&gt; matcher, FileVisitOption… options): Stream<Path></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return a ‘Stream’ that is lazily populated with ‘Path’ by searching for files in a file tree rooted at a given starting file.  <p> This method walks the file tree in exactly the manner specified by the ‘#walk walk’ method. For each file encountered, the given ‘BiPredicate’ is invoked with its ‘Path’ and ‘BasicFileAttributes’. The ‘Path’ object is obtained as if by ‘Path#resolve(Path) resolving’ the relative path against ‘start’ and is only included in the returned ‘Stream’ if the ‘BiPredicate’ returns true. Compare to calling ‘java.util.stream.Stream#filter filter’ on the ‘Stream’ returned by ‘walk’ method, this method may be more efficient by avoiding redundant retrieval of the ‘BasicFileAttributes’.  <p> The returned stream encapsulates one or more ‘DirectoryStream’s. If timely disposal of file system resources is required, the ‘try’-with-resources construct should be used to ensure that the stream’s ‘Stream#close close’ method is invoked after the stream operations are completed.  Operating on a closed stream will result in an ‘java.lang.IllegalStateException’.  <p> If an ‘IOException’ is thrown when accessing the directory after returned from this method, it is wrapped in an ‘UncheckedIOException’ which will be thrown from the method that caused the access to take place.</td>
<td align="left">SecurityException<br/>IOException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>lines(Path path, Charset cs): Stream<String></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Read all lines from a file as a ‘Stream’. Unlike ‘#readAllLines(Path, Charset) readAllLines’, this method does not read all lines into a ‘List’, but instead populates lazily as the stream is consumed.  <p> Bytes from the file are decoded into characters using the specified charset and the same line terminators as specified by ‘readAllLines’ are supported.  <p> After this method returns, then any subsequent I&#x2F;O exception that occurs while reading from the file or when a malformed or unmappable byte sequence is read, is wrapped in an ‘UncheckedIOException’ that will be thrown from the ‘java.util.stream.Stream’ method that caused the read to take place. In case an ‘IOException’ is thrown when closing the file, it is also wrapped as an ‘UncheckedIOException’.  <p> The returned stream encapsulates a ‘Reader’.  If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream’s ‘Stream#close close’ method is invoked after the stream operations are completed.</td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
<tr>
<td align="center"><strong>lines(Path path): Stream<String></strong></td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Read all lines from a file as a ‘Stream’. Bytes from the file are decoded into characters using the ‘StandardCharsets#UTF_8 UTF-8’ ‘Charset charset’.  <p> This method works as if invoking it were equivalent to evaluating the expression: <pre>'Files.lines(path, StandardCharsets.UTF_8)'</pre></td>
<td align="left">SecurityException<br/>IOException</td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="Files-AcceptAllFilter"><a href="#Files-AcceptAllFilter" class="headerlink" title="Files$AcceptAllFilter"></a><a href="./Files$AcceptAllFilter.html">Files$AcceptAllFilter</a></h3><h3 id="Files-FileTypeDetectors"><a href="#Files-FileTypeDetectors" class="headerlink" title="Files$FileTypeDetectors"></a><a href="./Files$FileTypeDetectors.html">Files$FileTypeDetectors</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
