<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/awt/font/TextLayout.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="TextLayout"><a href="#TextLayout" class="headerlink" title="TextLayout"></a>TextLayout</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父接口</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.awt.font.TextLayout</strong></td>
<td align="center">class</td>
<td align="center">Cloneable</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>characterCount: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isVerticalLine: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>baseline: byte</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>baselineOffsets: float[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>textLine: TextLine</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lineMetrics: TextLine.TextLineMetrics</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>visibleAdvance: float</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hashCodeCache: int</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>cacheIsValid: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">TextLayouts are supposedly immutable.  If you mutate a TextLayout under the covers (like the justification code does) you’ll need to set this back to false.  Could be replaced with textLine !&#x3D; null &lt;–&gt; cacheIsValid.</td>
</tr>
<tr>
<td align="center"><strong>justifyRatio: float</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ALREADY_JUSTIFIED: float</strong></td>
<td align="center">-53.9f</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>dx: float</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>dy: float</strong></td>
<td align="center">0</td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>naturalBounds: Rectangle2D</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Natural bounds is used internally.  It is built on demand in getNaturalBounds.</td>
</tr>
<tr>
<td align="center"><strong>boundsRect: Rectangle2D</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">boundsRect encloses all of the bits this TextLayout can draw.  It is build on demand in getBounds.</td>
</tr>
<tr>
<td align="center"><strong>caretsInLigaturesAreAllowed: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">flag to supress&#x2F;allow carets inside of ligatures when hit testing or arrow-keying</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT_CARET_POLICY: CaretPolicy</strong></td>
<td align="center">new CaretPolicy()</td>
<td align="center">public</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">This <code>CaretPolicy</code> is used when a policy is not specified by the client.  With this policy, a hit on a character whose direction is the same as the line direction is stronger than a hit on a counterdirectional character.  If the characters’ directions are the same, a hit on the leading edge of a character is stronger than a hit on the trailing edge of a character.</td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>TextLayout(String string, Font font, FontRenderContext frc)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a <code>TextLayout</code> from a <code>String</code> and a ‘Font’.  All the text is styled using the specified <code>Font</code>. <p> The <code>String</code> must specify a single paragraph of text, because an entire paragraph is required for the bidirectional algorithm.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TextLayout(String string, Map&lt;? extends Attribute,?&gt; attributes, FontRenderContext frc)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a <code>TextLayout</code> from a <code>String</code> and an attribute set. <p> All the text is styled using the provided attributes. <p> <code>string</code> must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>singleFont(char[] text, int start, int limit, Map&lt;? extends Attribute, ?&gt; attributes): Font</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Determines a font for the attributes, and if a single font can render all the text on one baseline, return it, otherwise null.  If the attributes specify a font, assume it can display all the text without checking. If the AttributeSet contains an embedded graphic, return null.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TextLayout(AttributedCharacterIterator text, FontRenderContext frc)</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a <code>TextLayout</code> from an iterator over styled text. <p> The iterator must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>TextLayout(TextLine textLine, byte baseline, float[] baselineOffsets, float justifyRatio)</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a <code>TextLayout</code> from a ‘TextLine’ and some paragraph data.  This method is used by ‘TextMeasurer’.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>paragraphInit(byte aBaseline, CoreMetrics lm, Map&lt;? extends Attribute, ?&gt; paragraphAttrs, char[] text): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Initialize the paragraph-specific data.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fastInit(char[] chars, Font font, Map&lt;? extends Attribute, ?&gt; attrs, FontRenderContext frc): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">the fast init generates a single glyph set.  This requires: all one style all renderable by one font (ie no embedded graphics) all on one baseline</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>standardInit(AttributedCharacterIterator text, char[] chars, FontRenderContext frc): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">the standard init generates multiple glyph sets based on style, renderable, and baseline runs.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>ensureCache(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">A utility to rebuild the ascent&#x2F;descent&#x2F;leading&#x2F;advance cache. You’ll need to call this if you clone and mutate (like justification, editing methods do)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>buildCache(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNaturalBounds(): Rectangle2D</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">The ‘natural bounds’ encloses all the carets the layout can draw.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>clone(): Object</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a copy of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>checkTextHit(TextHitInfo hit): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Utility to throw an expection if an invalid TextHitInfo is passed as a parameter.  Avoids code duplication.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getJustifiedLayout(float justificationWidth): TextLayout</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a copy of this <code>TextLayout</code> justified to the specified width. <p> If this <code>TextLayout</code> has already been justified, an exception is thrown.  If this <code>TextLayout</code> object’s justification ratio is zero, a <code>TextLayout</code> identical to this <code>TextLayout</code> is returned.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>handleJustify(float justificationWidth): void</strong></td>
<td align="center">protected</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Justify this layout.  Overridden by subclassers to control justification (if there were subclassers, that is…)  The layout will only justify if the paragraph attributes (from the source text, possibly defaulted by the layout attributes) indicate a non-zero justification ratio.  The text will be justified to the indicated width.  The current implementation also adjusts hanging punctuation and trailing whitespace to overhang the justification width. Once justified, the layout may not be rejustified. <p> Some code may rely on immutablity of layouts.  Subclassers should not call this directly, but instead should call getJustifiedLayout, which will call this method on a clone of this layout, preserving the original.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getBaseline(): byte</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the baseline for this <code>TextLayout</code>. The baseline is one of the values defined in <code>Font</code>, which are roman, centered and hanging.  Ascent and descent are relative to this baseline.  The <code>baselineOffsets</code> are also relative to this baseline.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getBaselineOffsets(): float[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the offsets array for the baselines used for this <code>TextLayout</code>. <p> The array is indexed by one of the values defined in <code>Font</code>, which are roman, centered and hanging.  The values are relative to this <code>TextLayout</code> object’s baseline, so that <code>getBaselineOffsets[getBaseline()] == 0</code>. Offsets are added to the position of the <code>TextLayout</code> object’s baseline to get the position for the new baseline.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getAdvance(): float</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the advance of this <code>TextLayout</code>. The advance is the distance from the origin to the advance of the rightmost (bottommost) character.  This is in baseline-relative coordinates.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getVisibleAdvance(): float</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the advance of this <code>TextLayout</code>, minus trailing whitespace.  This is in baseline-relative coordinates.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getAscent(): float</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the ascent of this <code>TextLayout</code>. The ascent is the distance from the top (right) of the <code>TextLayout</code> to the baseline.  It is always either positive or zero.  The ascent is sufficient to accommodate superscripted text and is the maximum of the sum of the ascent, offset, and baseline of each glyph.  The ascent is the maximum ascent from the baseline of all the text in the TextLayout.  It is in baseline-relative coordinates.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getDescent(): float</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the descent of this <code>TextLayout</code>. The descent is the distance from the baseline to the bottom (left) of the <code>TextLayout</code>.  It is always either positive or zero. The descent is sufficient to accommodate subscripted text and is the maximum of the sum of the descent, offset, and baseline of each glyph. This is the maximum descent from the baseline of all the text in the TextLayout.  It is in baseline-relative coordinates.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLeading(): float</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the leading of the <code>TextLayout</code>. The leading is the suggested interline spacing for this <code>TextLayout</code>.  This is in baseline-relative coordinates. <p> The leading is computed from the leading, descent, and baseline of all glyphvectors in the <code>TextLayout</code>.  The algorithm is roughly as follows: <blockquote><pre> maxD = 0; maxDL = 0; for (GlyphVector g in all glyphvectors) { maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]); maxDL = max(maxDL, g.getDescent() + g.getLeading() + offsets[g.getBaseline()]); } return maxDL - maxD; </pre></blockquote></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getBounds(): Rectangle2D</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the bounds of this <code>TextLayout</code>. The bounds are in standard coordinates. <p>Due to rasterization effects, this bounds might not enclose all of the pixels rendered by the TextLayout.</p> It might not coincide exactly with the ascent, descent, origin or advance of the <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getPixelBounds(FontRenderContext frc, float x, float y): Rectangle</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the pixel bounds of this <code>TextLayout</code> when rendered in a graphics with the given <code>FontRenderContext</code> at the given location.  The graphics render context need not be the same as the <code>FontRenderContext</code> used to create this <code>TextLayout</code>, and can be null.  If it is null, the <code>FontRenderContext</code> of this <code>TextLayout</code> is used.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isLeftToRight(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns <code>true</code> if this <code>TextLayout</code> has a left-to-right base direction or <code>false</code> if it has a right-to-left base direction.  The <code>TextLayout</code> has a base direction of either left-to-right (LTR) or right-to-left (RTL).  The base direction is independent of the actual direction of text on the line, which may be either LTR, RTL, or mixed. Left-to-right layouts by default should position flush left.  If the layout is on a tabbed line, the tabs run left to right, so that logically successive layouts position left to right.  The opposite is true for RTL layouts. By default they should position flush left, and tabs run right-to-left.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isVertical(): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns <code>true</code> if this <code>TextLayout</code> is vertical.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCharacterCount(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the number of characters represented by this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretInfo(int caret, Rectangle2D bounds, float[] info): float[]</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">carets and hit testing  Positions on a text line are represented by instances of TextHitInfo. Any TextHitInfo with characterOffset between 0 and characterCount-1, inclusive, represents a valid position on the line.  Additionally, [-1, trailing] and [characterCount, leading] are valid positions, and represent positions at the logical start and end of the line, respectively.  The characterOffsets in TextHitInfo’s used and returned by TextLayout are relative to the beginning of the text layout, not necessarily to the beginning of the text storage the client is using.   Every valid TextHitInfo has either one or two carets associated with it. A caret is a visual location in the TextLayout indicating where text at the TextHitInfo will be displayed on screen.  If a TextHitInfo represents a location on a directional boundary, then there are two possible visible positions for newly inserted text.  Consider the following example, in which capital letters indicate right-to-left text, and the overall line direction is left-to-right:  Text Storage: [ a, b, C, D, E, f ] Display:        a b E D C f  The text hit info (1, t) represents the trailing side of ‘b’.  If ‘q’, a left-to-right character is inserted into the text storage at this location, it will be displayed between the ‘b’ and the ‘E’:  Text Storage: [ a, b, q, C, D, E, f ] Display:        a b q E D C f  However, if a ‘W’, which is right-to-left, is inserted into the storage after ‘b’, the storage and display will be:  Text Storage: [ a, b, W, C, D, E, f ] Display:        a b E D C W f  So, for the original text storage, two carets should be displayed for location (1, t): one visually between ‘b’ and ‘E’ and one visually between ‘C’ and ‘f’.   When two carets are displayed for a TextHitInfo, one caret is the ‘strong’ caret and the other is the ‘weak’ caret.  The strong caret indicates where an inserted character will be displayed when that character’s direction is the same as the direction of the TextLayout. The weak caret shows where an character inserted character will be displayed when the character’s direction is opposite that of the TextLayout.   Clients should not be overly concerned with the details of correct caret display. TextLayout.getCaretShapes(TextHitInfo) will return an array of two paths representing where carets should be displayed. The first path in the array is the strong caret; the second element, if non-null, is the weak caret.  If the second element is null, then there is no weak caret for the given TextHitInfo.   Since text can be visually reordered, logically consecutive TextHitInfo’s may not be visually consecutive.  One implication of this is that a client cannot tell from inspecting a TextHitInfo whether the hit represents the first (or last) caret in the layout.  Clients can call getVisualOtherHit();  if the visual companion is (-1, TRAILING) or (characterCount, LEADING), then the hit is at the first (last) caret position in the layout.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretInfo(TextHitInfo hit, Rectangle2D bounds): float[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns information about the caret corresponding to <code>hit</code>. The first element of the array is the intersection of the caret with the baseline, as a distance along the baseline. The second element of the array is the inverse slope (run&#x2F;rise) of the caret, measured with respect to the baseline at that point. <p> This method is meant for informational use.  To display carets, it is better to use <code>getCaretShapes</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretInfoTestInternal(TextHitInfo hit, Rectangle2D bounds): float[]</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretInfo(TextHitInfo hit): float[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns information about the caret corresponding to <code>hit</code>. This method is a convenience overload of <code>getCaretInfo</code> and uses the natural bounds of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hitToCaret(TextHitInfo hit): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a caret index corresponding to <code>hit</code>. Carets are numbered from left to right (top to bottom) starting from zero. This always places carets next to the character hit, on the indicated side of the character.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>caretToHit(int caret): TextHitInfo</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Given a caret index, return a hit whose caret is at the index. The hit is NOT guaranteed to be strong!!!</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>caretIsValid(int caret): boolean</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextRightHit(TextHitInfo hit): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the right (bottom); if there is no such hit, returns <code>null</code>. If the hit character index is out of bounds, an ‘IllegalArgumentException’ is thrown.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextRightHit(int offset, CaretPolicy policy): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the right (bottom); if no such hit, returns <code>null</code>.  The hit is to the right of the strong caret at the specified offset, as determined by the specified policy. The returned hit is the stronger of the two possible hits, as determined by the specified policy.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextRightHit(int offset): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the right (bottom); if no such hit, returns <code>null</code>.  The hit is to the right of the strong caret at the specified offset, as determined by the default policy. The returned hit is the stronger of the two possible hits, as determined by the default policy.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextLeftHit(TextHitInfo hit): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the left (top); if no such hit, returns <code>null</code>. If the hit character index is out of bounds, an <code>IllegalArgumentException</code> is thrown.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextLeftHit(int offset, CaretPolicy policy): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the left (top); if no such hit, returns <code>null</code>.  The hit is to the left of the strong caret at the specified offset, as determined by the specified policy. The returned hit is the stronger of the two possible hits, as determined by the specified policy.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getNextLeftHit(int offset): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit for the next caret to the left (top); if no such hit, returns <code>null</code>.  The hit is to the left of the strong caret at the specified offset, as determined by the default policy. The returned hit is the stronger of the two possible hits, as determined by the default policy.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getVisualOtherHit(TextHitInfo hit): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hit on the opposite side of the specified hit’s caret.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretPath(TextHitInfo hit, Rectangle2D bounds): double[]</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretPath(int caret, Rectangle2D bounds, boolean clipToBounds): double[]</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return an array of four floats corresponding the endpoints of the caret x0, y0, x1, y1.  This creates a line along the slope of the caret intersecting the baseline at the caret position, and extending from ascent above the baseline to descent below it.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>pathToShape(double[] path, boolean close, LayoutPathImpl lp): GeneralPath</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretShape(TextHitInfo hit, Rectangle2D bounds): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a ‘Shape’ representing the caret at the specified hit inside the specified bounds.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretShape(TextHitInfo hit): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>Shape</code> representing the caret at the specified hit inside the natural bounds of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getStrongHit(TextHitInfo hit1, TextHitInfo hit2): TextHitInfo</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return the “stronger” of the TextHitInfos.  The TextHitInfos should be logical or visual counterparts.  They are not checked for validity.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCharacterLevel(int index): byte</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the level of the character at <code>index</code>. Indices -1 and <code>characterCount</code> are assigned the base level of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretShapes(int offset, Rectangle2D bounds, CaretPolicy policy): Shape[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns two paths corresponding to the strong and weak caret.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretShapes(int offset, Rectangle2D bounds): Shape[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns two paths corresponding to the strong and weak caret. This method is a convenience overload of <code>getCaretShapes</code> that uses the default caret policy.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getCaretShapes(int offset): Shape[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns two paths corresponding to the strong and weak caret. This method is a convenience overload of <code>getCaretShapes</code> that uses the default caret policy and this <code>TextLayout</code> object’s natural bounds.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>boundingShape(double[] path0, double[] path1): GeneralPath</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>caretBoundingShape(int caret0, int caret1, Rectangle2D bounds): GeneralPath</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>leftShape(Rectangle2D bounds): GeneralPath</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">A utility to return the path bounding the area to the left (top) of the layout. Shape is never outside of bounds.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>rightShape(Rectangle2D bounds): GeneralPath</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">A utility to return the path bounding the area to the right (bottom) of the layout.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLogicalRangesForVisualSelection(TextHitInfo firstEndpoint, TextHitInfo secondEndpoint): int[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the logical ranges of text corresponding to a visual selection.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getVisualHighlightShape(TextHitInfo firstEndpoint, TextHitInfo secondEndpoint, Rectangle2D bounds): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a path enclosing the visual selection in the specified range, extended to <code>bounds</code>. <p> If the selection includes the leftmost (topmost) position, the selection is extended to the left (top) of <code>bounds</code>.  If the selection includes the rightmost (bottommost) position, the selection is extended to the right (bottom) of the bounds.  The height (width on vertical lines) of the selection is always extended to <code>bounds</code>. <p> Although the selection is always contiguous, the logically selected text can be discontiguous on lines with mixed-direction text.  The logical ranges of text selected can be retrieved using <code>getLogicalRangesForVisualSelection</code>.  For example, consider the text ‘ABCdef’ where capital letters indicate right-to-left text, rendered on a right-to-left line, with a visual selection from 0L (the leading edge of ‘A’) to 3T (the trailing edge of ‘d’).  The text appears as follows, with bold underlined areas representing the selection: <br><pre> d<u><b>efCBA  </b></u> </pre> The logical selection ranges are 0-3, 4-6 (ABC, ef) because the visually contiguous text is logically discontiguous.  Also note that since the rightmost position on the layout (to the right of ‘A’) is selected, the selection is extended to the right of the bounds.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getVisualHighlightShape(TextHitInfo firstEndpoint, TextHitInfo secondEndpoint): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>Shape</code> enclosing the visual selection in the specified range, extended to the bounds.  This method is a convenience overload of <code>getVisualHighlightShape</code> that uses the natural bounds of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLogicalHighlightShape(int firstEndpoint, int secondEndpoint, Rectangle2D bounds): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>Shape</code> enclosing the logical selection in the specified range, extended to the specified <code>bounds</code>. <p> If the selection range includes the first logical character, the selection is extended to the portion of <code>bounds</code> before the start of this <code>TextLayout</code>.  If the range includes the last logical character, the selection is extended to the portion of <code>bounds</code> after the end of this <code>TextLayout</code>. The height (width on vertical lines) of the selection is always extended to <code>bounds</code>. <p> The selection can be discontiguous on lines with mixed-direction text. Only those characters in the logical range between start and limit appear selected.  For example, consider the text ‘ABCdef’ where capital letters indicate right-to-left text, rendered on a right-to-left line, with a logical selection from 0 to 4 (‘ABCd’).  The text appears as follows, with bold standing in for the selection, and underlining for the extension: <br><pre> <u><b>d</b></u>ef<u><b>CBA  </b></u> </pre> The selection is discontiguous because the selected characters are visually discontiguous. Also note that since the range includes the first logical character (A), the selection is extended to the portion of the <code>bounds</code> before the start of the layout, which in this case (a right-to-left line) is the right portion of the <code>bounds</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLogicalHighlightShape(int firstEndpoint, int secondEndpoint): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>Shape</code> enclosing the logical selection in the specified range, extended to the natural bounds of this <code>TextLayout</code>.  This method is a convenience overload of <code>getLogicalHighlightShape</code> that uses the natural bounds of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getBlackBoxBounds(int firstEndpoint, int secondEndpoint): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the black box bounds of the characters in the specified range. The black box bounds is an area consisting of the union of the bounding boxes of all the glyphs corresponding to the characters between start and limit.  This area can be disjoint.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>caretToPointDistance(float[] caretInfo, float x, float y): float</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the distance from the point (x,&amp;nbsp;y) to the caret along the line direction defined in <code>caretInfo</code>.  Distance is negative if the point is to the left of the caret on a horizontal line, or above the caret on a vertical line. Utility for use by hitTestChar.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hitTestChar(float x, float y, Rectangle2D bounds): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>TextHitInfo</code> corresponding to the specified point. Coordinates outside the bounds of the <code>TextLayout</code> map to hits on the leading edge of the first logical character, or the trailing edge of the last logical character, as appropriate, regardless of the position of that character in the line.  Only the direction along the baseline is used to make this evaluation.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hitTestChar(float x, float y): TextHitInfo</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>TextHitInfo</code> corresponding to the specified point.  This method is a convenience overload of <code>hitTestChar</code> that uses the natural bounds of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hashCode(): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the hash code of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(Object obj): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns <code>true</code> if the specified <code>Object</code> is a <code>TextLayout</code> object and if the specified <code>Object</code> equals this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(TextLayout rhs): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns <code>true</code> if the two layouts are equal. Two layouts are equal if they contain equal glyphvectors in the same order.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>toString(): String</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns debugging information for this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>draw(Graphics2D g2, float x, float y): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Renders this <code>TextLayout</code> at the specified location in the specified ‘java.awt.Graphics2D Graphics2D’ context. The origin of the layout is placed at x,&amp;nbsp;y.  Rendering may touch any point within <code>getBounds()</code> of this position.  This leaves the <code>g2</code> unchanged.  Text is rendered along the baseline path.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getTextLineForTesting(): TextLine</strong></td>
<td align="center">default</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Package-only method for testing ONLY.  Please don’t abuse.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>sameBaselineUpTo(Font font, char[] text, int start, int limit): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return the index of the first character with a different baseline from the character at start, or limit if all characters between start and limit have the same baseline.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getBaselineFromGraphic(GraphicAttribute graphic): byte</strong></td>
<td align="center">default</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getOutline(AffineTransform tx): Shape</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <code>Shape</code> representing the outline of this <code>TextLayout</code>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getLayoutPath(): LayoutPath</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Return the LayoutPath, or null if the layout path is the default path (x maps to advance, y maps to offset).</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>hitToPoint(TextHitInfo hit, Point2D point): void</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Convert a hit to a point in standard coordinates.  The point is on the baseline of the character at the leading or trailing edge of the character, as appropriate.  If the path is broken at the side of the character represented by the hit, the point will be adjacent to the character.</td>
<td align="left">NullPointerException<br/>IllegalArgumentException</td>
</tr>
</tbody></table>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h3 id="TextLayout-CaretPolicy"><a href="#TextLayout-CaretPolicy" class="headerlink" title="TextLayout$CaretPolicy"></a><a href="./TextLayout$CaretPolicy.html">TextLayout$CaretPolicy</a></h3>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
