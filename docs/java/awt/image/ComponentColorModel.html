<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Java Source Code Analysis |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/java-source-code-analysis/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/java-source-code-analysis/favicon.ico">

    

  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"java/awt/image/ComponentColorModel.html","title":""},"data":{"navigation":{"logo":{"text":"Java 源码分析","type":"link","path":"index.html"}}},"config":{"timezone":"Asia/Shanghai","root":"/java-source-code-analysis/","time_format":"HH:mm:ss","theme":"doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/java-source-code-analysis/index.html" class="doc-navbar__logo"><img src="/java-source-code-analysis/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Java 源码分析</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="ComponentColorModel"><a href="#ComponentColorModel" class="headerlink" title="ComponentColorModel"></a>ComponentColorModel</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">类型</th>
<th align="center">父类</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.awt.image.ComponentColorModel</strong></td>
<td align="center">class</td>
<td align="center">ColorModel</td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>signed: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"><code>signed</code>  is <code>true</code> for <code>short</code>, <code>float</code>, and <code>double</code> transfer types; it is <code>false</code> for <code>byte</code>, <code>ushort</code>, and <code>int</code> transfer types.</td>
</tr>
<tr>
<td align="center"><strong>is_sRGB_stdScale: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>is_LinearRGB_stdScale: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>is_LinearGray_stdScale: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>is_ICCGray_stdScale: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>tosRGB8LUT: byte[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fromsRGB8LUT8: byte[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fromsRGB8LUT16: short[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fromLinearGray16ToOtherGray8LUT: byte[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>fromLinearGray16ToOtherGray16LUT: short[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>needScaleInit: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>noUnnorm: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>nonStdScale: boolean</strong></td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>min: float[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>diffMinMax: float[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compOffset: float[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>compScale: float[]</strong></td>
<td align="center">null</td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">权限</th>
<th align="center">static</th>
<th align="center">final</th>
<th align="center">volatile</th>
<th align="center">synchronized</th>
<th align="center">transient</th>
<th align="center">abstract</th>
<th align="left">描述</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>bitsHelper(int transferType, ColorSpace colorSpace, boolean hasAlpha): int</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Constructs a <CODE>ComponentColorModel</CODE> from the specified parameters. Color components will be in the specified <CODE>ColorSpace</CODE>.  The supported transfer types are <CODE>DataBuffer.TYPE_BYTE</CODE>, <CODE>DataBuffer.TYPE_USHORT</CODE>, <CODE>DataBuffer.TYPE_INT</CODE>, <CODE>DataBuffer.TYPE_SHORT</CODE>, <CODE>DataBuffer.TYPE_FLOAT</CODE>, and <CODE>DataBuffer.TYPE_DOUBLE</CODE>.  The number of significant bits per color and alpha component will be 8, 16, 32, 16, 32,  or 64, respectively.  The number of color components will be the number of components in the <CODE>ColorSpace</CODE>.  There will be an alpha component if <CODE>hasAlpha</CODE> is <CODE>true</CODE>. If <CODE>hasAlpha</CODE> is true, then the boolean <CODE>isAlphaPremultiplied</CODE> specifies how to interpret color and alpha samples in pixel values. If the boolean is true, color samples are assumed to have been multiplied by the alpha sample. The <CODE>transparency</CODE> specifies what alpha values can be represented by this color model. The acceptable <code>transparency</code> values are <CODE>OPAQUE</CODE>, <CODE>BITMASK</CODE> or <CODE>TRANSLUCENT</CODE>. The <CODE>transferType</CODE> is the type of primitive array used to represent pixel values.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>bitsArrayHelper(int[] origBits, int transferType, ColorSpace colorSpace, boolean hasAlpha): int[]</strong></td>
<td align="center">private</td>
<td align="center"><strong><font color='red'>是</font></strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>setupLUTs(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>initScale(): void</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRGBComponent(int pixel, int idx): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRed(int pixel): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the red color component for the specified pixel, scaled from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion is done if necessary.  The pixel value is specified as an int. The returned value will be a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the red value will be 0).</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getGreen(int pixel): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the green color component for the specified pixel, scaled from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion is done if necessary.  The pixel value is specified as an int. The returned value will be a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the green value will be 0).</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getBlue(int pixel): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the blue color component for the specified pixel, scaled from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion is done if necessary.  The pixel value is specified as an int. The returned value will be a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the blue value will be 0).</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getAlpha(int pixel): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the alpha component for the specified pixel, scaled from 0 to 255.   The pixel value is specified as an int.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getRGB(int pixel): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the color&#x2F;alpha components of the pixel in the default RGB color model format.  A color conversion is done if necessary. The returned value will be in a non pre-multiplied format. If the alpha is premultiplied, this method divides it out of the color components (if the alpha value is 0, the color values will be 0).</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>extractComponent(Object inData, int idx, int precision): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRGBComponent(Object inData, int idx): int</strong></td>
<td align="center">private</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getRed(Object inData): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the red color component for the specified pixel, scaled from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion is done if necessary.  The <CODE>pixel</CODE> value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference. The returned value will be a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the red value will be 0). Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getGreen(Object inData): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the green color component for the specified pixel, scaled from 0 to 255 in the default RGB <CODE>ColorSpace</CODE>, sRGB. A color conversion is done if necessary.  The <CODE>pixel</CODE> value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference. The returned value is a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the green value will be 0). Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getBlue(Object inData): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the blue color component for the specified pixel, scaled from 0 to 255 in the default RGB <CODE>ColorSpace</CODE>, sRGB. A color conversion is done if necessary.  The <CODE>pixel</CODE> value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference. The returned value is a non pre-multiplied value. If the alpha is premultiplied, this method divides it out before returning the value (if the alpha value is 0, the blue value will be 0). Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getAlpha(Object inData): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the alpha component for the specified pixel, scaled from 0 to 255.  The pixel value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference.  Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getRGB(Object inData): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns the color&#x2F;alpha components for the specified pixel in the default RGB color model format.  A color conversion is done if necessary.  The pixel value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference. The returned value is in a non pre-multiplied format. If the alpha is premultiplied, this method divides it out of the color components (if the alpha value is 0, the color values will be 0). Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getDataElements(int rgb, Object pixel): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a data element array representation of a pixel in this <CODE>ColorModel</CODE>, given an integer pixel representation in the default RGB color model. This array can then be passed to the <CODE>setDataElements</CODE> method of a <CODE>WritableRaster</CODE> object.  If the <CODE>pixel</CODE> parameter is null, a new array is allocated.  Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then they throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException</td>
</tr>
<tr>
<td align="center"><strong>getComponents(int pixel, int[] components, int offset): int[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array of unnormalized color&#x2F;alpha components given a pixel in this <CODE>ColorModel</CODE>. An IllegalArgumentException is thrown if the component value for this <CODE>ColorModel</CODE> is not conveniently representable in the unnormalized form.  Color&#x2F;alpha components are stored in the <CODE>components</CODE> array starting at <CODE>offset</CODE> (even if the array is allocated by this method).</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getComponents(Object pixel, int[] components, int offset): int[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array of unnormalized color&#x2F;alpha components given a pixel in this <CODE>ColorModel</CODE>.  The pixel value is specified by an array of data elements of type <CODE>transferType</CODE> passed in as an object reference. An IllegalArgumentException is thrown if the component values for this <CODE>ColorModel</CODE> are not conveniently representable in the unnormalized form. Color&#x2F;alpha components are stored in the <CODE>components</CODE> array starting at  <CODE>offset</CODE> (even if the array is allocated by this method).  Since <code>ComponentColorModel</code> can be subclassed, subclasses inherit the implementation of this method and if they don’t override it then this method might throw an exception if they use an unsupported <code>transferType</code>.</td>
<td align="left">UnsupportedOperationException<br/>ClassCastException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getUnnormalizedComponents(float[] normComponents, int normOffset, int[] components, int offset): int[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array of all of the color&#x2F;alpha components in unnormalized form, given a normalized component array.  Unnormalized components are unsigned integral values between 0 and 2<sup>n</sup> - 1, where n is the number of bits for a particular component.  Normalized components are float values between a per component minimum and maximum specified by the <code>ColorSpace</code> object for this <code>ColorModel</code>.  An <code>IllegalArgumentException</code> will be thrown if color component values for this <code>ColorModel</code> are not conveniently representable in the unnormalized form.  If the <code>components</code> array is <code>null</code>, a new array will be allocated.  The <code>components</code> array will be returned.  Color&#x2F;alpha components are stored in the <code>components</code> array starting at <code>offset</code> (even if the array is allocated by this method). An <code>ArrayIndexOutOfBoundsException</code> is thrown if the <code>components</code> array is not <code>null</code> and is not large enough to hold all the color and alpha components (starting at <code>offset</code>).  An <code>IllegalArgumentException</code> is thrown if the <code>normComponents</code> array is not large enough to hold all the color and alpha components starting at <code>normOffset</code>.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getNormalizedComponents(int[] components, int offset, float[] normComponents, int normOffset): float[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array of all of the color&#x2F;alpha components in normalized form, given an unnormalized component array.  Unnormalized components are unsigned integral values between 0 and 2<sup>n</sup> - 1, where n is the number of bits for a particular component.  Normalized components are float values between a per component minimum and maximum specified by the <code>ColorSpace</code> object for this <code>ColorModel</code>.  An <code>IllegalArgumentException</code> will be thrown if color component values for this <code>ColorModel</code> are not conveniently representable in the unnormalized form.  If the <code>normComponents</code> array is <code>null</code>, a new array will be allocated.  The <code>normComponents</code> array will be returned.  Color&#x2F;alpha components are stored in the <code>normComponents</code> array starting at <code>normOffset</code> (even if the array is allocated by this method).  An <code>ArrayIndexOutOfBoundsException</code> is thrown if the <code>normComponents</code> array is not <code>null</code> and is not large enough to hold all the color and alpha components (starting at <code>normOffset</code>).  An <code>IllegalArgumentException</code> is thrown if the <code>components</code> array is not large enough to hold all the color and alpha components starting at <code>offset</code>.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getDataElement(int[] components, int offset): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a pixel value represented as an int in this <CODE>ColorModel</CODE>, given an array of unnormalized color&#x2F;alpha components.</td>
<td align="left">IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getDataElements(int[] components, int offset, Object obj): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a data element array representation of a pixel in this <CODE>ColorModel</CODE>, given an array of unnormalized color&#x2F;alpha components. This array can then be passed to the <CODE>setDataElements</CODE> method of a <CODE>WritableRaster</CODE> object.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException<br/>UnsupportedOperationException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getDataElement(float[] normComponents, int normOffset): int</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a pixel value represented as an <code>int</code> in this <code>ColorModel</code>, given an array of normalized color&#x2F;alpha components.  This method will throw an <code>IllegalArgumentException</code> if pixel values for this <code>ColorModel</code> are not conveniently representable as a single <code>int</code>.  An <code>ArrayIndexOutOfBoundsException</code> is thrown if  the <code>normComponents</code> array is not large enough to hold all the color and alpha components (starting at <code>normOffset</code>).</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>IllegalArgumentException</td>
</tr>
<tr>
<td align="center"><strong>getDataElements(float[] normComponents, int normOffset, Object obj): Object</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a data element array representation of a pixel in this <code>ColorModel</code>, given an array of normalized color&#x2F;alpha components.  This array can then be passed to the <code>setDataElements</code> method of a <code>WritableRaster</code> object.  An <code>ArrayIndexOutOfBoundsException</code> is thrown if the <code>normComponents</code> array is not large enough to hold all the color and alpha components (starting at <code>normOffset</code>).  If the <code>obj</code> variable is <code>null</code>, a new array will be allocated.  If <code>obj</code> is not <code>null</code>, it must be a primitive array of type transferType; otherwise, a <code>ClassCastException</code> is thrown.  An <code>ArrayIndexOutOfBoundsException</code> is thrown if <code>obj</code> is not large enough to hold a pixel value for this <code>ColorModel</code>.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>getNormalizedComponents(Object pixel, float[] normComponents, int normOffset): float[]</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns an array of all of the color&#x2F;alpha components in normalized form, given a pixel in this <code>ColorModel</code>.  The pixel value is specified by an array of data elements of type transferType passed in as an object reference.  If pixel is not a primitive array of type transferType, a <code>ClassCastException</code> is thrown. An <code>ArrayIndexOutOfBoundsException</code> is thrown if <code>pixel</code> is not large enough to hold a pixel value for this <code>ColorModel</code>. Normalized components are float values between a per component minimum and maximum specified by the <code>ColorSpace</code> object for this <code>ColorModel</code>.  If the <code>normComponents</code> array is <code>null</code>, a new array will be allocated.  The <code>normComponents</code> array will be returned.  Color&#x2F;alpha components are stored in the <code>normComponents</code> array starting at <code>normOffset</code> (even if the array is allocated by this method).  An <code>ArrayIndexOutOfBoundsException</code> is thrown if the <code>normComponents</code> array is not <code>null</code> and is not large enough to hold all the color and alpha components (starting at <code>normOffset</code>). <p> This method must be overridden by a subclass if that subclass is designed to translate pixel sample values to color component values in a non-default way.  The default translations implemented by this class is described in the class comments.  Any subclass implementing a non-default translation must follow the constraints on allowable translations defined there.</td>
<td align="left">ArrayIndexOutOfBoundsException<br/>ClassCastException</td>
</tr>
<tr>
<td align="center"><strong>isCompatibleRaster(Raster raster): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns true if <CODE>raster</CODE> is compatible with this <CODE>ColorModel</CODE>; false if it is not.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>createCompatibleSampleModel(int w, int h): SampleModel</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Creates a <CODE>SampleModel</CODE> with the specified width and height, that  has a data layout compatible with this <CODE>ColorModel</CODE>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>isCompatibleSampleModel(SampleModel sm): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Checks whether or not the specified <CODE>SampleModel</CODE> is compatible with this <CODE>ColorModel</CODE>.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>getAlphaRaster(WritableRaster raster): WritableRaster</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Returns a <CODE>Raster</CODE> representing the alpha channel of an image, extracted from the input <CODE>Raster</CODE>. This method assumes that <CODE>Raster</CODE> objects associated with this <CODE>ColorModel</CODE> store the alpha band, if present, as the last band of image data. Returns null if there is no separate spatial alpha channel associated with this <CODE>ColorModel</CODE>. This method creates a new <CODE>Raster</CODE>, but will share the data array.</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>equals(Object obj): boolean</strong></td>
<td align="center">public</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">Compares this color model with another for equality.</td>
<td align="left"></td>
</tr>
</tbody></table>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/java-source-code-analysis/script/doc.js"></script>

    

  </body>
</html>
